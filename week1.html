<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Feelings Fun! üé≠</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&family=Nunito:wght@400;600;700;800&display=swap');

:root {
  --bg: #FFF8E7;
  --text: #2D3436;
  --card-bg: #FFFFFF;
  --shadow: rgba(45, 52, 54, 0.1);
  --radius: 20px;
  --accent: #A29BFE;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Nunito', sans-serif;
  background: var(--bg);
  min-height: 100vh;
  overflow-x: hidden;
}

body::before {
  content: '';
  position: fixed;
  inset: 0;
  background:
    radial-gradient(circle at 10% 20%, rgba(255,217,61,0.15) 0%, transparent 50%),
    radial-gradient(circle at 90% 80%, rgba(162,155,254,0.12) 0%, transparent 50%),
    radial-gradient(circle at 50% 50%, rgba(255,133,202,0.08) 0%, transparent 60%);
  pointer-events: none;
  z-index: 0;
}

.app { position: relative; z-index: 1; max-width: 900px; margin: 0 auto; padding: 16px; padding-top: 40px; }

.header {
  position: fixed; top: 0; left: 0; right: 0; z-index: 50;
  display: flex; align-items: center; justify-content: space-between;
  padding: 8px 14px;
  background: rgba(255,248,231,0.9);
  backdrop-filter: blur(8px);
}
.header h1 {
  font-family: 'Fredoka', sans-serif;
  font-size: 1.2rem;
  font-weight: 700;
  background: linear-gradient(135deg, #FF6B6B, #A29BFE, #FFD93D);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  line-height: 1;
  flex-shrink: 0;
}
.header .subtitle { display: none; }

.score-bar {
  display: flex; gap: 6px; flex-wrap: nowrap;
}
.score-item {
  background: rgba(255,255,255,0.9);
  backdrop-filter: blur(8px);
  padding: 4px 10px;
  border-radius: 50px;
  font-weight: 700;
  font-size: 0.75rem;
  box-shadow: 0 1px 6px var(--shadow);
  display: flex;
  align-items: center;
  gap: 4px;
  transition: transform 0.3s;
}
.score-item.pop { animation: pop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
@keyframes pop {
  0% { transform: scale(1); }
  30% { transform: scale(1.4); background: #FFD93D; color: #2D3436; }
  60% { transform: scale(0.95); }
  100% { transform: scale(1); }
}

.nav-groups { display: flex; gap: 6px; justify-content: center; margin: 16px 0; flex-wrap: wrap; }
.nav-group {
  display: flex; align-items: center; gap: 4px;
  background: #F0F0F5; border-radius: 50px; padding: 4px;
}
.nav-group-label {
  font-size: 0.65rem; color: #999; font-family: 'Fredoka', sans-serif;
  font-weight: 600; padding: 0 6px; white-space: nowrap;
}
.nav-tab {
  padding: 8px 14px;
  border-radius: 50px;
  border: none;
  background: transparent;
  font-family: 'Fredoka', sans-serif;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s;
  color: #636E72;
  white-space: nowrap;
}
.nav-tab:hover { background: rgba(255,255,255,0.7); }
.nav-tab.active {
  background: white;
  color: var(--text);
  box-shadow: 0 2px 8px var(--shadow);
}
.nav-tab .stamina-hint { font-size: 0.65rem; opacity: 0.6; }

.section { display: none; animation: fadeIn 0.4s ease; }
.section.active { display: block; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: none; } }

/* ===== LEARN ===== */
.feelings-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 14px;
  margin-top: 10px;
}
.feeling-card {
  background: var(--card-bg);
  border-radius: var(--radius);
  padding: 18px 12px;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  box-shadow: 0 3px 15px var(--shadow);
  border: 3px solid transparent;
  position: relative;
}
.feeling-card:hover { transform: translateY(-6px) scale(1.03); box-shadow: 0 8px 25px var(--shadow); }
.feeling-card:active { transform: scale(0.95); }
.feeling-card .emoji { font-size: 2.8rem; margin-bottom: 8px; display: block; }
.feeling-card .word { font-family: 'Fredoka', sans-serif; font-size: 1.15rem; font-weight: 600; color: var(--text); }
.feeling-card .chinese { font-size: 0.85rem; color: #636E72; margin-top: 2px; }
.feeling-card .speaker-hint {
  position: absolute; top: 8px; right: 8px;
  font-size: 1rem; opacity: 0.3; transition: opacity 0.2s;
}
.feeling-card:hover .speaker-hint { opacity: 0.7; }
.feeling-card.speaking {
  border-color: var(--accent);
  animation: speakRing 0.6s ease;
}
@keyframes speakRing {
  0%, 100% { box-shadow: 0 3px 15px var(--shadow); }
  50% { box-shadow: 0 0 0 6px rgba(162,155,254,0.3), 0 3px 15px var(--shadow); }
}

.sentence-practice {
  background: white;
  border-radius: var(--radius);
  padding: 24px;
  margin-top: 20px;
  box-shadow: 0 3px 15px var(--shadow);
  text-align: center;
}
.sentence-practice h3 { font-family: 'Fredoka', sans-serif; font-size: 1.2rem; color: var(--text); margin-bottom: 14px; }
.sentence-display {
  font-size: 1.6rem;
  font-family: 'Fredoka', sans-serif;
  font-weight: 600;
  color: #2D3436;
  padding: 14px;
  background: #F8F9FA;
  border-radius: 14px;
  margin-bottom: 14px;
  min-height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  flex-wrap: wrap;
  line-height: 1.4;
}
.sentence-display .hl { color: var(--accent); font-weight: 700; }

.btn-row { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
.speak-btn {
  padding: 12px 28px;
  border-radius: 50px;
  border: none;
  font-family: 'Fredoka', sans-serif;
  font-size: 1.1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s;
  display: inline-flex;
  align-items: center;
  gap: 8px;
}
.speak-btn:hover { transform: translateY(-2px); }
.speak-btn:active { transform: scale(0.95); }
.speak-btn.primary {
  background: linear-gradient(135deg, #A29BFE, #6C5CE7);
  color: white;
  box-shadow: 0 4px 15px rgba(108,92,231,0.3);
}
.speak-btn.secondary {
  background: linear-gradient(135deg, #FFD93D, #FDCB6E);
  color: #2D3436;
  box-shadow: 0 4px 15px rgba(253,203,110,0.3);
}
.speak-btn.small { padding: 8px 18px; font-size: 0.95rem; }
.speak-btn.playing { opacity: 0.7; pointer-events: none; }

.feeling-chips { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-top: 14px; }
.feeling-chip {
  padding: 8px 16px;
  border-radius: 50px;
  border: 2px solid #DFE6E9;
  background: white;
  font-family: 'Fredoka', sans-serif;
  font-size: 0.95rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}
.feeling-chip:hover { background: #F8F9FA; transform: scale(1.05); }
.feeling-chip.selected { border-color: var(--accent); background: #F0EDFF; }

/* ===== MATCH ===== */
.match-feedback {
  text-align: center; padding: 16px;
  font-family: 'Fredoka', sans-serif; font-size: 1.3rem; font-weight: 600;
  min-height: 56px; display: flex; align-items: center; justify-content: center;
}
.match-game { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start; }
.match-column h3 { font-family: 'Fredoka', sans-serif; text-align: center; margin-bottom: 12px; color: #636E72; font-size: 1rem; }
.match-item {
  padding: 14px 18px; border-radius: 14px; margin-bottom: 10px;
  cursor: pointer; transition: all 0.3s;
  font-family: 'Fredoka', sans-serif; font-size: 1.1rem; font-weight: 600;
  text-align: center; user-select: none;
  background: white; border: 3px solid #DFE6E9; box-shadow: 0 2px 10px var(--shadow);
}
.match-item.emoji-item { font-size: 2rem; }
.match-item:hover { transform: scale(1.05); }
.match-item.selected { border-color: var(--accent); background: #F0EDFF; box-shadow: 0 4px 16px rgba(162,155,254,0.3); }
.match-item.correct { border-color: #00B894; background: #E8FFF5; animation: correctBounce 0.5s ease; }
.match-item.wrong { border-color: #FF6B6B; background: #FFE8E8; animation: shake 0.4s ease; }
.match-item.matched { opacity: 0.35; pointer-events: none; transform: scale(0.95); }
@keyframes correctBounce { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.12); } }
@keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-8px); } 75% { transform: translateX(8px); } }

.reset-btn {
  display: block; margin: 16px auto 0;
  padding: 12px 32px; border-radius: 50px; border: none;
  background: linear-gradient(135deg, #FFD93D, #FDCB6E);
  color: #2D3436;
  font-family: 'Fredoka', sans-serif; font-size: 1.05rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
  box-shadow: 0 4px 15px rgba(253,203,110,0.3);
}
.reset-btn:hover { transform: translateY(-2px); }

/* ===== QUIZ ===== */
.quiz-container {
  background: white; border-radius: var(--radius); padding: 30px;
  box-shadow: 0 3px 15px var(--shadow); text-align: center;
}
.quiz-progress { display: flex; gap: 6px; justify-content: center; margin-bottom: 20px; }
.quiz-dot { width: 12px; height: 12px; border-radius: 50%; background: #DFE6E9; transition: all 0.3s; }
.quiz-dot.done { background: #00B894; }
.quiz-dot.current { background: var(--accent); transform: scale(1.3); }
.quiz-dot.wrong-dot { background: #FF6B6B; }
.quiz-prompt { font-size: 3.5rem; margin: 20px 0; }
.quiz-question { font-family: 'Fredoka', sans-serif; font-size: 1.3rem; color: #636E72; margin-bottom: 20px; }
.quiz-options { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; max-width: 500px; margin: 0 auto; }
.quiz-option {
  padding: 16px; border-radius: 14px; border: 3px solid #DFE6E9;
  background: white; font-family: 'Fredoka', sans-serif; font-size: 1.15rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
}
.quiz-option:hover { border-color: var(--accent); transform: translateY(-2px); }
.quiz-option.correct-answer { border-color: #00B894; background: #E8FFF5; }
.quiz-option.wrong-answer { border-color: #FF6B6B; background: #FFE8E8; }

.quiz-result { padding: 30px; text-align: center; }
.quiz-result .big-emoji { font-size: 4rem; margin-bottom: 16px; }
.quiz-result .result-text { font-family: 'Fredoka', sans-serif; font-size: 1.6rem; font-weight: 700; margin-bottom: 8px; }
.quiz-result .result-detail { font-size: 1.1rem; color: #636E72; margin-bottom: 20px; }

/* ===== SIGHT WORDS ===== */
.sight-words-area { display: flex; flex-direction: column; gap: 14px; }
.sight-word-card {
  background: white; border-radius: var(--radius); padding: 20px 24px;
  display: flex; align-items: center; justify-content: space-between;
  box-shadow: 0 3px 15px var(--shadow); cursor: pointer; transition: all 0.3s;
}
.sight-word-card:hover { transform: translateY(-3px); box-shadow: 0 6px 20px var(--shadow); }
.sight-word-card:active { transform: scale(0.97); }
.sight-word-text { font-family: 'Fredoka', sans-serif; font-size: 2rem; font-weight: 700; color: var(--text); }
.sight-word-chinese { font-size: 1rem; color: #636E72; margin-top: 2px; }
.sight-word-card .play-icon {
  width: 48px; height: 48px; border-radius: 50%;
  background: linear-gradient(135deg, #A29BFE, #6C5CE7);
  display: flex; align-items: center; justify-content: center;
  color: white; font-size: 1.3rem; flex-shrink: 0;
}
.sight-word-card.speaking { border-left: 5px solid var(--accent); }
.sight-word-card.earned { opacity: 0.6; }
.sight-word-card.earned .play-icon { background: #00B894; }
.sight-confirm {
  padding: 6px 14px; border-radius: 50px; border: none;
  background: linear-gradient(135deg, #FFD93D, #FDCB6E); color: #2D3436;
  font-family: 'Fredoka', sans-serif; font-size: 0.85rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s; animation: fadeIn 0.3s ease;
  margin-top: 6px;
}
.sight-confirm:hover { transform: scale(1.05); }
.sight-confirm:disabled { cursor: not-allowed; }

/* Speed toggle */
.speed-toggle {
  display: flex; gap: 6px; justify-content: center; margin: 10px 0;
}
.speed-btn {
  padding: 6px 14px; border-radius: 50px;
  border: 2px solid #DFE6E9; background: white;
  font-family: 'Fredoka', sans-serif; font-size: 0.85rem; font-weight: 600;
  cursor: pointer; color: #636E72; transition: all 0.2s;
}
.speed-btn.active { border-color: var(--accent); background: #F0EDFF; color: var(--accent); }

.settings-section { margin-bottom: 16px; }
.settings-label {
  font-family: 'Fredoka', sans-serif; font-size: 0.9rem;
  font-weight: 600; color: var(--text); margin-bottom: 6px;
}
.settings-reset {
  padding: 8px 20px; border-radius: 50px; border: 2px solid #FF6B6B;
  background: white; color: #FF6B6B;
  font-family: 'Fredoka', sans-serif; font-size: 0.85rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
}
.settings-reset:hover { background: #FF6B6B; color: white; }

.confetti-box { position: fixed; inset: 0; pointer-events: none; z-index: 100; }
.confetti-piece {
  position: absolute; width: 10px; height: 10px; border-radius: 2px;
  animation: confDrop 2s ease-out forwards;
}
@keyframes confDrop {
  0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
  100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
}

/* ===== MINE ===== */
.mine-header { text-align: center; margin-bottom: 12px; }
.mine-header h3 { font-family: 'Fredoka', sans-serif; font-size: 1.3rem; color: var(--text); }
.mine-pickaxe { font-size: 1rem; color: #636E72; margin-top: 4px; }
.mine-cost { font-size: 0.9rem; color: var(--accent); margin-top: 2px; }
.mine-hold-hint {
  font-size: 0.85rem; color: #A29BFE; margin-top: 4px;
  font-family: 'Fredoka', sans-serif; font-weight: 600;
  animation: holdHintPulse 2s ease-in-out infinite;
}
@keyframes holdHintPulse {
  0%, 100% { opacity: 0.7; }
  50% { opacity: 1; }
}

.mountain {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  margin: 0 auto;
  padding: 10px 0;
  background: linear-gradient(180deg, #87CEEB 0%, #87CEEB 20%, #E8D5B7 100%);
  border-radius: var(--radius);
  overflow: hidden;
}
.mountain-row {
  display: flex;
  gap: 2px;
}
.mine-cell {
  width: 38px; height: 38px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.3rem;
  cursor: pointer;
  transition: all 0.15s;
  border: 1px solid rgba(0,0,0,0.15);
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.2);
  position: relative;
  user-select: none;
}
.mine-cell:hover:not(.mined):not(.locked) { transform: scale(1.12); z-index: 2; box-shadow: 0 0 8px rgba(255,255,255,0.5); }

.mine-cell.unexposed { opacity: 0.85; cursor: default; }
.mine-cell.unexposed:hover { transform: none; box-shadow: inset 0 -2px 4px rgba(0,0,0,0.2); }
.mine-cell.mined {
  background: rgba(135,206,235,0.25) !important;
  border-color: transparent;
  box-shadow: none;
  pointer-events: none;
}
.mine-cell.locked {
  cursor: not-allowed;
  position: relative;
}
.mine-cell.locked::after {
  content: 'üîí';
  position: absolute;
  font-size: 0.8rem;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.4);
  border-radius: 4px;
}
.mine-cell .block-reveal {
  animation: blockPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
@keyframes blockPop {
  0% { transform: scale(0) rotate(-20deg); opacity: 0; }
  60% { transform: scale(1.3) rotate(5deg); opacity: 1; }
  100% { transform: scale(1) rotate(0); }
}
.mine-cell.tier1 { background: linear-gradient(180deg, #8B6F47, #6B4F37); }
.mine-cell.tier2 { background: linear-gradient(180deg, #7F8C8D, #616A6B); }
.mine-cell.tier3 { background: linear-gradient(180deg, #5D6D7E, #4A5568); }
.mine-cell.tier4 { background: linear-gradient(180deg, #6B4C3B, #4A3728); }
.mine-cell.tier5 { background: linear-gradient(180deg, #2C3E6D, #1A2547); }
.mine-cell.tree { background: none; border: none; box-shadow: none; font-size: 1.5rem; cursor: pointer; }
.mine-cell.tree:hover { transform: scale(1.15); }
.mine-cell.tree.mined { background: none !important; border: none; box-shadow: none; opacity: 0; pointer-events: none; }
.mine-cell.animal { background: none; border: none; box-shadow: none; font-size: 1.5rem; cursor: pointer; }
.mine-cell.animal:hover { transform: scale(1.15); }
.mine-cell.animal.mined { background: none !important; border: none; box-shadow: none; opacity: 0; pointer-events: none; }

.mine-result {
  text-align: center; margin-top: 12px; padding: 10px;
  font-family: 'Fredoka', sans-serif; font-size: 1.05rem; font-weight: 600;
  min-height: 44px;
}
.mine-refresh {
  display: block; margin: 10px auto 0;
  padding: 10px 28px; border-radius: 50px; border: none;
  background: linear-gradient(135deg, #A29BFE, #6C5CE7);
  color: white;
  font-family: 'Fredoka', sans-serif; font-size: 1rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
  box-shadow: 0 4px 15px rgba(108,92,231,0.3);
}
.mine-refresh:hover { transform: translateY(-2px); }
.mine-refresh:disabled { opacity: 0.4; pointer-events: none; }

/* ===== COLLECTION ===== */
.collection-tabs { display: flex; gap: 8px; justify-content: center; margin-bottom: 16px; }
.collection-tab {
  padding: 8px 16px; border-radius: 50px; border: 2px solid #DFE6E9;
  background: white; font-family: 'Fredoka', sans-serif; font-size: 0.9rem;
  font-weight: 600; cursor: pointer; color: #636E72; transition: all 0.2s;
}
.collection-tab.active { border-color: var(--accent); background: #F0EDFF; color: var(--accent); }

.encyclopedia-grid {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
  gap: 12px;
}
.block-card {
  background: white; border-radius: var(--radius); padding: 14px;
  text-align: center; box-shadow: 0 2px 10px var(--shadow);
  border: 3px solid #DFE6E9; transition: all 0.3s;
}
.block-card.owned { border-color: #00B894; }
.block-card.undiscovered { opacity: 0.4; }
.block-card .block-emoji { font-size: 2.2rem; margin-bottom: 6px; }
.block-card .block-name { font-family: 'Fredoka', sans-serif; font-size: 1rem; font-weight: 600; }
.block-card .block-count { font-size: 0.85rem; color: #636E72; margin-top: 2px; }
.block-card .block-tier { font-size: 0.7rem; color: var(--accent); margin-top: 2px; }

.craft-area { max-width: 500px; margin: 0 auto; }
.craft-current { text-align: center; font-family: 'Fredoka', sans-serif; color: #636E72; margin-bottom: 12px; font-size: 1rem; }
.craft-guide {
  text-align: center; font-family: 'Fredoka', sans-serif;
  font-size: 0.85rem; color: #636E72; margin-bottom: 12px;
  background: #F0FFF8; padding: 8px 16px; border-radius: 50px;
  border: 1px dashed #00B894;
}

.craft-table {
  display: flex; align-items: center; justify-content: center;
  gap: 16px; flex-wrap: wrap; margin-bottom: 16px;
}
.craft-grid {
  display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px;
  background: #8B6F47; padding: 8px; border-radius: 12px;
  box-shadow: inset 0 2px 6px rgba(0,0,0,0.3), 0 3px 10px var(--shadow);
}
.craft-slot {
  width: 52px; height: 52px; border-radius: 6px;
  background: #A0855C; border: 2px solid #6B4F37;
  display: flex; align-items: center; justify-content: center;
  font-size: 1.6rem; cursor: pointer; transition: all 0.15s;
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.15);
}
.craft-slot:hover { background: #B8976A; transform: scale(1.05); }
.craft-slot.filled { background: #C4A97D; border-color: #8B6F47; }

.craft-arrow { font-size: 1.8rem; color: #636E72; }

.craft-result-slot {
  width: 64px; height: 64px; border-radius: 8px;
  background: #A0855C; border: 3px solid #6B4F37;
  display: flex; align-items: center; justify-content: center;
  font-size: 2rem; position: relative;
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.15);
}
.craft-result-slot.matched {
  border-color: #00B894; background: #C4A97D;
  animation: correctBounce 0.5s ease;
}

.craft-actions { display: flex; gap: 8px; justify-content: center; margin-bottom: 16px; }
.craft-btn {
  padding: 10px 24px; border-radius: 50px; border: none;
  font-family: 'Fredoka', sans-serif; font-size: 1rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
}
.craft-btn:hover { transform: translateY(-2px); }
.craft-btn:disabled { opacity: 0.4; pointer-events: none; }
.craft-btn.primary { background: linear-gradient(135deg, #00B894, #00CEC9); color: white; box-shadow: 0 4px 15px rgba(0,184,148,0.3); }
.craft-btn.secondary { background: linear-gradient(135deg, #DFE6E9, #BDC3C7); color: #2D3436; }

.craft-inventory {
  background: #8B6F47; border-radius: 12px; padding: 10px;
  box-shadow: inset 0 2px 6px rgba(0,0,0,0.3), 0 3px 10px var(--shadow);
}
.craft-inv-title {
  font-family: 'Fredoka', sans-serif; font-size: 0.9rem;
  color: #FFFFFF; margin-bottom: 8px; text-align: center;
}
.craft-inv-grid {
  display: flex; flex-wrap: wrap; gap: 4px; justify-content: center;
}
.craft-inv-item {
  width: 48px; height: 48px; border-radius: 6px;
  background: #A0855C; border: 2px solid #6B4F37;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  font-size: 1.2rem; cursor: pointer; transition: all 0.15s;
  position: relative;
}
.craft-inv-item:hover { background: #B8976A; transform: scale(1.08); }
.craft-inv-item.selected { border-color: #FFD93D; background: #C4A97D; box-shadow: 0 0 8px rgba(255,217,61,0.5); }
.craft-inv-item .inv-count {
  font-size: 0.55rem; font-weight: 700; color: #FFF;
  background: rgba(0,0,0,0.5); border-radius: 4px; padding: 0 3px;
  position: absolute; bottom: 2px; right: 2px;
}

.recipe-book { margin-top: 20px; }
.recipe-book-title {
  font-family: 'Fredoka', sans-serif; font-size: 1.1rem; font-weight: 600;
  color: var(--text); text-align: center; margin-bottom: 12px;
}
.recipe-list { display: flex; flex-direction: column; gap: 10px; }
.recipe-card {
  background: white; border-radius: 14px; padding: 12px 16px;
  box-shadow: 0 2px 10px var(--shadow); display: flex; align-items: center; gap: 12px;
  border: 2px solid #DFE6E9; transition: all 0.2s;
}
.recipe-card.craftable { border-color: #00B894; background: #F0FFF8; }
.recipe-card.crafted { border-color: #B2BEC3; opacity: 0.5; }
.recipe-mini-grid {
  display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px;
  background: #8B6F47; padding: 4px; border-radius: 6px; flex-shrink: 0;
}
.recipe-mini-slot {
  width: 28px; height: 28px; border-radius: 3px;
  background: #A0855C; display: flex; align-items: center; justify-content: center;
  font-size: 0.9rem;
}
.recipe-arrow { color: #636E72; font-size: 1.2rem; flex-shrink: 0; }
.recipe-result { font-size: 1.4rem; flex-shrink: 0; }
.recipe-info { flex: 1; }
.recipe-name { font-family: 'Fredoka', sans-serif; font-weight: 600; font-size: 0.95rem; }
.recipe-needs { font-size: 0.8rem; color: #636E72; margin-top: 2px; }
.recipe-needs .has { color: #00B894; }
.recipe-needs .need { color: #FF6B6B; }
.recipe-category { margin-bottom: 12px; }
.recipe-category-header {
  font-family: 'Fredoka', sans-serif; font-size: 1rem; font-weight: 600;
  color: var(--text); padding: 8px 12px; cursor: pointer;
  background: #F0F0F5; border-radius: 10px; margin-bottom: 8px;
  transition: all 0.2s; user-select: none;
}
.recipe-category-header:hover { background: #E0E0E8; }
.recipe-category-header.collapsed::after { content: ' ‚ñ∏'; }
.recipe-category-header:not(.collapsed)::after { content: ' ‚ñæ'; }

.house-area { text-align: center; max-width: 400px; margin: 0 auto; }
.house-visual {
  font-size: 1.2rem; line-height: 1.8;
  background: white; border-radius: var(--radius); padding: 24px;
  box-shadow: 0 2px 10px var(--shadow); margin-bottom: 16px;
  min-height: 180px; display: flex; align-items: center; justify-content: center;
  white-space: pre; font-family: 'Fredoka', sans-serif;
}
.house-stage {
  background: white; border-radius: 14px; padding: 14px 18px;
  margin-bottom: 10px; box-shadow: 0 2px 10px var(--shadow);
  display: flex; align-items: center; justify-content: space-between;
}
.house-stage.done { border-left: 4px solid #00B894; }
.house-stage.current { border-left: 4px solid var(--accent); }
.house-stage.locked { opacity: 0.5; }
.house-stage-info { text-align: left; }
.house-stage-name { font-family: 'Fredoka', sans-serif; font-weight: 600; }
.house-stage-needs { font-size: 0.85rem; color: #636E72; margin-top: 2px; }
.house-build-btn {
  padding: 8px 18px; border-radius: 50px; border: none;
  background: linear-gradient(135deg, #FFD93D, #FDCB6E); color: #2D3436;
  font-family: 'Fredoka', sans-serif; font-size: 0.9rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
}
.house-build-btn:disabled { opacity: 0.4; pointer-events: none; }

/* ===== SETTINGS MODAL ===== */
.modal-overlay {
  display: none;
  position: fixed; inset: 0;
  background: rgba(45, 52, 54, 0.5);
  z-index: 200;
  justify-content: center;
  align-items: center;
}
.modal-overlay.active {
  display: flex;
}
.modal-content {
  background: white;
  border-radius: var(--radius);
  padding: 24px;
  width: 90%;
  max-width: 360px;
  box-shadow: 0 8px 32px rgba(45, 52, 54, 0.2);
  animation: fadeIn 0.3s ease;
}
.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-family: 'Fredoka', sans-serif;
  font-size: 1.2rem;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 16px;
}
.modal-close {
  background: none; border: none;
  font-size: 1.3rem; cursor: pointer;
  color: #B2BEC3; transition: color 0.2s;
  padding: 4px 8px; line-height: 1;
}
.modal-close:hover { color: var(--text); }
.settings-btn {
  cursor: pointer; border: none;
  background: rgba(255,255,255,0.9);
  min-width: 36px; min-height: 36px;
  display: flex; align-items: center; justify-content: center;
}
.settings-btn:hover { transform: scale(1.15); }

@media (max-width: 600px) {
  .header { padding: 6px 10px; }
  .header h1 { font-size: 1rem; }
  .score-item { padding: 3px 8px; font-size: 0.7rem; }
  .feelings-grid { grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap: 10px; }
  .feeling-card { padding: 14px 8px; }
  .feeling-card .emoji { font-size: 2.2rem; }
  .match-game { grid-template-columns: 1fr; }
  .quiz-options { grid-template-columns: 1fr; }
  .nav-groups { gap: 4px; }
  .nav-group { padding: 3px; }
  .nav-group-label { font-size: 0; width: 0; padding: 0; overflow: hidden; }
  .stamina-hint { display: none; }
  .nav-tab { padding: 8px 12px; font-size: 0.85rem; }
  .sentence-display { font-size: 1.2rem; }
  .mine-cell { width: 38px; height: 38px; font-size: 1.2rem; }
  .mine-cell.tree { font-size: 1.4rem; }
  .mine-cell.animal { font-size: 1.4rem; }
  .encyclopedia-grid { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); }
  .craft-slot { width: 44px; height: 44px; font-size: 1.3rem; }
  .craft-result-slot { width: 52px; height: 52px; font-size: 1.6rem; }
  .craft-inv-item { width: 44px; height: 44px; font-size: 1.1rem; }
  .collection-tab { padding: 6px 12px; font-size: 0.8rem; }
  .character-display.small { display: none; }
  .equip-slot { min-width: 160px; padding: 6px 10px; }
  .equip-inv-item { width: 40px; height: 40px; font-size: 1.2rem; }
  .modal-content { min-width: auto; width: 90vw; }
}
.mine-progress {
  position: absolute; bottom: 0; left: 0; right: 0; height: 7px;
  background: rgba(0,0,0,0.2); border-radius: 0 0 4px 4px;
  overflow: hidden;
}
.mine-progress-fill {
  height: 100%; width: 0%; background: #00B894;
  transition: none;
}
.character-display {
  display: flex; flex-direction: column; align-items: center;
  gap: 2px; margin: 16px auto;
}
.character-row { font-size: 2rem; line-height: 1.1; text-align: center; }
.character-display.small { margin: 0; }
.character-display.small .character-row { font-size: 1.2rem; }

.equip-area { text-align: center; }
.equip-slots {
  display: flex; flex-direction: column; align-items: center;
  gap: 8px; margin: 16px 0;
}
.equip-slot {
  display: flex; align-items: center; gap: 12px;
  background: white; padding: 8px 16px; border-radius: 12px;
  box-shadow: 0 2px 8px rgba(45, 52, 54, 0.1); min-width: 200px;
  cursor: pointer; transition: all 0.2s;
}
.equip-slot:hover { transform: scale(1.02); box-shadow: 0 4px 12px rgba(45, 52, 54, 0.1); }
.equip-slot-label { font-size: 0.8rem; color: #636E72; font-family: 'Fredoka', sans-serif; min-width: 50px; }
.equip-slot-item { font-size: 1.3rem; }
.equip-slot-name { font-family: 'Fredoka', sans-serif; font-size: 0.9rem; }
.equip-slot-empty { color: #B2BEC3; font-style: italic; }

.equip-inventory {
  display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;
  margin-top: 16px; padding: 12px;
  background: #F0F0F5; border-radius: 12px;
}
.equip-inv-item {
  width: 48px; height: 48px;
  display: flex; align-items: center; justify-content: center;
  font-size: 1.5rem; background: white; border-radius: 8px;
  cursor: pointer; transition: all 0.2s; position: relative;
  box-shadow: 0 1px 4px rgba(45, 52, 54, 0.1);
}
.equip-inv-item:hover { transform: scale(1.1); }
</style>
</head>
<body>

<div class="app">
  <div class="header">
    <h1>Feelings Fun! üé≠</h1>
    <div class="subtitle">Â≠∏ÁøíË°®ÈÅîÊÉÖÁ∑íÁöÑËã±Êñá ¬∑ Learn to express feelings</div>
    <div class="score-bar">
      <div class="score-item" id="starBar"><span>‚≠ê</span> <span id="stars">0</span></div>
      <div class="score-item" id="streakBar"><span>üî•</span> <span id="streak">0</span></div>
      <div class="score-item" id="gemBar"><span>‚ö°</span> <span id="gems">0</span></div>
      <button class="score-item settings-btn" id="settingsBtn">‚öôÔ∏è</button>
    </div>
  </div>

  <div class="nav-groups">
    <div class="nav-group">
      <div class="nav-group-label">üìö Â≠∏Áøí</div>
      <div class="nav-group-tabs">
        <button class="nav-tab active" data-tab="learn">üìñ Learn</button>
      </div>
    </div>
    <div class="nav-group">
      <div class="nav-group-label">üèÜ ÊåëÊà∞</div>
      <div class="nav-group-tabs">
        <button class="nav-tab" data-tab="sight">üëÄ Sight <span class="stamina-hint">+‚ö°</span></button>
        <button class="nav-tab" data-tab="match">üéØ Match <span class="stamina-hint">+‚ö°</span></button>
        <button class="nav-tab" data-tab="quiz">üß† Quiz <span class="stamina-hint">+‚ö°</span></button>
      </div>
    </div>
    <div class="nav-group">
      <div class="nav-group-label">‚õèÔ∏è ÈÅäÊà≤</div>
      <div class="nav-group-tabs">
        <button class="nav-tab" data-tab="mine">‚õèÔ∏è Mine</button>
        <button class="nav-tab" data-tab="collection">üì¶ Êî∂Ëóè</button>
      </div>
    </div>
  </div>

  <div id="learn" class="section active">
    <div class="feelings-grid" id="feelingsGrid"></div>
    <div class="sentence-practice">
      <h3>üó£Ô∏è Practice Sentences ÈÄ†Âè•Á∑¥Áøí</h3>
      <div class="sentence-display" id="sentenceDisplay">I feel <span class="hl">happy</span>. üòä</div>
      <div class="btn-row">
        <button class="speak-btn primary" id="speakSentenceBtn">üîä Listen ËÅΩÁôºÈü≥</button>
        <button class="speak-btn secondary" id="randomSentenceBtn">üé≤ Random Èö®Ê©ü</button>
      </div>
      <div class="feeling-chips" id="feelingChips"></div>
    </div>
  </div>

  <div id="match" class="section">
    <div class="match-feedback" id="matchFeedback">Èªû‰∏ÄÂÄãÂñÆÂ≠óÔºåÂÜçÈªûÈÖçÂ∞çÁöÑË°®ÊÉÖÔºÅ üéØ</div>
    <div class="match-game" id="matchGame">
      <div class="match-column" id="matchWords"><h3>Words ÂñÆÂ≠ó</h3></div>
      <div class="match-column" id="matchEmojis"><h3>Emoji Ë°®ÊÉÖ</h3></div>
    </div>
    <button class="reset-btn" id="resetMatch">üîÑ New Round ÂÜç‰æÜ‰∏ÄÊ¨°</button>
  </div>

  <div id="quiz" class="section">
    <div class="quiz-container" id="quizContainer"></div>
  </div>

  <div id="sight" class="section">
    <div class="sight-words-area" id="sightWordsArea"></div>
  </div>

  <div id="mine" class="section">
    <div id="mineArea"></div>
  </div>

  <div id="collection" class="section">
    <div id="collectionArea"></div>
  </div>
</div>

<div class="confetti-box" id="confettiBox"></div>

<div class="modal-overlay" id="settingsModal">
  <div class="modal-content">
    <div class="modal-header">
      <span>‚öôÔ∏è Ë®≠ÂÆö</span>
      <button class="modal-close" id="settingsClose">‚úï</button>
    </div>
    <div class="settings-section">
      <div class="settings-label">üîä Ë™ûÈÄü Speed</div>
      <div class="speed-toggle">
        <button class="speed-btn" data-speed="slow" id="speedSlow">üê¢ Slow</button>
        <button class="speed-btn active" data-speed="normal" id="speedNormal">üêá Normal</button>
      </div>
    </div>
    <div class="settings-section">
      <div class="settings-label">üîá ÈùúÈü≥ Mute</div>
      <div class="speed-toggle">
        <button class="speed-btn" id="muteOff">üîä Èñã</button>
        <button class="speed-btn active" id="muteOn">üîá Èóú</button>
      </div>
    </div>
    <div class="settings-section">
      <div class="settings-label">üóëÔ∏è ÈáçÁΩÆÈÄ≤Â∫¶</div>
      <button class="settings-reset" id="resetProgress">ÈáçÁΩÆÊâÄÊúâË≥áÊñô</button>
    </div>
    <div id="engineStatus" style="text-align:center;font-size:0.8rem;color:#B2BEC3;margin-top:12px;font-family:'Nunito',sans-serif;">üîç ÂÅµÊ∏¨‰∏≠...</div>
    <div style="text-align:center;font-size:0.7rem;color:#B2BEC3;margin-top:8px;font-family:'Nunito',sans-serif;">v2.5.0</div>
  </div>
</div>

<script>
// ===== DATA =====
const feelings = [
  { word: 'happy',   zh: 'ÈñãÂøÉÁöÑ', emoji: 'üòä', color: '#FFD93D' },
  { word: 'sad',     zh: 'Èõ£ÈÅéÁöÑ', emoji: 'üò¢', color: '#74B9FF' },
  { word: 'angry',   zh: 'ÁîüÊ∞£ÁöÑ', emoji: 'üò†', color: '#FF6B6B' },
  { word: 'excited', zh: 'ËààÂ•ÆÁöÑ', emoji: 'ü§©', color: '#FF85CA' },
  { word: 'silly',   zh: 'ÂÇªÂÇªÁöÑ', emoji: 'ü§™', color: '#A29BFE' },
  { word: 'tired',   zh: 'Á¥ØÁöÑ',   emoji: 'üò¥', color: '#B2BEC3' },
  { word: 'scared',  zh: 'ÂÆ≥ÊÄïÁöÑ', emoji: 'üò®', color: '#81ECEC' },
  { word: 'bored',   zh: 'ÁÑ°ËÅäÁöÑ', emoji: 'üòë', color: '#FFEAA7' },
  { word: 'sick',    zh: '‰∏çËàíÊúçÁöÑ', emoji: 'ü§í', color: '#55EFC4' },
  { word: 'proud',   zh: 'È©ïÂÇ≤ÁöÑ', emoji: 'üòé', color: '#FD79A8' },
  { word: 'brave',   zh: 'ÂãáÊï¢ÁöÑ', emoji: 'üí™', color: '#E17055' },
  { word: 'mad',     zh: 'ÂæàÁîüÊ∞£', emoji: 'üò§', color: '#D63031' },
];

const sightWords = [
  { word: 'door',  zh: 'ÈñÄ', sentence: 'Open the door.' },
  { word: 'down',  zh: '‰∏ãÈù¢', sentence: 'Sit down please.' },
  { word: 'dress', zh: 'Ê¥ãË£ù', sentence: 'I like your dress.' },
  { word: 'duck',  zh: 'È¥®Â≠ê', sentence: 'Look at the duck!' },
  { word: 'each',  zh: 'ÊØè‰∏ÄÂÄã', sentence: 'Give one to each child.' },
  { word: 'egg',   zh: 'Ëõã', sentence: 'I eat an egg.' },
  { word: 'every', zh: 'ÊØèÂÄã', sentence: 'Every day is special.' },
];
const sightColors = ['#FF6B6B','#A29BFE','#FFD93D','#00B894','#FF85CA','#74B9FF','#E17055'];

// ===== MINING DATA =====
const blocks = [
  { id: 'dirt',     name: 'Ê≥•Âúü',   emoji: 'üü´', tier: 1, weight: 40 },
  { id: 'wood',     name: 'Êú®È†≠',   emoji: 'ü™µ', tier: 1, weight: 35 },
  { id: 'stick',    name: 'Êú®Ê£ç',   emoji: 'ü•¢', tier: 0, weight: 0 },
  { id: 'stone',    name: 'Áü≥È†≠',   emoji: 'ü™®', tier: 2, weight: 30 },
  { id: 'coal',     name: 'ÁÖ§ÁÇ≠',   emoji: '‚¨õ', tier: 2, weight: 25 },
  { id: 'iron',     name: 'ÈêµÁ§¶',   emoji: '‚¨ú', tier: 3, weight: 18 },
  { id: 'copper',   name: 'ÈäÖÁ§¶',   emoji: 'üüß', tier: 3, weight: 15 },
  { id: 'gold',     name: 'ÈáëÁ§¶',   emoji: 'üü°', tier: 4, weight: 8 },
  { id: 'emerald',  name: 'Á∂†ÂØ∂Áü≥', emoji: 'üíö', tier: 4, weight: 5 },
  { id: 'diamond',  name: 'ÈëΩÁü≥',   emoji: 'üíé', tier: 5, weight: 3 },
  { id: 'amethyst', name: 'Á¥´Ê∞¥Êô∂', emoji: 'üü£', tier: 5, weight: 2 },
  // Animal drops (tier 0, weight 0 = drop-only)
  { id: 'leather',      name: 'ÁöÆÈù©',   emoji: 'üü§', tier: 0, weight: 0 },
  { id: 'pork',         name: 'Ë±¨Êéí',   emoji: 'üçñ', tier: 0, weight: 0 },
  { id: 'chicken_meat', name: 'ÈõûËÇâ',   emoji: 'üçó', tier: 0, weight: 0 },
  { id: 'feather',      name: 'ÁæΩÊØõ',   emoji: 'ü™∂', tier: 0, weight: 0 },
  { id: 'wool',         name: 'ÁæäÊØõ',   emoji: 'üß∂', tier: 0, weight: 0 },
  // Tools (tier 0, weight 0 = never mined, only crafted)
  { id: 'stone_pick',   name: 'Áü≥Èé¨',   emoji: '‚õèÔ∏è', tier: 0, weight: 0 },
  { id: 'iron_pick',    name: 'ÈêµÈé¨',   emoji: '‚õèÔ∏è', tier: 0, weight: 0 },
  { id: 'gold_pick',    name: 'ÈáëÈé¨',   emoji: 'üî±', tier: 0, weight: 0 },
  { id: 'diamond_pick', name: 'ÈëΩÁü≥Èé¨', emoji: '‚õèÔ∏è', tier: 0, weight: 0 },
  { id: 'stone_axe',    name: 'Áü≥Êñß',   emoji: 'ü™ì', tier: 0, weight: 0 },
  { id: 'iron_axe',     name: 'ÈêµÊñß',   emoji: 'ü™ì', tier: 0, weight: 0 },
  { id: 'gold_axe',     name: 'ÈáëÊñß',   emoji: 'ü™ì', tier: 0, weight: 0 },
  { id: 'diamond_axe',  name: 'ÈëΩÁü≥Êñß', emoji: 'ü™ì', tier: 0, weight: 0 },
  { id: 'stone_sword',   name: 'Áü≥Âäç',   emoji: 'üó°Ô∏è', tier: 0, weight: 0 },
  { id: 'iron_sword',    name: 'ÈêµÂäç',   emoji: 'üó°Ô∏è', tier: 0, weight: 0 },
  { id: 'gold_sword',    name: 'ÈáëÂäç',   emoji: 'üó°Ô∏è', tier: 0, weight: 0 },
  { id: 'diamond_sword', name: 'ÈëΩÁü≥Âäç', emoji: 'üó°Ô∏è', tier: 0, weight: 0 },
  // Armor items (tier 0, weight 0)
  { id: 'leather_helmet',  name: 'ÁöÆÈù©È†≠Áõî', emoji: 'ü™ñ', tier: 0, weight: 0 },
  { id: 'leather_chest',   name: 'ÁöÆÈù©ÁõîÁî≤', emoji: 'ü¶∫', tier: 0, weight: 0 },
  { id: 'leather_legs',    name: 'ÁöÆÈù©Ë§≤Â≠ê', emoji: 'üëñ', tier: 0, weight: 0 },
  { id: 'leather_boots',   name: 'ÁöÆÈù©ÈûãÂ≠ê', emoji: 'üë¢', tier: 0, weight: 0 },
  { id: 'iron_helmet',     name: 'ÈêµÈ†≠Áõî',   emoji: 'ü™ñ', tier: 0, weight: 0 },
  { id: 'iron_chest',      name: 'ÈêµÁõîÁî≤',   emoji: 'ü¶∫', tier: 0, weight: 0 },
  { id: 'iron_legs',       name: 'ÈêµË§≤Â≠ê',   emoji: 'üëñ', tier: 0, weight: 0 },
  { id: 'iron_boots',      name: 'ÈêµÈûãÂ≠ê',   emoji: 'üë¢', tier: 0, weight: 0 },
  { id: 'gold_helmet',     name: 'ÈáëÈ†≠Áõî',   emoji: 'ü™ñ', tier: 0, weight: 0 },
  { id: 'gold_chest',      name: 'ÈáëÁõîÁî≤',   emoji: 'ü¶∫', tier: 0, weight: 0 },
  { id: 'gold_legs',       name: 'ÈáëË§≤Â≠ê',   emoji: 'üëñ', tier: 0, weight: 0 },
  { id: 'gold_boots',      name: 'ÈáëÈûãÂ≠ê',   emoji: 'üë¢', tier: 0, weight: 0 },
  { id: 'diamond_helmet',  name: 'ÈëΩÁü≥È†≠Áõî', emoji: 'ü™ñ', tier: 0, weight: 0 },
  { id: 'diamond_chest',   name: 'ÈëΩÁü≥ÁõîÁî≤', emoji: 'ü¶∫', tier: 0, weight: 0 },
  { id: 'diamond_legs',    name: 'ÈëΩÁü≥Ë§≤Â≠ê', emoji: 'üëñ', tier: 0, weight: 0 },
  { id: 'diamond_boots',   name: 'ÈëΩÁü≥ÈûãÂ≠ê', emoji: 'üë¢', tier: 0, weight: 0 },
];

const pickaxes = [
  { id: 'wood_pick',    name: 'Êú®Èé¨',   emoji: '‚õèÔ∏è', maxTier: 2, durability: Infinity, recipe: null, pattern: null },
  { id: 'stone_pick',   name: 'Áü≥Èé¨',   emoji: '‚õèÔ∏è', maxTier: 3, durability: 30,
    recipe: { stick: 2, stone: 3 },
    pattern: ['stone','stone','stone', null,'stick',null, null,'stick',null] },
  { id: 'iron_pick',    name: 'ÈêµÈé¨',   emoji: '‚õèÔ∏è', maxTier: 5, durability: 60,
    recipe: { stick: 2, iron: 3 },
    pattern: ['iron','iron','iron', null,'stick',null, null,'stick',null] },
  { id: 'gold_pick',    name: 'ÈáëÈé¨',   emoji: 'üî±', maxTier: 4, durability: 25,
    recipe: { stick: 2, gold: 3 },
    pattern: ['gold','gold','gold', null,'stick',null, null,'stick',null] },
  { id: 'diamond_pick', name: 'ÈëΩÁü≥Èé¨', emoji: '‚õèÔ∏è', maxTier: 5, durability: 150,
    recipe: { stick: 2, diamond: 3 },
    pattern: ['diamond','diamond','diamond', null,'stick',null, null,'stick',null] },
];

// Axe recipes (XX. / XS. / .S.)
const axes = [
  { id: 'stone_axe',   name: 'Áü≥Êñß',   emoji: 'ü™ì', woodBonus: 2, durability: 30,
    recipe: { stick: 2, stone: 3 },
    pattern: ['stone','stone',null, 'stone','stick',null, null,'stick',null] },
  { id: 'iron_axe',    name: 'ÈêµÊñß',   emoji: 'ü™ì', woodBonus: 3, durability: 60,
    recipe: { stick: 2, iron: 3 },
    pattern: ['iron','iron',null, 'iron','stick',null, null,'stick',null] },
  { id: 'gold_axe',    name: 'ÈáëÊñß',   emoji: 'ü™ì', woodBonus: 3, durability: 25,
    recipe: { stick: 2, gold: 3 },
    pattern: ['gold','gold',null, 'gold','stick',null, null,'stick',null] },
  { id: 'diamond_axe', name: 'ÈëΩÁü≥Êñß', emoji: 'ü™ì', woodBonus: 4, durability: 150,
    recipe: { stick: 2, diamond: 3 },
    pattern: ['diamond','diamond',null, 'diamond','stick',null, null,'stick',null] },
];

const animals = [
  { id: 'cow',     name: 'Áâõ',  emoji: 'üêÑ', drops: [{ id: 'leather', min: 1, max: 2 }] },
  { id: 'pig',     name: 'Ë±¨',  emoji: 'üê∑', drops: [{ id: 'pork', min: 1, max: 1 }] },
  { id: 'chicken', name: 'Èõû',  emoji: 'üêî', drops: [{ id: 'chicken_meat', min: 1, max: 1 }, { id: 'feather', min: 1, max: 1 }] },
  { id: 'sheep',   name: 'Áæä',  emoji: 'üêë', drops: [{ id: 'wool', min: 1, max: 2 }] },
];

const swords = [
  { id: 'wood_sword',    name: 'Êú®Âäç',   emoji: 'üó°Ô∏è', holdTime: 1500, durability: Infinity, recipe: null, pattern: null },
  { id: 'stone_sword',   name: 'Áü≥Âäç',   emoji: 'üó°Ô∏è', holdTime: 1000, durability: 30,
    recipe: { stick: 1, stone: 2 },
    pattern: [null,'stone',null, null,'stone',null, null,'stick',null] },
  { id: 'iron_sword',    name: 'ÈêµÂäç',   emoji: 'üó°Ô∏è', holdTime: 700, durability: 60,
    recipe: { stick: 1, iron: 2 },
    pattern: [null,'iron',null, null,'iron',null, null,'stick',null] },
  { id: 'gold_sword',    name: 'ÈáëÂäç',   emoji: 'üó°Ô∏è', holdTime: 700, durability: 25,
    recipe: { stick: 1, gold: 2 },
    pattern: [null,'gold',null, null,'gold',null, null,'stick',null] },
  { id: 'diamond_sword', name: 'ÈëΩÁü≥Âäç', emoji: 'üó°Ô∏è', holdTime: 400, durability: 150,
    recipe: { stick: 1, diamond: 2 },
    pattern: [null,'diamond',null, null,'diamond',null, null,'stick',null] },
];

const armorSlots = ['helmet', 'chest', 'legs', 'boots'];
const armorMaterials = [
  { id: 'leather', name: 'ÁöÆÈù©', emoji: 'üü§' },
  { id: 'iron',    name: 'Èêµ',   emoji: '‚¨ú' },
  { id: 'gold',    name: 'Èáë',   emoji: 'üü°' },
  { id: 'diamond', name: 'ÈëΩÁü≥', emoji: 'üíé' },
];

const armorRecipes = [
  // Helmets: XXX / X_X / ___
  { outputId: 'leather_helmet', material: 'leather', slot: 'helmet', recipe: { leather: 5 },
    pattern: ['leather','leather','leather', 'leather',null,'leather', null,null,null] },
  { outputId: 'iron_helmet', material: 'iron', slot: 'helmet', recipe: { iron: 5 },
    pattern: ['iron','iron','iron', 'iron',null,'iron', null,null,null] },
  { outputId: 'gold_helmet', material: 'gold', slot: 'helmet', recipe: { gold: 5 },
    pattern: ['gold','gold','gold', 'gold',null,'gold', null,null,null] },
  { outputId: 'diamond_helmet', material: 'diamond', slot: 'helmet', recipe: { diamond: 5 },
    pattern: ['diamond','diamond','diamond', 'diamond',null,'diamond', null,null,null] },
  // Chestplates: X_X / XXX / XXX
  { outputId: 'leather_chest', material: 'leather', slot: 'chest', recipe: { leather: 8 },
    pattern: ['leather',null,'leather', 'leather','leather','leather', 'leather','leather','leather'] },
  { outputId: 'iron_chest', material: 'iron', slot: 'chest', recipe: { iron: 8 },
    pattern: ['iron',null,'iron', 'iron','iron','iron', 'iron','iron','iron'] },
  { outputId: 'gold_chest', material: 'gold', slot: 'chest', recipe: { gold: 8 },
    pattern: ['gold',null,'gold', 'gold','gold','gold', 'gold','gold','gold'] },
  { outputId: 'diamond_chest', material: 'diamond', slot: 'chest', recipe: { diamond: 8 },
    pattern: ['diamond',null,'diamond', 'diamond','diamond','diamond', 'diamond','diamond','diamond'] },
  // Leggings: XXX / X_X / X_X
  { outputId: 'leather_legs', material: 'leather', slot: 'legs', recipe: { leather: 7 },
    pattern: ['leather','leather','leather', 'leather',null,'leather', 'leather',null,'leather'] },
  { outputId: 'iron_legs', material: 'iron', slot: 'legs', recipe: { iron: 7 },
    pattern: ['iron','iron','iron', 'iron',null,'iron', 'iron',null,'iron'] },
  { outputId: 'gold_legs', material: 'gold', slot: 'legs', recipe: { gold: 7 },
    pattern: ['gold','gold','gold', 'gold',null,'gold', 'gold',null,'gold'] },
  { outputId: 'diamond_legs', material: 'diamond', slot: 'legs', recipe: { diamond: 7 },
    pattern: ['diamond','diamond','diamond', 'diamond',null,'diamond', 'diamond',null,'diamond'] },
  // Boots: ___ / X_X / X_X
  { outputId: 'leather_boots', material: 'leather', slot: 'boots', recipe: { leather: 4 },
    pattern: [null,null,null, 'leather',null,'leather', 'leather',null,'leather'] },
  { outputId: 'iron_boots', material: 'iron', slot: 'boots', recipe: { iron: 4 },
    pattern: [null,null,null, 'iron',null,'iron', 'iron',null,'iron'] },
  { outputId: 'gold_boots', material: 'gold', slot: 'boots', recipe: { gold: 4 },
    pattern: [null,null,null, 'gold',null,'gold', 'gold',null,'gold'] },
  { outputId: 'diamond_boots', material: 'diamond', slot: 'boots', recipe: { diamond: 4 },
    pattern: [null,null,null, 'diamond',null,'diamond', 'diamond',null,'diamond'] },
];

// General crafting recipes (non-pickaxe)
// shapeless: true means the item can be placed in any slot
const craftRecipes = [
  { id: 'wood_to_sticks', name: 'Êú®Ê£ç', emoji: 'ü•¢', outputId: 'stick', outputCount: 4,
    needs: { wood: 1 }, shapeless: true },
];

const houseStages = [
  { name: 'Âú∞Âü∫',  needs: { stone: 6 },             emoji: 'üß±' },
  { name: 'ÁâÜÂ£Å',  needs: { wood: 8 },              emoji: 'üèóÔ∏è' },
  { name: 'Â±ãÈ†Ç',  needs: { wood: 4, iron: 2 },     emoji: 'üè†' },
  { name: 'Ë£ùÈ£æ',  needs: { gold: 1, emerald: 1 },  emoji: 'üè°' },
];

const tierColors = ['#8B7355', '#A0A0A0', '#C0C0C0', '#FFD700', '#B9F2FF'];

// ===== STATE =====
let stars = 0, streak = 0, currentFeeling = 'happy';
let matchSelected = null, matchedPairs = new Set();
let quizQuestions = [], quizIndex = 0, quizScore = 0, quizAnswered = false;
let speechSpeed = 'normal'; // 'slow' or 'normal'
let isMuted = false;

// ===== MINING STATE =====
let gems = 0;
let inventory = {};
let houseProgress = 0;
let toolDurability = {}; // { 'stone_pick': 28, ... } ‚Äî remaining uses for active tool
let discovered = new Set(); // permanently tracks every item ID ever obtained
let equipped = { helmet: null, chest: null, legs: null, boots: null };

function getEffectivePickaxeLevel() {
  let best = 0;
  pickaxes.forEach((pick, idx) => {
    if (idx === 0) return;
    if (getBlockCount(pick.id) > 0) best = Math.max(best, idx);
  });
  return best;
}

function getEffectiveAxeBonus() {
  let best = 1;
  axes.forEach(axe => {
    if (getBlockCount(axe.id) > 0) best = Math.max(best, axe.woodBonus);
  });
  return best;
}

// Returns tool def or null. Sets initial durability if needed.
function getActiveTool(toolList) {
  for (let i = toolList.length - 1; i >= 0; i--) {
    const t = toolList[i];
    if (i === 0 && (toolList === pickaxes || toolList === swords)) return t; // wood pick/sword always available
    if (getBlockCount(t.id) > 0) {
      if (t.durability !== Infinity && toolDurability[t.id] === undefined) {
        toolDurability[t.id] = t.durability;
      }
      return t;
    }
  }
  return (toolList === pickaxes || toolList === swords) ? toolList[0] : null; // null = no axe owned
}

function getEffectiveSword() {
  return getActiveTool(swords);
}

function getEffectiveSwordHoldTime() {
  const sword = getEffectiveSword();
  return sword ? sword.holdTime : 2000;
}

// Use a tool: decrement durability, return break message or null
function useTool(tool) {
  if (!tool || tool.durability === Infinity) return null;
  if (toolDurability[tool.id] === undefined) toolDurability[tool.id] = tool.durability;
  toolDurability[tool.id]--;
  if (toolDurability[tool.id] <= 0) {
    // Tool broke
    inventory[tool.id] = (inventory[tool.id] || 1) - 1;
    if (inventory[tool.id] <= 0) delete inventory[tool.id];
    delete toolDurability[tool.id];
    // If more of same tool, set durability for next one
    if (getBlockCount(tool.id) > 0) {
      toolDurability[tool.id] = tool.durability;
    }
    saveGame();
    return tool.name;
  }
  saveGame();
  return null;
}

function getToolDurabilityText(tool) {
  if (!tool || tool.durability === Infinity) return '';
  const cur = toolDurability[tool.id] || tool.durability;
  return ` (${cur}/${tool.durability})`;
}

function saveGame() {
  localStorage.setItem('mineGame', JSON.stringify({ gems, inventory, houseProgress, stars, streak, craftGrid, toolDurability, discovered: [...discovered], equipped }));
}

function loadGame() {
  try {
    const d = JSON.parse(localStorage.getItem('mineGame'));
    if (!d) return;
    gems = d.gems || 0;
    inventory = d.inventory || {};
    toolDurability = d.toolDurability || {};
    if (d.discovered) discovered = new Set(d.discovered);
    if (d.equipped) equipped = { helmet: null, chest: null, legs: null, boots: null, ...d.equipped };
    // Also mark any current inventory items as discovered
    Object.keys(inventory).forEach(id => discovered.add(id));
    Object.values(equipped).forEach(id => { if (id) discovered.add(id); });
    // Migration: convert old pickaxeLevel to inventory item
    if (d.pickaxeLevel > 0 && d.pickaxeLevel < pickaxes.length) {
      const oldPick = pickaxes[d.pickaxeLevel];
      if (!inventory[oldPick.id]) inventory[oldPick.id] = 1;
    }
    houseProgress = d.houseProgress || 0;
    if (d.craftGrid) craftGrid = d.craftGrid;
    stars = d.stars || 0;
    streak = d.streak || 0;
    document.getElementById('stars').textContent = Math.floor(stars);
    document.getElementById('streak').textContent = streak;
    updateGemDisplay();
  } catch (e) { console.warn('Failed to load save', e); }
}

function addGems(n) {
  gems += n;
  updateGemDisplay();
  saveGame();
}

function updateGemDisplay() {
  const el = document.getElementById('gems');
  if (el) el.textContent = gems;
  const bar = document.getElementById('gemBar');
  if (bar) { bar.classList.remove('pop'); void bar.offsetWidth; bar.classList.add('pop'); }
}

function getBlockCount(id) { return inventory[id] || 0; }

function addBlock(id, n) {
  inventory[id] = (inventory[id] || 0) + (n || 1);
  discovered.add(id);
  saveGame();
}

function removeBlocks(recipe) {
  for (const [id, count] of Object.entries(recipe)) {
    inventory[id] = (inventory[id] || 0) - count;
    if (inventory[id] <= 0) delete inventory[id];
  }
  saveGame();
}

function hasBlocks(recipe) {
  return Object.entries(recipe).every(([id, count]) => getBlockCount(id) >= count);
}

// ===== TTS ENGINE =====
// Primary: SpeechSynthesis with smart voice selection
// macOS has many novelty voices (Albert, Bad News, Bells, etc.) ‚Äî filter those out
let lastEngine = 'none';
let cachedVoice = null;

const noveltyVoices = new Set([
  'Albert','Bad News','Bahh','Bells','Boing','Bubbles','Cellos','Good News',
  'Jester','Organ','Superstar','Trinoids','Whisper','Wobble','Zarvox',
  'Ralph','Fred','Kathy','Junior','Princess'
]);

function pickBestVoice(voices) {
  if (cachedVoice) return cachedVoice;
  const preferred = ['Samantha','Alex','Karen','Daniel','Moira','Tessa','Ava','Tom','Allison'];
  for (const name of preferred) {
    const v = voices.find(v => v.name.includes(name) && v.lang.startsWith('en'));
    if (v) { cachedVoice = v; return v; }
  }
  const enUS = voices.filter(v => v.lang === 'en-US' && !noveltyVoices.has(v.name));
  if (enUS.length) { cachedVoice = enUS[0]; return enUS[0]; }
  const en = voices.filter(v => v.lang.startsWith('en') && !noveltyVoices.has(v.name));
  if (en.length) { cachedVoice = en[0]; return en[0]; }
  cachedVoice = voices.find(v => v.lang.startsWith('en')) || voices[0];
  return cachedVoice;
}

// Unlock SpeechSynthesis on first user interaction (iOS requirement)
function unlockAudio() {
  if (window.speechSynthesis) {
    const u = new SpeechSynthesisUtterance('');
    u.volume = 0;
    speechSynthesis.speak(u);
  }
}
document.addEventListener('touchstart', unlockAudio, { once: true });
document.addEventListener('click', unlockAudio, { once: true });

function updateEngineDisplay(engine, detail) {
  lastEngine = engine;
  const el = document.getElementById('engineStatus');
  if (engine === 'speech-synthesis') {
    el.textContent = `üü¢ SpeechSynthesis${detail ? ' ‚Äî ' + detail : ''}`;
    el.style.color = '#00B894';
  } else if (engine === 'error') {
    el.textContent = `üî¥ ÁÑ°Ê≥ïÁôºÈü≥${detail ? ' ‚Äî ' + detail : ''}`;
    el.style.color = '#FF6B6B';
  } else {
    el.textContent = 'üîç ÂÅµÊ∏¨‰∏≠...';
    el.style.color = '#B2BEC3';
  }
}

function speak(text, forceSpeed) {
  const synth = window.speechSynthesis;
  if (!synth) {
    updateEngineDisplay('error', 'SpeechSynthesis not available');
    return null;
  }
  synth.cancel();

  const speed = forceSpeed || speechSpeed;
  const slow = speed === 'slow';
  const u = new SpeechSynthesisUtterance(text);
  u.lang = 'en-US';
  u.rate = slow ? 0.6 : 0.85;
  u.pitch = 1.05;
  const pick = pickBestVoice(synth.getVoices());
  if (pick) u.voice = pick;
  u.onstart = () => updateEngineDisplay('speech-synthesis', pick ? pick.name : 'default voice');
  u.onerror = (e) => updateEngineDisplay('error', e.error);
  synth.speak(u);
  return u;
}

// Speak word first, then sentence after a pause
function speakWordThenSentence(word, sentence) {
  const synth = window.speechSynthesis;
  if (!synth) return;
  synth.cancel();

  const speed = speechSpeed;
  const slow = speed === 'slow';
  const u = new SpeechSynthesisUtterance(word);
  u.lang = 'en-US';
  u.rate = slow ? 0.6 : 0.85;
  u.pitch = 1.05;
  const pick = pickBestVoice(synth.getVoices());
  if (pick) u.voice = pick;
  u.onstart = () => updateEngineDisplay('speech-synthesis', pick ? pick.name : 'default voice');
  u.onend = () => {
    setTimeout(() => speak(sentence), 400);
  };
  u.onerror = (e) => updateEngineDisplay('error', e.error);
  synth.speak(u);
}

// ===== SPEED TOGGLE =====
document.querySelectorAll('.speed-btn[data-speed]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.speed-btn[data-speed]').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    speechSpeed = btn.dataset.speed;
  });
});

// ===== SFX (Web Audio API) =====
let audioCtx = null;
function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

function playMineSfx(tier) {
  if (isMuted) return;
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();

  // Noise burst ‚Äî sounds like stone breaking
  const bufferSize = ctx.sampleRate * 0.08;
  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize); // decaying noise
  }
  const noise = ctx.createBufferSource();
  noise.buffer = buffer;

  // Filter ‚Äî higher tier = higher pitch
  const filter = ctx.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.value = 400 + tier * 200;
  filter.Q.value = 1.5;

  const gain = ctx.createGain();
  gain.gain.value = 0.3;
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);

  noise.connect(filter).connect(gain).connect(ctx.destination);
  noise.start();
  noise.stop(ctx.currentTime + 0.08);

  // Extra "ding" for rare blocks (tier 4+)
  if (tier >= 4) {
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = tier >= 5 ? 1200 : 900;
    const oscGain = ctx.createGain();
    oscGain.gain.value = 0.15;
    oscGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);
    osc.connect(oscGain).connect(ctx.destination);
    osc.start(ctx.currentTime + 0.05);
    osc.stop(ctx.currentTime + 0.3);
  }
}

function playLockedSfx() {
  if (isMuted) return;
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();
  const osc = ctx.createOscillator();
  osc.type = 'square';
  osc.frequency.value = 120;
  const gain = ctx.createGain();
  gain.gain.value = 0.1;
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
  osc.connect(gain).connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.15);
}

function playCraftSfx() {
  if (isMuted) return;
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();
  // Ascending arpeggio
  [0, 1, 2].forEach((i) => {
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = 600 + i * 200;
    const gain = ctx.createGain();
    gain.gain.value = 0.12;
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15 + i * 0.1);
    osc.connect(gain).connect(ctx.destination);
    osc.start(ctx.currentTime + i * 0.1);
    osc.stop(ctx.currentTime + 0.15 + i * 0.1);
  });
}

function playPlaceSfx() {
  if (isMuted) return;
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();
  const osc = ctx.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = 500;
  const gain = ctx.createGain();
  gain.gain.value = 0.08;
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.06);
  osc.connect(gain).connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.06);
}

// ===== UTILS =====
function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function addStars(n) {
  stars += n;
  document.getElementById('stars').textContent = Math.floor(stars);
  const el = document.getElementById('starBar');
  el.classList.remove('pop');
  void el.offsetWidth;
  el.classList.add('pop');
  saveGame();
}

function bumpStreak() {
  streak++;
  document.getElementById('streak').textContent = streak;
  const el = document.getElementById('streakBar');
  el.classList.remove('pop');
  void el.offsetWidth;
  el.classList.add('pop');
}

function resetStreak() { streak = 0; document.getElementById('streak').textContent = 0; saveGame(); }

function doConfetti() {
  const box = document.getElementById('confettiBox');
  const colors = ['#FFD93D','#FF6B6B','#A29BFE','#FF85CA','#00B894','#74B9FF'];
  for (let i = 0; i < 35; i++) {
    const p = document.createElement('div');
    p.className = 'confetti-piece';
    p.style.left = Math.random() * 100 + '%';
    p.style.background = colors[Math.floor(Math.random() * colors.length)];
    p.style.animationDelay = Math.random() * 0.5 + 's';
    p.style.animationDuration = (1.5 + Math.random()) + 's';
    const size = 6 + Math.random() * 8;
    p.style.width = size + 'px';
    p.style.height = size + 'px';
    box.appendChild(p);
  }
  setTimeout(() => box.innerHTML = '', 3000);
}

// ===== NAV =====
document.querySelectorAll('.nav-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById(tab.dataset.tab).classList.add('active');
    if (tab.dataset.tab === 'match') { if (matchedPairs.size >= 6) initMatch(); }
    if (tab.dataset.tab === 'quiz') { if (quizIndex === 0 || quizIndex >= quizQuestions.length) initQuiz(); }
    if (tab.dataset.tab === 'sight') { if (!document.getElementById('sightWordsArea').children.length) initSightWords(); }
    if (tab.dataset.tab === 'mine') initMine();
    if (tab.dataset.tab === 'collection') initCollection();
  });
});

// ===== LEARN =====
function initLearn() {
  const grid = document.getElementById('feelingsGrid');
  grid.innerHTML = '';
  feelings.forEach(f => {
    const card = document.createElement('div');
    card.className = 'feeling-card';
    card.innerHTML = `
      <span class="speaker-hint">üîä</span>
      <span class="emoji">${f.emoji}</span>
      <div class="word">${f.word}</div>
      <div class="chinese">${f.zh}</div>
    `;
    card.style.borderBottom = `4px solid ${f.color}`;
    card.addEventListener('click', () => {
      card.classList.add('speaking');
      setTimeout(() => card.classList.remove('speaking'), 800);
      speak(f.word);
      selectFeeling(f.word);
    });
    grid.appendChild(card);
  });

  const chips = document.getElementById('feelingChips');
  chips.innerHTML = '';
  feelings.forEach(f => {
    const chip = document.createElement('button');
    chip.className = 'feeling-chip' + (f.word === currentFeeling ? ' selected' : '');
    chip.textContent = `${f.emoji} ${f.word}`;
    chip.addEventListener('click', () => {
      selectFeeling(f.word);
      speak(`I feel ${f.word}.`);
    });
    chips.appendChild(chip);
  });
}

function selectFeeling(word) {
  currentFeeling = word;
  const f = feelings.find(x => x.word === word);
  document.getElementById('sentenceDisplay').innerHTML =
    `I feel <span class="hl">${word}</span>. ${f?.emoji || ''}`;
  document.querySelectorAll('.feeling-chip').forEach(c => {
    c.classList.toggle('selected', c.textContent.includes(word));
  });
}

document.getElementById('speakSentenceBtn').addEventListener('click', () => speak(`I feel ${currentFeeling}.`));
document.getElementById('randomSentenceBtn').addEventListener('click', () => {
  const r = feelings[Math.floor(Math.random() * feelings.length)];
  selectFeeling(r.word);
  speak(`I feel ${r.word}.`);
});

// ===== MATCH =====
function initMatch() {
  const pool = shuffle(feelings).slice(0, 6);
  const wCol = document.getElementById('matchWords');
  const eCol = document.getElementById('matchEmojis');
  wCol.innerHTML = '<h3>Words ÂñÆÂ≠ó</h3>';
  eCol.innerHTML = '<h3>Emoji Ë°®ÊÉÖ</h3>';
  matchSelected = null;
  matchedPairs = new Set();
  document.getElementById('matchFeedback').textContent = 'Èªû‰∏ÄÂÄãÂñÆÂ≠óÔºåÂÜçÈªûÈÖçÂ∞çÁöÑË°®ÊÉÖÔºÅ üéØ';

  shuffle(pool).forEach(f => {
    const item = document.createElement('div');
    item.className = 'match-item';
    item.textContent = f.word;
    item.dataset.word = f.word;
    item.dataset.type = 'word';
    item.addEventListener('click', () => matchClick(item));
    wCol.appendChild(item);
  });
  shuffle(pool).forEach(f => {
    const item = document.createElement('div');
    item.className = 'match-item emoji-item';
    item.textContent = f.emoji;
    item.dataset.word = f.word;
    item.dataset.type = 'emoji';
    item.addEventListener('click', () => matchClick(item));
    eCol.appendChild(item);
  });
}

function matchClick(item) {
  if (item.classList.contains('matched')) return;

  if (!matchSelected) {
    matchSelected = item;
    item.classList.add('selected');
    if (item.dataset.type === 'word') speak(item.dataset.word);
    return;
  }
  if (matchSelected === item) {
    item.classList.remove('selected');
    matchSelected = null;
    return;
  }
  if (matchSelected.dataset.type === item.dataset.type) {
    matchSelected.classList.remove('selected');
    matchSelected = item;
    item.classList.add('selected');
    if (item.dataset.type === 'word') speak(item.dataset.word);
    return;
  }

  if (matchSelected.dataset.word === item.dataset.word) {
    const prev = matchSelected;
    prev.classList.remove('selected');
    prev.classList.add('correct');
    item.classList.add('correct');
    const f = feelings.find(x => x.word === item.dataset.word);
    speak(item.dataset.word);
    document.getElementById('matchFeedback').textContent = `‚úÖ ${f?.emoji} ${f?.word} = ${f?.zh}ÔºÅ`;
    addStars(1); bumpStreak(); addGems(1);
    setTimeout(() => {
      prev.classList.add('matched'); prev.classList.remove('correct');
      item.classList.add('matched'); item.classList.remove('correct');
    }, 600);
    matchedPairs.add(item.dataset.word);
    if (matchedPairs.size >= 6) {
      setTimeout(() => {
        document.getElementById('matchFeedback').textContent = 'üéâ ÂÖ®ÈÉ®ÈÖçÂ∞çÂÆåÊàêÔºÅÂ§™Ê£í‰∫ÜÔºÅ';
        addStars(3); doConfetti(); addGems(2);
      }, 700);
    }
  } else {
    const prev = matchSelected;
    prev.classList.add('wrong'); item.classList.add('wrong');
    resetStreak();
    document.getElementById('matchFeedback').textContent = '‚ùå ÂÜçË©¶‰∏ÄÊ¨°ÔºÅ';
    setTimeout(() => {
      prev.classList.remove('wrong', 'selected');
      item.classList.remove('wrong');
    }, 500);
  }
  matchSelected = null;
}

document.getElementById('resetMatch').addEventListener('click', initMatch);

// ===== QUIZ =====
function initQuiz() {
  quizQuestions = shuffle(feelings).slice(0, 8).map(f => {
    const others = shuffle(feelings.filter(x => x.word !== f.word)).slice(0, 3);
    return { feeling: f, options: shuffle([f, ...others]), type: Math.random() > 0.5 ? 'e2w' : 'w2e' };
  });
  quizIndex = 0; quizScore = 0;
  renderQuiz();
}

function renderQuiz() {
  const c = document.getElementById('quizContainer');
  if (quizIndex >= quizQuestions.length) {
    const pct = Math.round(quizScore / quizQuestions.length * 100);
    const msg = pct === 100 ? 'üèÜ Perfect! ÂÆåÁæéÔºÅ' : pct >= 75 ? 'üåü Great! ÂæàÊ£íÔºÅ' : 'üí™ Keep going! Âä†Ê≤πÔºÅ';
    c.innerHTML = `<div class="quiz-result">
      <div class="big-emoji">${pct === 100 ? 'üéâ' : pct >= 75 ? 'üåü' : 'üí™'}</div>
      <div class="result-text">${msg}</div>
      <div class="result-detail">${quizScore} / ${quizQuestions.length} Á≠îÂ∞ç</div>
      <button class="speak-btn primary" onclick="initQuiz()">üîÑ ÂÜç‰æÜ‰∏ÄÊ¨°</button>
    </div>`;
    if (pct >= 75) { addStars(5); doConfetti(); addGems(3); }
    return;
  }

  const q = quizQuestions[quizIndex];
  quizAnswered = false;
  const dots = quizQuestions.map((_, i) => `<div class="quiz-dot${i < quizIndex ? ' done' : ''}${i === quizIndex ? ' current' : ''}"></div>`).join('');

  if (q.type === 'e2w') {
    c.innerHTML = `
      <div class="quiz-progress">${dots}</div>
      <div class="quiz-prompt">${q.feeling.emoji}</div>
      <div class="quiz-question">ÈÄôÊòØ‰ªÄÈ∫ºÊÑüË¶∫Ôºü</div>
      <button class="speak-btn small primary" style="margin-bottom:16px" id="quizHint">üîä ËÅΩÊèêÁ§∫</button>
      <div class="quiz-options">
        ${q.options.map(o => `<button class="quiz-option" data-word="${o.word}">${o.word}</button>`).join('')}
      </div>`;
  } else {
    c.innerHTML = `
      <div class="quiz-progress">${dots}</div>
      <div class="quiz-prompt" style="font-size:2.2rem;font-family:'Fredoka',sans-serif;font-weight:700">${q.feeling.word}</div>
      <div class="quiz-question">Âì™ÂÄãË°®ÊÉÖÁ¨¶ÂêàÔºü</div>
      <button class="speak-btn small primary" style="margin-bottom:16px" id="quizHint">üîä ËÅΩÁôºÈü≥</button>
      <div class="quiz-options">
        ${q.options.map(o => `<button class="quiz-option" data-word="${o.word}">${o.emoji} ${o.zh}</button>`).join('')}
      </div>`;
  }

  // Don't auto-speak ‚Äî iOS blocks audio without a direct user gesture.
  // The hint button below lets the user trigger it.

  // Hint button
  c.querySelector('#quizHint')?.addEventListener('click', () => speak(q.feeling.word));

  c.querySelectorAll('.quiz-option').forEach(btn => {
    btn.addEventListener('click', () => {
      if (quizAnswered) return;
      quizAnswered = true;
      const correct = btn.dataset.word === q.feeling.word;
      if (correct) {
        btn.classList.add('correct-answer');
        quizScore++; addStars(1); bumpStreak(); addGems(1);
        speak('Great job!');
      } else {
        btn.classList.add('wrong-answer');
        resetStreak();
        c.querySelector(`[data-word="${q.feeling.word}"]`)?.classList.add('correct-answer');
        speak(q.feeling.word);
      }
      setTimeout(() => { quizIndex++; renderQuiz(); }, 1300);
    });
  });
}

// ===== SIGHT WORDS =====
let sightEarned = new Set();

function initSightWords() {
  const area = document.getElementById('sightWordsArea');
  area.textContent = '';

  sightWords.forEach((sw, i) => {
    const card = document.createElement('div');
    card.className = 'sight-word-card';
    card.style.borderLeft = `5px solid ${sightColors[i]}`;

    const info = document.createElement('div');
    const wordEl = document.createElement('div');
    wordEl.className = 'sight-word-text';
    wordEl.textContent = sw.word;
    const zhEl = document.createElement('div');
    zhEl.className = 'sight-word-chinese';
    zhEl.textContent = `${sw.zh} ‚Äî "${sw.sentence}"`;
    info.appendChild(wordEl);
    info.appendChild(zhEl);

    const playIcon = document.createElement('div');
    playIcon.className = 'play-icon';
    playIcon.textContent = 'üîä';

    card.appendChild(info);
    card.appendChild(playIcon);

    // Create confirm button immediately (disabled)
    const btn = document.createElement('button');
    btn.className = 'sight-confirm';
    btn.textContent = 'üé§ ÊàëË∑üËëóÂî∏‰∫ÜÔºÅ+‚ö°';
    btn.disabled = true;
    btn.style.opacity = '0.4';

    if (sightEarned.has(sw.word)) {
      playIcon.textContent = '‚úÖ';
      card.classList.add('earned');
    } else {
      card.appendChild(btn);
    }

    card.addEventListener('click', () => {
      if (sightEarned.has(sw.word)) {
        speakWordThenSentence(sw.word, sw.sentence);
        return;
      }
      card.classList.add('speaking');
      speakWordThenSentence(sw.word, sw.sentence);
      // Enable button after audio plays
      setTimeout(() => {
        card.classList.remove('speaking');
        if (sightEarned.has(sw.word)) return;
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.animation = 'fadeIn 0.3s ease';
      }, 2500);
    });

    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      sightEarned.add(sw.word);
      addGems(1);
      btn.remove();
      card.classList.add('earned');
      playIcon.textContent = '‚úÖ';
    });
    area.appendChild(card);
  });

  const extra = document.createElement('div');
  extra.className = 'sentence-practice';
  extra.style.marginTop = '8px';
  extra.innerHTML = `
    <h3>üìå Weekly Quote ÊØèÈÄ±‰Ω≥Âè•</h3>
    <div class="sentence-display" style="font-size:1.3rem">"Life is better when you are happy." üòä</div>
    <button class="speak-btn primary small" onclick="speak('Life is better when you are happy.')">üîä Listen</button>
    <div style="margin-top:18px">
      <h3>üéµ Song & Rhyme</h3>
      <div class="sentence-display" style="font-size:1.4rem;margin-top:8px">‚ú® Hakuna Matata ‚ú®</div>
      <button class="speak-btn secondary small" onclick="speak('Hakuna Matata! It means no worries!')">üîä Listen</button>
    </div>`;
  area.appendChild(extra);
}

// ===== MINE =====
// Mountain shape: each row = { width, tier } ‚Äî triangle from peak to base
const mountainShape = [
  { width: 2, tier: 0 },   // tree tops
  { width: 4, tier: 0 },   // more trees
  { width: 6, tier: 1 },   // dirt/wood
  { width: 8, tier: 1 },
  { width: 10, tier: 1 },
  { width: 12, tier: 2 },  // stone/coal
  { width: 12, tier: 2 },
  { width: 12, tier: 2 },
  { width: 12, tier: 3 },  // iron/copper
  { width: 12, tier: 3 },
  { width: 12, tier: 3 },
  { width: 12, tier: 4 },  // gold/emerald
  { width: 12, tier: 4 },
  { width: 12, tier: 5 },  // diamond/amethyst
  { width: 12, tier: 5 },
];

let mineData = []; // 2D array: each cell = { block, mined, tier, el } or null

function rollBlockForTier(tier) {
  const pool = blocks.filter(b => b.tier === tier);
  const totalWeight = pool.reduce((s, b) => s + b.weight, 0);
  let r = Math.random() * totalWeight;
  for (const b of pool) {
    r -= b.weight;
    if (r <= 0) return b;
  }
  return pool[pool.length - 1];
}

function isExposed(row, col) {
  if (mineData[row][col] === null || mineData[row][col].mined) return false;
  // Check 4 neighbors ‚Äî if any is outside mountain or mined, this cell is exposed
  const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
  for (const [dr, dc] of dirs) {
    const nr = row + dr, nc = col + dc;
    if (nr < 0 || nr >= mineData.length) return true; // top/bottom edge
    if (nc < 0 || nc >= mineData[nr].length) return true; // side edge
    if (mineData[nr][nc] === null) return true; // outside mountain shape
    if (mineData[nr][nc].mined) return true; // adjacent to mined cell
    if (mineData[nr][nc].tier === 0) return true; // tree row counts as open
  }
  return false;
}

function updateExposure() {
  const maxTier = pickaxes[getEffectivePickaxeLevel()].maxTier;
  for (let r = 0; r < mineData.length; r++) {
    for (let c = 0; c < mineData[r].length; c++) {
      const cell = mineData[r][c];
      if (!cell || cell.mined || cell.tier === 0) continue;
      const exposed = isExposed(r, c);
      const locked = cell.tier > maxTier;
      cell.el.classList.toggle('unexposed', !exposed);
      cell.el.classList.toggle('locked', exposed && locked);
    }
  }
}

let mineHoldRAF = null;
let mineHoldTarget = null;
let mineHoldStart = 0;

function getMineHoldDuration(cellData) {
  if (cellData.animal) {
    const sword = getEffectiveSword();
    return sword ? sword.holdTime : 2000;
  }
  if (cellData.tier === 0) {
    return getEffectiveAxeBonus() > 1 ? 600 : 1000;
  }
  const pickLevel = getEffectivePickaxeLevel();
  const pick = pickaxes[pickLevel];
  if (cellData.tier > pick.maxTier) return Infinity;
  const tierDiff = cellData.tier - pickLevel;
  if (tierDiff <= 0) return 800;
  return 800 + tierDiff * 600;
}

function startMineHold(cellData) {
  if (cellData.mined) return;
  const duration = getMineHoldDuration(cellData);
  if (duration === Infinity) {
    playLockedSfx();
    document.getElementById('mineResult').textContent = 'üîí ÈúÄË¶ÅÊõ¥Â•ΩÁöÑÈé¨ÊâçËÉΩÊåñÁ¨¨ ' + cellData.tier + ' Â±§ÔºÅ';
    return;
  }

  let bar = cellData.el.querySelector('.mine-progress');
  if (!bar) {
    bar = document.createElement('div');
    bar.className = 'mine-progress';
    const fill = document.createElement('div');
    fill.className = 'mine-progress-fill';
    bar.appendChild(fill);
    cellData.el.appendChild(bar);
  }
  const fill = bar.querySelector('.mine-progress-fill');
  fill.style.width = '0%';

  mineHoldStart = Date.now();
  mineHoldTarget = { cellData, duration, fill };

  function updateProgress() {
    if (!mineHoldTarget) return;
    const elapsed = Date.now() - mineHoldStart;
    const pct = Math.min(100, (elapsed / duration) * 100);
    fill.style.width = pct + '%';
    if (elapsed >= duration) {
      completeMineHold();
      return;
    }
    mineHoldRAF = requestAnimationFrame(updateProgress);
  }
  mineHoldRAF = requestAnimationFrame(updateProgress);
}

function completeMineHold() {
  if (!mineHoldTarget) return;
  const { cellData } = mineHoldTarget;
  cancelMineHold(false);

  if (cellData.animal) {
    attackAnimal(cellData);
  } else if (cellData.tier === 0) {
    chopTree(cellData);
  } else {
    for (let r = 0; r < mineData.length; r++) {
      for (let c = 0; c < mineData[r].length; c++) {
        if (mineData[r][c] === cellData) {
          mineMountainCell(r, c, cellData);
          return;
        }
      }
    }
  }
}

function cancelMineHold(resetBar) {
  if (resetBar === undefined) resetBar = true;
  if (mineHoldRAF) cancelAnimationFrame(mineHoldRAF);
  mineHoldRAF = null;
  if (resetBar && mineHoldTarget) {
    mineHoldTarget.fill.style.width = '0%';
  }
  mineHoldTarget = null;
}

function initMine() {
  const area = document.getElementById('mineArea');
  const pick = pickaxes[getEffectivePickaxeLevel()];
  area.textContent = '';
  mineData = [];

  // Header
  const header = document.createElement('div');
  header.className = 'mine-header';
  const h3 = document.createElement('h3');
  h3.textContent = '‚õèÔ∏è ÊåñÁ§¶ Mine';
  const pickInfo = document.createElement('div');
  pickInfo.className = 'mine-pickaxe';
  const pickDur = getToolDurabilityText(pick);
  const activeAxe = getActiveTool(axes);
  const axeBonus = getEffectiveAxeBonus();
  const axeLabel = axeBonus > 1 ? `  |  ü™ì ${activeAxe.name}${getToolDurabilityText(activeAxe)}ÔºàÁ†çÊ®π x${axeBonus}Ôºâ` : '';
  const activeSword = getEffectiveSword();
  const swordLabel = activeSword && activeSword.id !== 'wood_sword' ? '  |  üó°Ô∏è ' + activeSword.name + getToolDurabilityText(activeSword) : '';
  pickInfo.textContent = `‚õèÔ∏è ${pick.name}${pickDur}ÔºàÂèØÊåñÁ¨¨ ${pick.maxTier} Â±§Ôºâ${axeLabel}${swordLabel}`;
  const costInfo = document.createElement('div');
  costInfo.className = 'mine-cost';
  costInfo.textContent = 'ÊØèÊ†ºËä±Ë≤ª 1 ‚ö° È´îÂäõ';
  const holdHint = document.createElement('div');
  holdHint.className = 'mine-hold-hint';
  holdHint.textContent = 'üëÜ Êåâ‰Ωè‰∏çÊîæ‰æÜÊåñÁ§¶ÔºÅHold to mine!';
  header.appendChild(h3);
  header.appendChild(pickInfo);
  header.appendChild(costInfo);
  header.appendChild(holdHint);
  area.appendChild(header);

  // Mountain
  const mountain = document.createElement('div');
  mountain.className = 'mountain';
  const maxWidth = 12;

  mountainShape.forEach((rowDef, r) => {
    const rowEl = document.createElement('div');
    rowEl.className = 'mountain-row';
    const rowData = [];

    // Pad to maxWidth with nulls for consistent indexing
    const offset = Math.floor((maxWidth - rowDef.width) / 2);
    for (let c = 0; c < maxWidth; c++) {
      if (c < offset || c >= offset + rowDef.width) {
        rowData.push(null);
        continue;
      }

      const cellEl = document.createElement('div');
      cellEl.className = 'mine-cell';

      if (rowDef.tier === 0) {
        if (Math.random() < 0.35) {
          // Animal
          const animal = animals[Math.floor(Math.random() * animals.length)];
          cellEl.classList.add('animal');
          cellEl.textContent = animal.emoji;
          const animalData = { tier: 0, mined: false, block: null, animal: animal, el: cellEl };
          rowData.push(animalData);
        } else {
          // Choppable trees ‚Äî gives wood
          cellEl.classList.add('tree');
          cellEl.textContent = Math.random() > 0.5 ? 'üå≥' : 'üå≤';
          const woodBlock = blocks.find(b => b.id === 'wood');
          const treeData = { tier: 0, mined: false, block: woodBlock, el: cellEl };
          rowData.push(treeData);
        }
      } else {
        const block = rollBlockForTier(rowDef.tier);
        cellEl.classList.add('tier' + rowDef.tier);
        const cellData = { tier: rowDef.tier, mined: false, block, el: cellEl };
        rowData.push(cellData);
      }

      // Hold-to-mine events (touch + mouse)
      const holdData = rowData[rowData.length - 1];
      if (holdData) {
        const startHold = (e) => { e.preventDefault(); startMineHold(holdData); };
        const endHold = () => cancelMineHold();
        cellEl.addEventListener('mousedown', startHold);
        cellEl.addEventListener('mouseup', endHold);
        cellEl.addEventListener('mouseleave', endHold);
        cellEl.addEventListener('touchstart', startHold, { passive: false });
        cellEl.addEventListener('touchend', endHold);
        cellEl.addEventListener('touchcancel', endHold);
      }

      rowEl.appendChild(cellEl);
    }

    mineData.push(rowData);
    mountain.appendChild(rowEl);
  });

  const mineLayout = document.createElement('div');
  mineLayout.style.cssText = 'display:flex;align-items:flex-start;justify-content:center;gap:12px;';
  mineLayout.appendChild(mountain);

  const charSide = document.createElement('div');
  charSide.id = 'mineCharacter';
  renderCharacter(charSide, 'small');
  mineLayout.appendChild(charSide);

  area.appendChild(mineLayout);

  // Result
  const result = document.createElement('div');
  result.className = 'mine-result';
  result.id = 'mineResult';
  area.appendChild(result);

  // Refresh button
  const refreshBtn = document.createElement('button');
  refreshBtn.className = 'mine-refresh';
  refreshBtn.id = 'mineRefresh';
  refreshBtn.textContent = 'üîÑ Êñ∞Â±±È´î New Mountain';
  refreshBtn.addEventListener('click', initMine);
  area.appendChild(refreshBtn);

  updateExposure();
  updateMineRefreshBtn();
}

function attackAnimal(cellData) {
  if (cellData.mined) return;
  if (gems < 1) {
    playLockedSfx();
    document.getElementById('mineResult').textContent = '‚ö° È´îÂäõ‰∏çË∂≥ÔºÅÂéªÁ≠îÈ°åË£úÂÖÖÂêßÔºÅ';
    return;
  }
  playMineSfx(1);
  gems--;
  updateGemDisplay();
  cellData.mined = true;
  cellData.el.classList.add('mined');

  const animal = cellData.animal;
  const activeSword = getEffectiveSword();
  const brokeName = useTool(activeSword);

  let msg = animal.emoji + ' ÊìäÊïó' + animal.name + 'ÔºÅÁç≤ÂæóÔºö';
  animal.drops.forEach(drop => {
    const count = drop.min + Math.floor(Math.random() * (drop.max - drop.min + 1));
    addBlock(drop.id, count);
    const b = blocks.find(x => x.id === drop.id);
    msg += ' ' + b.emoji + b.name + ' x' + count;
  });
  if (brokeName) msg += ' ‚ö†Ô∏è ' + brokeName + ' Â£ûÊéâ‰∫ÜÔºÅ';

  document.getElementById('mineResult').textContent = msg;
  updateExposure();
  updateMineRefreshBtn();
  saveGame();
}

function chopTree(cellData) {
  if (cellData.mined) return;
  if (gems < 1) {
    playLockedSfx();
    document.getElementById('mineResult').textContent = '‚ö° È´îÂäõ‰∏çË∂≥ÔºÅÂéªÁ≠îÈ°åË£úÂÖÖÂêßÔºÅ';
    return;
  }
  playMineSfx(1);
  gems--;
  updateGemDisplay();
  cellData.mined = true;
  cellData.el.classList.add('mined');
  const activeAxe = getActiveTool(axes);
  const woodCount = getEffectiveAxeBonus();
  addBlock('wood', woodCount);
  const brokeName = useTool(activeAxe);
  const axeMsg = woodCount > 1 ? ` (ü™ì ÊñßÈ†≠Âä†Êàê x${woodCount})` : '';
  const breakMsg = brokeName ? ` ‚ö†Ô∏è ${brokeName} Â£ûÊéâ‰∫ÜÔºÅ` : '';
  document.getElementById('mineResult').textContent =
    `ü™µ Á†çÂà∞Êú®È†≠ x${woodCount}ÔºÅ${axeMsg}${breakMsg}ÔºàÊìÅÊúâ ${getBlockCount('wood')} ÂÄãÔºâ`;
  updateExposure();
  updateMineRefreshBtn();
  saveGame();
}

function mineMountainCell(row, col, cellData) {
  if (cellData.mined) return;

  const maxTier = pickaxes[getEffectivePickaxeLevel()].maxTier;
  if (cellData.tier > maxTier) {
    playLockedSfx();
    document.getElementById('mineResult').textContent = `üîí ÈúÄË¶ÅÊõ¥Â•ΩÁöÑÈé¨ÊâçËÉΩÊåñÁ¨¨ ${cellData.tier} Â±§ÔºÅ`;
    return;
  }

  if (!isExposed(row, col)) return;

  if (gems < 1) {
    playLockedSfx();
    document.getElementById('mineResult').textContent = '‚ö° È´îÂäõ‰∏çË∂≥ÔºÅÂéªÁ≠îÈ°åË£úÂÖÖÂêßÔºÅ';
    return;
  }

  playMineSfx(cellData.tier);
  gems--;
  updateGemDisplay();
  cellData.mined = true;
  cellData.el.classList.add('mined');
  cellData.el.textContent = '';
  const reveal = document.createElement('span');
  reveal.className = 'block-reveal';
  reveal.textContent = cellData.block.emoji;
  cellData.el.appendChild(reveal);
  // Fade out emoji after animation
  setTimeout(() => { cellData.el.textContent = ''; }, 800);

  addBlock(cellData.block.id);

  const activePick = pickaxes[getEffectivePickaxeLevel()];
  const brokeName = useTool(activePick);

  const b = cellData.block;
  const rarity = b.tier >= 4 ? ' ‚ú® Á®ÄÊúâÔºÅ' : b.tier >= 3 ? ' ‰∏çÈåØÔºÅ' : '';
  const breakMsg = brokeName ? ` ‚ö†Ô∏è ${brokeName} Â£ûÊéâ‰∫ÜÔºÅ` : '';
  document.getElementById('mineResult').textContent =
    `${b.emoji} ÊåñÂà∞ ${b.name}ÔºÅ${rarity}${breakMsg}ÔºàÊìÅÊúâ ${getBlockCount(b.id)} ÂÄãÔºâ`;

  if (b.tier >= 4) doConfetti();
  updateExposure();
  updateMineRefreshBtn();
  saveGame();
}

function updateMineRefreshBtn() {
  const btn = document.getElementById('mineRefresh');
  if (btn) btn.disabled = gems < 1;
}

// ===== COLLECTION =====
let collectionView = 'encyclopedia';

function renderCharacter(container, size) {
  container.textContent = '';
  const display = document.createElement('div');
  display.className = 'character-display' + (size === 'small' ? ' small' : '');

  const getEmoji = (slot, fallback) => {
    if (!equipped[slot]) return fallback;
    const b = blocks.find(x => x.id === equipped[slot]);
    return b ? b.emoji : fallback;
  };

  const rows = [getEmoji('helmet', 'üòä'), getEmoji('chest', 'üëï'), getEmoji('legs', 'üëñ'), getEmoji('boots', 'üëü')];
  rows.forEach(emoji => {
    const row = document.createElement('div');
    row.className = 'character-row';
    row.textContent = emoji;
    display.appendChild(row);
  });

  const pick = pickaxes[getEffectivePickaxeLevel()];
  const toolRow = document.createElement('div');
  toolRow.className = 'character-row';
  toolRow.style.fontSize = size === 'small' ? '0.8rem' : '1.2rem';
  toolRow.style.marginTop = '4px';
  toolRow.textContent = pick.emoji;
  display.appendChild(toolRow);

  container.appendChild(display);
}

function initCollection() {
  const area = document.getElementById('collectionArea');
  area.textContent = '';

  // Sub-tabs
  const tabs = document.createElement('div');
  tabs.className = 'collection-tabs';
  ['encyclopedia', 'craft', 'house', 'equip'].forEach(view => {
    const labels = { encyclopedia: 'üìñ ÂúñÈëë', craft: 'üî® ÂêàÊàê', house: 'üè† ËìãÊàøÂ≠ê', equip: 'üë§ Ë£ùÂÇô' };
    const btn = document.createElement('button');
    btn.className = 'collection-tab' + (collectionView === view ? ' active' : '');
    btn.textContent = labels[view];
    btn.addEventListener('click', () => { collectionView = view; initCollection(); });
    tabs.appendChild(btn);
  });
  area.appendChild(tabs);

  const content = document.createElement('div');
  content.id = 'collectionContent';
  area.appendChild(content);

  if (collectionView === 'encyclopedia') renderEncyclopedia(content);
  else if (collectionView === 'craft') renderCraft(content);
  else if (collectionView === 'house') renderHouse(content);
  else if (collectionView === 'equip') renderEquipment(content);
}

function renderEncyclopedia(c) {
  const discoveredCount = discovered.size;
  const counter = document.createElement('div');
  counter.style.cssText = 'text-align:center;margin-bottom:12px;font-family:Fredoka,sans-serif;color:#636E72';
  counter.textContent = `Â∑≤ÁôºÁèæ ${discoveredCount} / ${blocks.length} Á®ÆÁâ©ÂìÅ`;
  c.appendChild(counter);

  const grid = document.createElement('div');
  grid.className = 'encyclopedia-grid';
  blocks.forEach(b => {
    const count = getBlockCount(b.id);
    const owned = discovered.has(b.id);
    const card = document.createElement('div');
    card.className = 'block-card ' + (owned ? 'owned' : 'undiscovered');
    if (b.tier > 0) card.style.borderBottomColor = tierColors[b.tier - 1];
    else card.style.borderBottomColor = '#A29BFE'; // tools

    const emoji = document.createElement('div');
    emoji.className = 'block-emoji';
    emoji.textContent = owned ? b.emoji : '‚ùì';
    const name = document.createElement('div');
    name.className = 'block-name';
    name.textContent = owned ? b.name : '???';
    const cnt = document.createElement('div');
    cnt.className = 'block-count';
    cnt.textContent = owned ? `x${count}` : 'Êú™ÁôºÁèæ';
    const tier = document.createElement('div');
    tier.className = 'block-tier';
    tier.textContent = b.tier > 0 ? '‚≠ê'.repeat(b.tier) : 'üîß';

    card.appendChild(emoji);
    card.appendChild(name);
    card.appendChild(cnt);
    card.appendChild(tier);
    grid.appendChild(card);
  });
  c.appendChild(grid);
}

// ===== CRAFTING TABLE =====
let craftGrid = [null,null,null, null,null,null, null,null,null]; // 9 slots, block id or null
let craftSelected = null; // selected block id from inventory

function renderCraft(c) {
  // craftGrid persists across tab switches (items are already deducted from inventory)

  const currentPick = pickaxes[getEffectivePickaxeLevel()];
  const current = document.createElement('div');
  current.className = 'craft-current';
  const axeB = getEffectiveAxeBonus();
  const axeStr = axeB > 1 ? `  |  ü™ì ÊñßÈ†≠ÔºàÁ†çÊ®π x${axeB}Ôºâ` : '';
  current.textContent = `‚õèÔ∏è ${currentPick.name}${axeStr}`;
  c.appendChild(current);

  const area = document.createElement('div');
  area.className = 'craft-area';

  // Onboarding guide
  const guide = document.createElement('div');
  guide.className = 'craft-guide';
  guide.textContent = '‚ë† ËÉåÂåÖÈÅ∏ÊùêÊñô ‚Üí ‚ë° ÈªûÊ†ºÂ≠êÊîæÂÖ• ‚Üí ‚ë¢ ÊåâÂêàÊàêÔºÅ';
  area.appendChild(guide);

  // Craft table: grid + arrow + result
  const table = document.createElement('div');
  table.className = 'craft-table';

  const grid = document.createElement('div');
  grid.className = 'craft-grid';
  grid.id = 'craftGrid';
  for (let i = 0; i < 9; i++) {
    const slot = document.createElement('div');
    slot.className = 'craft-slot';
    slot.dataset.idx = i;
    slot.addEventListener('click', () => craftSlotClick(i));
    grid.appendChild(slot);
  }
  table.appendChild(grid);

  const arrow = document.createElement('div');
  arrow.className = 'craft-arrow';
  arrow.textContent = '‚û°Ô∏è';
  table.appendChild(arrow);

  const resultSlot = document.createElement('div');
  resultSlot.className = 'craft-result-slot';
  resultSlot.id = 'craftResultSlot';
  resultSlot.style.cursor = 'pointer';
  resultSlot.addEventListener('click', () => {
    if (checkCraftMatch()) doCraft();
  });
  table.appendChild(resultSlot);

  area.appendChild(table);

  // Action buttons
  const actions = document.createElement('div');
  actions.className = 'craft-actions';
  const craftBtn = document.createElement('button');
  craftBtn.className = 'craft-btn primary';
  craftBtn.id = 'craftBtn';
  craftBtn.textContent = 'üî® ÂêàÊàê';
  craftBtn.disabled = true;
  craftBtn.addEventListener('click', doCraft);
  const clearBtn = document.createElement('button');
  clearBtn.className = 'craft-btn secondary';
  clearBtn.textContent = 'üîÑ Ê∏ÖÁ©∫';
  clearBtn.addEventListener('click', () => {
    // Return all placed blocks to inventory
    craftGrid.forEach(id => { if (id) addBlock(id); });
    craftGrid = [null,null,null, null,null,null, null,null,null];
    updateCraftUI();
  });
  actions.appendChild(craftBtn);
  actions.appendChild(clearBtn);
  area.appendChild(actions);

  // Inventory panel
  const inv = document.createElement('div');
  inv.className = 'craft-inventory';
  const invTitle = document.createElement('div');
  invTitle.className = 'craft-inv-title';
  invTitle.textContent = 'üéí ËÉåÂåÖÔºàÈªûÈÅ∏ÊñπÂ°äÂÜçÊîæÂà∞Ê†ºÂ≠ê‰∏äÔºâ';
  inv.appendChild(invTitle);
  const invGrid = document.createElement('div');
  invGrid.className = 'craft-inv-grid';
  invGrid.id = 'craftInvGrid';
  inv.appendChild(invGrid);
  area.appendChild(inv);

  c.appendChild(area);

  // Recipe book
  renderRecipeBook(c);

  updateCraftUI();
}

function renderRecipeBook(c) {
  const book = document.createElement('div');
  book.className = 'recipe-book';
  const title = document.createElement('div');
  title.className = 'recipe-book-title';
  title.textContent = 'üìú ÂêàÊàêË°® Recipes';
  book.appendChild(title);

  // Collect recipes by category
  const categories = [
    { name: '‚õèÔ∏è Èé¨ Pickaxes', recipes: [] },
    { name: 'ü™ì Êñß Axes', recipes: [] },
    { name: 'üó°Ô∏è Âäç Swords', recipes: [] },
    { name: 'üõ°Ô∏è ÁõîÁî≤ Armor', recipes: [] },
    { name: 'üîß ÂÖ∂‰ªñ Other', recipes: [] },
  ];

  pickaxes.forEach((pick) => {
    if (!pick.pattern) return;
    categories[0].recipes.push({
      pattern: pick.pattern, emoji: pick.emoji, name: pick.name,
      needs: pick.recipe, itemId: pick.id, type: 'pickaxe'
    });
  });
  axes.forEach((axe) => {
    categories[1].recipes.push({
      pattern: axe.pattern, emoji: axe.emoji, name: axe.name,
      needs: axe.recipe, itemId: axe.id, type: 'axe'
    });
  });
  swords.forEach((sword) => {
    if (!sword.pattern) return;
    categories[2].recipes.push({
      pattern: sword.pattern, emoji: sword.emoji, name: sword.name,
      needs: sword.recipe, itemId: sword.id, type: 'sword'
    });
  });
  armorRecipes.forEach((armor) => {
    const b = blocks.find(x => x.id === armor.outputId);
    categories[3].recipes.push({
      pattern: armor.pattern, emoji: b ? b.emoji : '?', name: b ? b.name : armor.outputId,
      needs: armor.recipe, itemId: armor.outputId, type: 'armor'
    });
  });
  craftRecipes.forEach(recipe => {
    const needs = recipe.needs || {};
    const pattern = recipe.pattern || (recipe.shapeless ?
      (() => {
        const p = [null,null,null, null,null,null, null,null,null];
        const ids = Object.entries(needs);
        if (ids.length === 1) { p[4] = ids[0][0]; }
        return p;
      })() : [null,null,null, null,null,null, null,null,null]);
    categories[4].recipes.push({
      pattern, emoji: recipe.emoji,
      name: recipe.name + ' x' + recipe.outputCount,
      needs, itemId: recipe.outputId, type: 'item',
      shapeless: recipe.shapeless
    });
  });

  categories.forEach((cat, catIdx) => {
    if (cat.recipes.length === 0) return;

    const section = document.createElement('div');
    section.className = 'recipe-category';

    const header = document.createElement('div');
    header.className = 'recipe-category-header';
    header.textContent = cat.name + ' (' + cat.recipes.length + ')';
    let expanded = catIdx < 3;
    header.addEventListener('click', () => {
      expanded = !expanded;
      list.style.display = expanded ? 'flex' : 'none';
      header.classList.toggle('collapsed', !expanded);
    });
    if (!expanded) header.classList.add('collapsed');
    section.appendChild(header);

    const list = document.createElement('div');
    list.className = 'recipe-list';
    list.style.display = expanded ? 'flex' : 'none';

    cat.recipes.forEach(r => {
      const canCraft = hasBlocks(r.needs);
      const owned = r.itemId ? getBlockCount(r.itemId) : 0;
      const card = document.createElement('div');
      card.className = 'recipe-card' + (canCraft ? ' craftable' : '');

      const miniGrid = document.createElement('div');
      miniGrid.className = 'recipe-mini-grid';
      r.pattern.forEach(slot => {
        const cell = document.createElement('div');
        cell.className = 'recipe-mini-slot';
        if (slot) {
          const b = blocks.find(x => x.id === slot);
          if (b) cell.textContent = b.emoji;
        }
        miniGrid.appendChild(cell);
      });
      card.appendChild(miniGrid);

      const arrow = document.createElement('div');
      arrow.className = 'recipe-arrow';
      arrow.textContent = '‚û°Ô∏è';
      card.appendChild(arrow);

      const result = document.createElement('div');
      result.className = 'recipe-result';
      result.textContent = r.emoji;
      card.appendChild(result);

      const info = document.createElement('div');
      info.className = 'recipe-info';
      const nameEl = document.createElement('div');
      nameEl.className = 'recipe-name';
      const ownedLabel = owned > 0 ? ' (ÊìÅÊúâ x' + owned + ')' : '';
      nameEl.textContent = r.name + ownedLabel + (r.shapeless ? ' (‰ªªÊÑè‰ΩçÁΩÆ)' : '');
      info.appendChild(nameEl);

      const needsEl = document.createElement('div');
      needsEl.className = 'recipe-needs';
      Object.entries(r.needs).forEach(([id, count], idx) => {
        const b = blocks.find(x => x.id === id);
        const have = getBlockCount(id);
        const span = document.createElement('span');
        span.className = have >= count ? 'has' : 'need';
        span.textContent = (b ? b.emoji : id) + ' ' + have + '/' + count;
        if (idx > 0) needsEl.appendChild(document.createTextNode('  '));
        needsEl.appendChild(span);
      });
      info.appendChild(needsEl);
      card.appendChild(info);

      list.appendChild(card);
    });

    section.appendChild(list);
    book.appendChild(section);
  });

  c.appendChild(book);
}

function craftSlotClick(idx) {
  if (craftGrid[idx]) {
    // Remove block from grid, return to inventory
    playPlaceSfx();
    addBlock(craftGrid[idx]);
    craftGrid[idx] = null;
    updateCraftUI();
  } else if (craftSelected && getBlockCount(craftSelected) > 0) {
    // Place selected block
    playPlaceSfx();
    craftGrid[idx] = craftSelected;
    // Deduct from inventory (temporarily)
    inventory[craftSelected] = (inventory[craftSelected] || 0) - 1;
    if (inventory[craftSelected] <= 0) delete inventory[craftSelected];
    saveGame();
    updateCraftUI();
  }
}

function checkCraftMatch() {
  // Check pickaxe recipes (all repeatable)
  for (const pick of pickaxes) {
    if (!pick.pattern) continue;
    const match = pick.pattern.every((need, i) => {
      if (need === null) return craftGrid[i] === null;
      return craftGrid[i] === need;
    });
    if (match) return { type: 'pickaxe', item: pick, emoji: pick.emoji, name: pick.name };
  }
  // Check axe recipes
  for (const axe of axes) {
    const match = axe.pattern.every((need, i) => {
      if (need === null) return craftGrid[i] === null;
      return craftGrid[i] === need;
    });
    if (match) return { type: 'axe', item: axe, emoji: axe.emoji, name: axe.name };
  }
  // Check sword recipes
  for (const sword of swords) {
    if (!sword.pattern) continue;
    const match = sword.pattern.every((need, i) => {
      if (need === null) return craftGrid[i] === null;
      return craftGrid[i] === need;
    });
    if (match) return { type: 'sword', item: sword, emoji: sword.emoji, name: sword.name };
  }
  // Check armor recipes
  for (const armor of armorRecipes) {
    const match = armor.pattern.every((need, i) => {
      if (need === null) return craftGrid[i] === null;
      return craftGrid[i] === need;
    });
    if (match) {
      const b = blocks.find(x => x.id === armor.outputId);
      return { type: 'armor', item: armor, emoji: b.emoji, name: b.name };
    }
  }
  // Check general recipes
  for (const recipe of craftRecipes) {
    if (recipe.shapeless) {
      // Shapeless: count placed blocks, must match needs exactly
      const placed = {};
      craftGrid.forEach(id => { if (id) placed[id] = (placed[id] || 0) + 1; });
      const placedKeys = Object.keys(placed);
      const needKeys = Object.keys(recipe.needs);
      if (placedKeys.length === needKeys.length &&
          needKeys.every(k => placed[k] === recipe.needs[k])) {
        return { type: 'item', item: recipe, emoji: recipe.emoji, name: `${recipe.name} x${recipe.outputCount}` };
      }
    } else if (recipe.pattern) {
      const match = recipe.pattern.every((need, i) => {
        if (need === null) return craftGrid[i] === null;
        return craftGrid[i] === need;
      });
      if (match) return { type: 'item', item: recipe, emoji: recipe.emoji, name: `${recipe.name} x${recipe.outputCount}` };
    }
  }
  return null;
}

function updateCraftUI() {
  // Update grid slots
  const gridEl = document.getElementById('craftGrid');
  if (!gridEl) return;
  const slots = gridEl.children;
  for (let i = 0; i < 9; i++) {
    const slot = slots[i];
    slot.textContent = '';
    slot.classList.toggle('filled', craftGrid[i] !== null);
    if (craftGrid[i]) {
      const b = blocks.find(x => x.id === craftGrid[i]);
      if (b) slot.textContent = b.emoji;
    }
  }

  // Check for recipe match
  const match = checkCraftMatch();
  const resultSlot = document.getElementById('craftResultSlot');
  const craftBtn = document.getElementById('craftBtn');
  if (resultSlot) {
    resultSlot.textContent = match ? match.emoji : '';
    resultSlot.classList.toggle('matched', !!match);
  }
  if (craftBtn) craftBtn.disabled = !match;

  // Update inventory panel
  const invGrid = document.getElementById('craftInvGrid');
  if (!invGrid) return;
  invGrid.textContent = '';
  blocks.forEach(b => {
    const count = getBlockCount(b.id);
    if (count <= 0) return;
    const item = document.createElement('div');
    item.className = 'craft-inv-item' + (craftSelected === b.id ? ' selected' : '');
    item.textContent = b.emoji;
    const countEl = document.createElement('span');
    countEl.className = 'inv-count';
    countEl.textContent = count;
    item.appendChild(countEl);
    // Show durability bar for tools
    if (toolDurability[b.id] && b.tier === 0) {
      const toolDef = pickaxes.find(p => p.id === b.id) || axes.find(a => a.id === b.id) || swords.find(s => s.id === b.id);
      if (toolDef && toolDef.durability !== Infinity) {
        const pct = (toolDurability[b.id] / toolDef.durability) * 100;
        const barColor = pct > 50 ? '#00B894' : pct > 20 ? '#FDCB6E' : '#FF6B6B';
        const bar = document.createElement('div');
        bar.style.cssText = `position:absolute;bottom:0;left:2px;right:2px;height:3px;border-radius:2px;background:rgba(0,0,0,0.2);`;
        const fill = document.createElement('div');
        fill.style.cssText = `height:100%;width:${pct}%;border-radius:2px;background:${barColor};transition:width 0.3s;`;
        bar.appendChild(fill);
        item.appendChild(bar);
      }
    }
    item.addEventListener('click', (e) => {
      e.stopPropagation();
      craftSelected = (craftSelected === b.id) ? null : b.id;
      updateCraftUI();
    });
    invGrid.appendChild(item);
  });
}

function doCraft() {
  const match = checkCraftMatch();
  if (!match) return;
  playCraftSfx();
  // Clear the grid (blocks already deducted when placed)
  craftGrid = [null,null,null, null,null,null, null,null,null];

  if (match.type === 'pickaxe' || match.type === 'axe' || match.type === 'sword') {
    addBlock(match.item.id);
    if (!toolDurability[match.item.id] && match.item.durability !== Infinity) {
      toolDurability[match.item.id] = match.item.durability;
    }
  } else if (match.type === 'armor') {
    addBlock(match.item.outputId);
  } else if (match.type === 'item') {
    addBlock(match.item.outputId, match.item.outputCount);
  }

  saveGame();
  doConfetti();
  initCollection();
}

function getHouseArt() {
  const arts = [
    'üå≥  üåø  üå≥\n\n   Á©∫Âú∞\n\nüåø  üå≥  üåø',
    'üå≥       üå≥\n\nüß±üß±üß±üß±\nüß±           üß±\nüß±üß±üß±üß±',
    'üå≥       üå≥\n\nüß±ü™µü™µüß±\nü™µ           ü™µ\nüß±ü™µü™µüß±',
    '     üî∫\n   / ü™µ \\\n  / ü™µü™µ \\\nüß±ü™µü™µüß±\nü™µ  üö™  ü™µ\nüß±ü™µü™µüß±',
    '    ‚≠ê\n     üî∫\n   / ü™µ \\\n  / ü™µü™µ \\\nüß±ü™µü™µüß±\nü™µ  üö™  ü™µ\nüß±üíöüü°üß±',
  ];
  return arts[houseProgress] || arts[arts.length - 1];
}

function renderHouse(c) {
  const houseArea = document.createElement('div');
  houseArea.className = 'house-area';

  const visual = document.createElement('div');
  visual.className = 'house-visual';
  visual.textContent = getHouseArt();
  houseArea.appendChild(visual);

  const stagesEl = document.createElement('div');
  houseStages.forEach((stage, i) => {
    const done = i < houseProgress;
    const isCurrent = i === houseProgress;
    const canBuild = isCurrent && hasBlocks(stage.needs);

    const el = document.createElement('div');
    el.className = 'house-stage ' + (done ? 'done' : isCurrent ? 'current' : 'locked');

    const info = document.createElement('div');
    info.className = 'house-stage-info';
    const nameEl = document.createElement('div');
    nameEl.className = 'house-stage-name';
    nameEl.textContent = `${stage.emoji} ${stage.name} ${done ? '‚úÖ' : ''}`;
    info.appendChild(nameEl);

    const needsEl = document.createElement('div');
    needsEl.className = 'house-stage-needs';
    if (done) {
      needsEl.textContent = 'ÂÆåÊàê';
    } else {
      Object.entries(stage.needs).forEach(([id, count], idx) => {
        const b = blocks.find(x => x.id === id);
        const have = getBlockCount(id);
        const span = document.createElement('span');
        span.className = have >= count ? 'has' : 'need';
        span.textContent = `${b.emoji} ${have}/${count}`;
        if (idx > 0) needsEl.appendChild(document.createTextNode('  '));
        needsEl.appendChild(span);
      });
    }
    info.appendChild(needsEl);
    el.appendChild(info);

    if (isCurrent) {
      const btn = document.createElement('button');
      btn.className = 'house-build-btn';
      btn.textContent = 'Âª∫ÈÄ†';
      btn.disabled = !canBuild;
      btn.addEventListener('click', () => {
        removeBlocks(stage.needs);
        houseProgress++;
        saveGame();
        doConfetti();
        initCollection();
      });
      el.appendChild(btn);
    }

    stagesEl.appendChild(el);
  });
  houseArea.appendChild(stagesEl);
  c.appendChild(houseArea);
}

function renderEquipment(c) {
  const area = document.createElement('div');
  area.className = 'equip-area';

  const charContainer = document.createElement('div');
  renderCharacter(charContainer, 'large');
  area.appendChild(charContainer);

  const slotsEl = document.createElement('div');
  slotsEl.className = 'equip-slots';
  const slotLabels = { helmet: 'ü™ñ È†≠Áõî', chest: 'ü¶∫ ÁõîÁî≤', legs: 'üëñ Ë§≤Â≠ê', boots: 'üë¢ ÈûãÂ≠ê' };

  armorSlots.forEach(slot => {
    const slotEl = document.createElement('div');
    slotEl.className = 'equip-slot';

    const label = document.createElement('div');
    label.className = 'equip-slot-label';
    label.textContent = slotLabels[slot];
    slotEl.appendChild(label);

    const itemEl = document.createElement('div');
    itemEl.className = 'equip-slot-item';

    if (equipped[slot]) {
      const b = blocks.find(x => x.id === equipped[slot]);
      itemEl.textContent = b ? b.emoji : '';
      const nameEl = document.createElement('div');
      nameEl.className = 'equip-slot-name';
      nameEl.textContent = b ? b.name : '';
      slotEl.appendChild(itemEl);
      slotEl.appendChild(nameEl);
      slotEl.addEventListener('click', () => {
        addBlock(equipped[slot]);
        equipped[slot] = null;
        saveGame();
        initCollection();
      });
    } else {
      itemEl.textContent = '‚Äî';
      const nameEl = document.createElement('div');
      nameEl.className = 'equip-slot-name equip-slot-empty';
      nameEl.textContent = 'Á©∫';
      slotEl.appendChild(itemEl);
      slotEl.appendChild(nameEl);
      slotEl.addEventListener('click', () => {
        const available = blocks.filter(b => b.id.includes('_' + slot) && getBlockCount(b.id) > 0);
        if (available.length === 0) return;
        const best = available[available.length - 1];
        inventory[best.id] = (inventory[best.id] || 1) - 1;
        if (inventory[best.id] <= 0) delete inventory[best.id];
        equipped[slot] = best.id;
        saveGame();
        initCollection();
      });
    }

    slotsEl.appendChild(slotEl);
  });
  area.appendChild(slotsEl);

  const invTitle = document.createElement('div');
  invTitle.style.cssText = 'text-align:center;margin-top:16px;font-family:Fredoka,sans-serif;font-size:0.9rem;color:#636E72;';
  invTitle.textContent = 'üì¶ ËÉåÂåÖ‰∏≠ÁöÑË£ùÂÇôÔºàÈªûÊìäÁ©ø‰∏äÔºâ';
  area.appendChild(invTitle);

  const invGrid = document.createElement('div');
  invGrid.className = 'equip-inventory';
  let hasEquipment = false;

  blocks.forEach(b => {
    if (!b.id.includes('_helmet') && !b.id.includes('_chest') && !b.id.includes('_legs') && !b.id.includes('_boots')) return;
    const count = getBlockCount(b.id);
    if (count <= 0) return;
    hasEquipment = true;

    const item = document.createElement('div');
    item.className = 'equip-inv-item';
    item.textContent = b.emoji;
    item.title = b.name;

    const countEl = document.createElement('span');
    countEl.className = 'inv-count';
    countEl.textContent = count;
    item.appendChild(countEl);

    const slot = b.id.includes('_helmet') ? 'helmet' : b.id.includes('_chest') ? 'chest' : b.id.includes('_legs') ? 'legs' : 'boots';
    item.addEventListener('click', () => {
      if (equipped[slot]) addBlock(equipped[slot]);
      inventory[b.id] = (inventory[b.id] || 1) - 1;
      if (inventory[b.id] <= 0) delete inventory[b.id];
      equipped[slot] = b.id;
      saveGame();
      initCollection();
    });

    invGrid.appendChild(item);
  });

  if (!hasEquipment) {
    const emptyMsg = document.createElement('div');
    emptyMsg.style.cssText = 'color:#B2BEC3;font-size:0.85rem;padding:8px;';
    emptyMsg.textContent = 'ÈÇÑÊ≤íÊúâË£ùÂÇôÔºåÂéªÂêàÊàê‰∏Ä‰∫õÂêßÔºÅ';
    invGrid.appendChild(emptyMsg);
  }
  area.appendChild(invGrid);
  c.appendChild(area);
}

// ===== INIT =====
loadGame();
initLearn();

// Settings modal
const settingsModal = document.getElementById('settingsModal');
const settingsBtn = document.getElementById('settingsBtn');
const settingsClose = document.getElementById('settingsClose');
settingsBtn.addEventListener('click', () => { settingsModal.classList.add('active'); });
settingsClose.addEventListener('click', () => { settingsModal.classList.remove('active'); });
settingsModal.addEventListener('click', (e) => {
  if (e.target === settingsModal) settingsModal.classList.remove('active');
});

// Mute toggle
isMuted = localStorage.getItem('isMuted') === 'true';
const muteOffBtn = document.getElementById('muteOff');
const muteOnBtn = document.getElementById('muteOn');
function updateMuteUI() {
  muteOffBtn.classList.toggle('active', !isMuted);
  muteOnBtn.classList.toggle('active', isMuted);
}
updateMuteUI();
muteOffBtn.addEventListener('click', () => { isMuted = false; localStorage.setItem('isMuted', 'false'); updateMuteUI(); });
muteOnBtn.addEventListener('click', () => { isMuted = true; localStorage.setItem('isMuted', 'true'); updateMuteUI(); });

// Reset progress
document.getElementById('resetProgress').addEventListener('click', () => {
  if (confirm('Á¢∫ÂÆöË¶ÅÈáçÁΩÆÊâÄÊúâÈÅäÊà≤ÈÄ≤Â∫¶ÂóéÔºüÊ≠§Êìç‰ΩúÁÑ°Ê≥ïÂæ©ÂéüÔºÅ')) {
    localStorage.removeItem('mineGame');
    localStorage.removeItem('isMuted');
    location.reload();
  }
});

// Pre-warm: load voices so pickBestVoice works on first click
if (window.speechSynthesis) {
  speechSynthesis.getVoices();
  speechSynthesis.onvoiceschanged = () => {
    cachedVoice = null; // re-pick on voice list change
    speechSynthesis.getVoices();
  };
}
</script>
</body>
</html>
