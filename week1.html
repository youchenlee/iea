<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Feelings Fun! üé≠</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&family=Nunito:wght@400;600;700;800&display=swap');

:root {
  /* Palette */
  --bg: #FFF8E7;
  --text: #2D3436;
  --text-secondary: #636E72;
  --text-muted: #B2BEC3;
  --card-bg: #FFFFFF;
  --surface: #F0F0F5;
  --border: #DFE6E9;
  --accent: #A29BFE;
  --accent-dark: #6C5CE7;
  --success: #00B894;
  --error: #FF6B6B;
  --gold: #FFD93D;
  --gold-dark: #FDCB6E;
  /* Shadows */
  --shadow: rgba(45, 52, 54, 0.1);
  --shadow-sm: 0 2px 10px var(--shadow);
  --shadow-md: 0 3px 15px var(--shadow);
  --shadow-lg: 0 8px 25px var(--shadow);
  /* Shape */
  --radius: 20px;
  --radius-sm: 14px;
  --radius-pill: 50px;
  /* Typography */
  --font-display: 'Fredoka', sans-serif;
  --font-body: 'Nunito', sans-serif;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: var(--font-body);
  background: var(--bg);
  min-height: 100vh;
}

body::before {
  content: '';
  position: fixed;
  inset: 0;
  background:
    radial-gradient(circle at 10% 20%, rgba(255,217,61,0.15) 0%, transparent 50%),
    radial-gradient(circle at 90% 80%, rgba(162,155,254,0.12) 0%, transparent 50%),
    radial-gradient(circle at 50% 50%, rgba(255,133,202,0.08) 0%, transparent 60%);
  pointer-events: none;
  z-index: 0;
}

.app { position: relative; z-index: 1; max-width: 1100px; margin: 0 auto; padding: 16px; padding-top: 40px; min-height: 100vh; display: flex; flex-direction: column; overflow-x: hidden; }

.header {
  position: fixed; top: 0; left: 0; right: 0; z-index: 50;
  display: flex; align-items: center; justify-content: space-between;
  padding: 8px 14px; padding-right: 80px;
  background: rgba(255,248,231,0.95);
  backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  transition: transform 0.3s ease, box-shadow 0.3s;
  box-shadow: 0 1px 8px rgba(0,0,0,0.06);
}
.header.hidden { transform: translateY(-100%); }
.header h1 {
  font-family: var(--font-display);
  font-size: 1.1rem;
  font-weight: 700;
  background: linear-gradient(135deg, #FF6B6B, #A29BFE, #E17055);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  line-height: 1;
  flex-shrink: 0;
}
.header .subtitle { display: none; }

.score-bar {
  display: flex; gap: 6px; flex-wrap: nowrap;
}
.score-item {
  background: rgba(255,255,255,0.9);
  backdrop-filter: blur(8px);
  padding: 4px 10px;
  border-radius: 50px;
  font-weight: 700;
  font-size: 0.75rem;
  box-shadow: 0 1px 6px var(--shadow);
  display: flex;
  align-items: center;
  gap: 4px;
  transition: transform 0.3s;
}
.score-item.pop { animation: pop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
@keyframes pop {
  0% { transform: scale(1); }
  30% { transform: scale(1.4); background: #FFD93D; color: #2D3436; }
  60% { transform: scale(0.95); }
  100% { transform: scale(1); }
}
.gem-float {
  position: fixed; top: 8px; right: 14px; z-index: 51;
  background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
  padding: 5px 12px; border-radius: 50px;
  font-weight: 700; font-size: 0.8rem;
  box-shadow: 0 2px 10px rgba(0,0,0,0.12);
  display: flex; align-items: center; gap: 4px;
  transition: transform 0.3s, top 0.25s;
  -webkit-transform: translateZ(0); transform: translateZ(0);
}
.gem-float.pop { animation: pop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }

.bottom-nav {
  position: fixed; bottom: 0; left: 0; right: 0; z-index: 10;
  background: rgba(255,255,255,0.95); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
  border-top: 1px solid rgba(0,0,0,0.08);
  transform: translateZ(0); -webkit-transform: translateZ(0); /* iOS fixed positioning fix */
  display: flex; justify-content: center;
  padding: 0 4px; padding-bottom: env(safe-area-inset-bottom, 0);
  box-shadow: 0 -2px 12px rgba(0,0,0,0.06);
}
.bottom-nav-inner {
  display: flex; width: 100%; max-width: 600px; justify-content: space-around;
}
.nav-tab {
  display: flex; flex-direction: column; align-items: center; gap: 1px;
  padding: 6px 2px 4px; border: none; background: transparent;
  font-family: var(--font-display); font-size: 0.6rem; font-weight: 600;
  color: var(--text-secondary); cursor: pointer; transition: all 0.2s;
  min-width: 0; flex: 1; position: relative;
}
.nav-tab .nav-icon { font-size: 1.25rem; line-height: 1.2; }
.nav-tab .nav-label { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }
.nav-tab:hover { color: var(--text); }
.nav-tab.active { color: var(--accent); font-weight: 700; }
.nav-tab.active::after {
  content: ''; position: absolute; top: 0; left: 25%; right: 25%;
  height: 2.5px; border-radius: 0 0 2px 2px; background: var(--accent);
}
.nav-tab .stamina-hint { font-size: 0.5rem; opacity: 0.6; position: absolute; top: 2px; right: 4px; }
.nav-spacer { height: 64px; } /* push content above fixed nav */

.section { display: none; animation: fadeIn 0.4s ease; }
.section.active { display: block; }
.section-title {
  font-family: var(--font-display); font-size: 1.2rem; font-weight: 600;
  color: var(--text); text-align: center; margin-bottom: 4px;
}
.section-subtitle {
  font-size: 0.85rem; color: var(--text-secondary); text-align: center; margin-bottom: 12px;
}
.section-empty {
  text-align: center; color: var(--text-muted); padding: 40px 0;
}
.section-empty span { font-size: 0.85rem; }
.app-footer {
  text-align: center; font-size: 0.7rem; color: var(--text-muted);
  padding: 24px 16px 80px; line-height: 1.6;
  margin-top: auto;
}
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: none; } }

/* ===== LEARN ===== */
.feelings-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 14px;
  margin-top: 10px;
}
.feeling-card {
  background: var(--card-bg);
  border-radius: var(--radius);
  padding: 18px 12px;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  box-shadow: var(--shadow-md);
  border: 3px solid transparent;
  position: relative;
}
.feeling-card:hover { transform: translateY(-6px) scale(1.03); box-shadow: var(--shadow-lg); }
.feeling-card:active { transform: scale(0.95); }
.feeling-card .emoji { font-size: 2.8rem; margin-bottom: 8px; display: block; }
.feeling-card .word { font-family: var(--font-display); font-size: 1.15rem; font-weight: 600; color: var(--text); }
.feeling-card .chinese { font-size: 0.85rem; color: var(--text-secondary); margin-top: 2px; }
.feeling-card .speaker-hint {
  position: absolute; top: 8px; right: 8px;
  font-size: 1rem; opacity: 0.3; transition: opacity 0.2s;
}
.feeling-card:hover .speaker-hint { opacity: 0.7; }
.feeling-card.speaking {
  border-color: var(--accent);
  animation: speakRing 0.6s ease;
}
@keyframes speakRing {
  0%, 100% { box-shadow: var(--shadow-md); }
  50% { box-shadow: 0 0 0 6px rgba(162,155,254,0.3), 0 3px 15px var(--shadow); }
}

.sentence-practice {
  background: white;
  border-radius: var(--radius);
  padding: 24px;
  margin-top: 20px;
  box-shadow: var(--shadow-md);
  text-align: center;
}
.sentence-practice h3 { font-family: var(--font-display); font-size: 1.2rem; color: var(--text); margin-bottom: 14px; }
.sentence-display {
  font-size: 1.6rem;
  font-family: var(--font-display);
  font-weight: 600;
  color: #2D3436;
  padding: 14px;
  background: #F8F9FA;
  border-radius: 14px;
  margin-bottom: 14px;
  min-height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  flex-wrap: wrap;
  line-height: 1.4;
}
.sentence-display .hl { color: var(--accent); font-weight: 700; }

.learn-section-title {
  font-family: var(--font-display); font-size: 1.1rem; color: var(--text);
  margin: 10px 0 4px 4px;
}
.sight-learn-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 14px;
}
.sight-learn-card {
  background: var(--card-bg);
  border-radius: var(--radius);
  padding: 16px 12px;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  box-shadow: var(--shadow-md);
  position: relative;
}
.sight-learn-card:hover { transform: translateY(-6px) scale(1.03); box-shadow: var(--shadow-lg); }
.sight-learn-card:active { transform: scale(0.95); }
.sight-learn-card .speaker-hint {
  position: absolute; top: 8px; right: 8px;
  font-size: 1rem; opacity: 0.3; transition: opacity 0.2s;
}
.sight-learn-card:hover .speaker-hint { opacity: 0.7; }
.sight-learn-card.speaking {
  border-color: var(--accent);
  animation: speakRing 0.6s ease;
}
.sight-learn-card .sl-word {
  font-family: var(--font-display); font-size: 1.3rem; font-weight: 700; color: var(--text);
}
.sight-learn-card .sl-zh {
  font-size: 0.85rem; color: var(--text-secondary); margin-top: 2px;
}
.sight-learn-card .sl-sentence {
  font-size: 0.75rem; color: var(--text-muted); margin-top: 6px; font-style: italic;
}

/* ===== READ (Sentence Reading) ===== */
.read-header { text-align: center; margin-bottom: 16px; }
.read-header h3 { font-family: var(--font-display); font-size: 1.3rem; color: var(--text); }
.read-header p { font-size: 0.85rem; color: var(--text-secondary); margin-top: 4px; }
.read-unit-toggle { display: flex; gap: 8px; justify-content: center; margin: 10px 0 6px; }
.read-unit-btn {
  padding: 7px 16px; border-radius: var(--radius-pill); border: 2px solid var(--border);
  background: var(--surface); color: var(--text-secondary); font-family: var(--font-display);
  font-size: 0.85rem; font-weight: 600; cursor: pointer; transition: all 0.2s;
}
.read-unit-btn.active { background: var(--accent); border-color: var(--accent); color: white; }
.sc-qa { display: flex; flex-direction: column; gap: 6px; }
.sc-qa-row { display: flex; gap: 8px; align-items: flex-start; }
.sc-qa-label {
  font-family: var(--font-display); font-size: 0.7rem; font-weight: 700;
  padding: 2px 7px; border-radius: 8px; flex-shrink: 0; margin-top: 2px;
}
.sc-qa-label.q { background: #74B9FF33; color: #0984e3; }
.sc-qa-label.a { background: #00B89433; color: #00b894; }
.sc-qa-text { font-family: var(--font-display); font-size: 1rem; font-weight: 600; color: var(--text); line-height: 1.4; }
.sc-qa-zh { font-size: 0.78rem; color: var(--text-secondary); margin-top: 1px; padding-left: 36px; }
.read-progress-bar { width: 100%; height: 8px; background: var(--surface); border-radius: 4px; margin-top: 8px; overflow: hidden; }
.read-progress-fill { height: 100%; background: linear-gradient(90deg, var(--success), #55EFC4); border-radius: 4px; transition: width 0.4s ease; }
.sentence-cards { display: flex; flex-direction: column; gap: 14px; }
.sentence-card {
  background: var(--card-bg); border-radius: var(--radius); padding: 18px 16px;
  box-shadow: var(--shadow-md); cursor: pointer; position: relative;
  transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  border-left: 5px solid var(--border);
}
.sentence-card:hover { transform: translateY(-3px); box-shadow: var(--shadow-lg); }
.sentence-card:active { transform: scale(0.98); }
.sentence-card.speaking { border-left-color: var(--accent); animation: speakRing 0.6s ease; }
.sentence-card.done { border-left-color: var(--success); }
.sentence-card .sc-number {
  font-family: var(--font-display); font-size: 0.8rem; font-weight: 700;
  color: var(--text-muted); margin-bottom: 6px;
}
.sentence-card .sc-en {
  font-family: var(--font-display); font-size: 1.1rem; font-weight: 600;
  color: var(--text); line-height: 1.5;
}
.sentence-card .sc-zh {
  font-size: 0.85rem; color: var(--text-secondary); margin-top: 6px;
}
.sentence-card .sc-bottom {
  display: flex; align-items: center; justify-content: space-between; margin-top: 10px;
}
.sentence-card .sc-count {
  font-size: 0.8rem; color: var(--text-muted); font-family: var(--font-body);
}
.sentence-card .sc-dots { display: flex; gap: 6px; }
.sentence-card .sc-dot {
  width: 14px; height: 14px; border-radius: 50%;
  background: var(--surface); border: 2px solid var(--border); transition: all 0.3s;
}
.sentence-card .sc-dot.filled { background: var(--success); border-color: var(--success); }
.sentence-card .sc-listen-btn {
  padding: 6px 14px; border-radius: var(--radius-pill); border: 2px solid var(--accent);
  background: transparent; color: var(--accent-dark); font-family: var(--font-display);
  font-size: 0.8rem; font-weight: 600; cursor: pointer; transition: all 0.2s;
}
.sentence-card .sc-listen-btn:hover { background: var(--accent); color: white; }
@media (max-width: 600px) {
  .sentence-card .sc-en { font-size: 1rem; }
}

.btn-row { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
.speak-btn {
  padding: 12px 28px;
  border-radius: 50px;
  border: none;
  font-family: var(--font-display);
  font-size: 1.1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s;
  display: inline-flex;
  align-items: center;
  gap: 8px;
}
.speak-btn:hover { transform: translateY(-2px); }
.speak-btn:active { transform: scale(0.95); }
.speak-btn.primary {
  background: linear-gradient(135deg, var(--accent), var(--accent-dark));
  color: white;
  box-shadow: 0 4px 15px rgba(108,92,231,0.3);
}
.speak-btn.secondary {
  background: linear-gradient(135deg, var(--gold), var(--gold-dark));
  color: #2D3436;
  box-shadow: 0 4px 15px rgba(253,203,110,0.3);
}
.speak-btn.small { padding: 8px 18px; font-size: 0.95rem; }
.speak-btn.playing { opacity: 0.7; pointer-events: none; }

.feeling-chips { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-top: 14px; }
.feeling-chip {
  padding: 8px 16px;
  border-radius: 50px;
  border: 2px solid var(--border);
  background: white;
  font-family: var(--font-display);
  font-size: 0.95rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}
.feeling-chip:hover { background: #F8F9FA; transform: scale(1.05); }
.feeling-chip.selected { border-color: var(--accent); background: #F0EDFF; }

/* ===== MATCH ===== */
.match-feedback {
  text-align: center; padding: 16px;
  font-family: var(--font-display); font-size: 1.3rem; font-weight: 600;
  min-height: 56px; display: flex; align-items: center; justify-content: center;
}
.match-game { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start; }
.match-column h3 { font-family: var(--font-display); text-align: center; margin-bottom: 12px; color: var(--text-secondary); font-size: 1rem; }
.match-item {
  padding: 0 18px; height: 52px; border-radius: 14px; margin-bottom: 10px;
  cursor: pointer; transition: all 0.3s;
  font-family: var(--font-display); font-size: 1.1rem; font-weight: 600;
  text-align: center; user-select: none;
  background: white; border: 3px solid var(--border); box-shadow: var(--shadow-sm);
  display: flex; align-items: center; justify-content: center;
}
.match-item.emoji-item { font-size: 2rem; }
.match-item:hover { transform: scale(1.05); }
.match-item.selected { border-color: var(--accent); background: #F0EDFF; box-shadow: 0 4px 16px rgba(162,155,254,0.3); }
.match-item.correct { border-color: var(--success); background: #E8FFF5; animation: correctBounce 0.5s ease; }
.match-item.wrong { border-color: var(--error); background: #FFE8E8; animation: shake 0.4s ease; }
.match-item.matched { opacity: 0.35; pointer-events: none; transform: scale(0.95); }
@keyframes correctBounce { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.12); } }
@keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-8px); } 75% { transform: translateX(8px); } }

.reset-btn {
  display: block; margin: 16px auto 0;
  padding: 12px 32px; border-radius: 50px; border: none;
  background: linear-gradient(135deg, var(--gold), var(--gold-dark));
  color: #2D3436;
  font-family: var(--font-display); font-size: 1.05rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
  box-shadow: 0 4px 15px rgba(253,203,110,0.3);
}
.reset-btn:hover { transform: translateY(-2px); }

/* ===== QUIZ ===== */
.quiz-container {
  background: white; border-radius: var(--radius); padding: 30px;
  box-shadow: var(--shadow-md); text-align: center;
}
.quiz-progress { display: flex; gap: 6px; justify-content: center; margin-bottom: 20px; }
.quiz-dot { width: 12px; height: 12px; border-radius: 50%; background: var(--border); transition: all 0.3s; }
.quiz-dot.done { background: var(--success); }
.quiz-dot.current { background: var(--accent); transform: scale(1.3); }
.quiz-dot.wrong-dot { background: var(--error); }
.quiz-prompt { font-size: 3.5rem; margin: 20px 0; }
.quiz-question { font-family: var(--font-display); font-size: 1.3rem; color: var(--text-secondary); margin-bottom: 20px; }
.quiz-options { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; max-width: 500px; margin: 0 auto; }
.quiz-option {
  padding: 16px; border-radius: 14px; border: 3px solid var(--border);
  background: white; font-family: var(--font-display); font-size: 1.15rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
}
.quiz-option:hover { border-color: var(--accent); transform: translateY(-2px); }
.quiz-option.correct-answer { border-color: var(--success); background: #E8FFF5; }
.quiz-option.wrong-answer { border-color: var(--error); background: #FFE8E8; }

.quiz-result { padding: 30px; text-align: center; }
.quiz-result .big-emoji { font-size: 4rem; margin-bottom: 16px; }
.quiz-result .result-text { font-family: var(--font-display); font-size: 1.6rem; font-weight: 700; margin-bottom: 8px; }
.quiz-result .result-detail { font-size: 1.1rem; color: var(--text-secondary); margin-bottom: 20px; }

/* ===== SIGHT WORDS ===== */
.sight-words-area { display: flex; flex-direction: column; gap: 14px; }
.sight-word-card {
  background: white; border-radius: var(--radius); padding: 20px 24px;
  display: flex; align-items: center; justify-content: space-between;
  box-shadow: var(--shadow-md); cursor: pointer; transition: all 0.3s;
}
.sight-word-card:hover { transform: translateY(-3px); box-shadow: 0 6px 20px var(--shadow); }
.sight-word-card:active { transform: scale(0.97); }
.sight-word-text { font-family: var(--font-display); font-size: 2rem; font-weight: 700; color: var(--text); }
.sight-word-chinese { font-size: 1rem; color: var(--text-secondary); margin-top: 2px; }
.sight-word-card .play-icon {
  width: 48px; height: 48px; border-radius: 50%;
  background: linear-gradient(135deg, var(--accent), var(--accent-dark));
  display: flex; align-items: center; justify-content: center;
  color: white; font-size: 1.3rem; flex-shrink: 0;
}
.sight-word-card.speaking { border-left: 5px solid var(--accent); }
.sight-word-card.earned { opacity: 0.6; }
.sight-word-card.earned .play-icon { background: var(--success); }
.sight-confirm {
  padding: 6px 14px; border-radius: 50px; border: none;
  background: linear-gradient(135deg, var(--gold), var(--gold-dark)); color: #2D3436;
  font-family: var(--font-display); font-size: 0.85rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s; animation: fadeIn 0.3s ease;
  margin-top: 6px;
}
.sight-confirm:hover { transform: scale(1.05); }
.sight-confirm:disabled { cursor: not-allowed; }

/* Speed toggle */
.speed-toggle {
  display: flex; gap: 6px; justify-content: center; margin: 10px 0;
}
.speed-btn {
  padding: 6px 14px; border-radius: 50px;
  border: 2px solid var(--border); background: white;
  font-family: var(--font-display); font-size: 0.85rem; font-weight: 600;
  cursor: pointer; color: var(--text-secondary); transition: all 0.2s;
}
.speed-btn.active { border-color: var(--accent); background: #F0EDFF; color: var(--accent); }

.settings-section { margin-bottom: 16px; }
.settings-label {
  font-family: var(--font-display); font-size: 0.9rem;
  font-weight: 600; color: var(--text); margin-bottom: 6px;
}
.confetti-box { position: fixed; inset: 0; pointer-events: none; z-index: 100; }
.confetti-piece {
  position: absolute; width: 10px; height: 10px; border-radius: 2px;
  animation: confDrop 2s ease-out forwards;
}
@keyframes confDrop {
  0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
  100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
}

/* ===== MINE ===== */
.mine-header { text-align: center; margin-bottom: 12px; }
.mine-pickaxe { font-size: 1rem; color: var(--text-secondary); margin-top: 4px; }

.mountain-scroll {
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  border-radius: var(--radius);
  flex: 1; min-width: 0;
  position: relative;
  cursor: grab;
}
.mountain-scroll-hint {
  display: none;
  position: absolute; right: 0; top: 0; bottom: 0; width: 28px;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6));
  pointer-events: none; z-index: 1;
  animation: scrollHintPulse 2s ease-in-out infinite;
}
.mountain-scroll-hint::after {
  content: '‚Üí'; position: absolute; right: 4px; top: 50%;
  transform: translateY(-50%); font-size: 1rem; opacity: 0.5;
}
@keyframes scrollHintPulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }
.mountain-scroll-wrap {
  display: flex; align-items: center; gap: 4px;
}
.mountain-arrow {
  flex-shrink: 0; width: 36px; height: 60px;
  border: none; border-radius: 10px;
  background: rgba(0,0,0,0.08); color: var(--text-secondary);
  font-size: 1.1rem; cursor: pointer;
  transition: all 0.2s;
}
.mountain-arrow:hover { background: rgba(0,0,0,0.15); }
.mountain-arrow:active { transform: scale(0.92); }
.mountain {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  min-width: fit-content;
  padding: 10px 0;
  background: linear-gradient(180deg, #87CEEB 0%, #87CEEB 20%, #E8D5B7 100%);
  border-radius: var(--radius);
}
.mountain-row {
  display: flex;
  gap: 2px;
}
.mine-cell {
  width: 38px; height: 38px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.3rem;
  cursor: pointer;
  transition: all 0.15s;
  border: 1px solid rgba(0,0,0,0.15);
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.2);
  position: relative;
  user-select: none;
}
.mine-cell:hover:not(.mined):not(.locked) { transform: scale(1.12); z-index: 2; box-shadow: 0 0 8px rgba(255,255,255,0.5); }

.mine-cell.unexposed { opacity: 0.85; cursor: default; }
.mine-cell.unexposed:hover { transform: none; box-shadow: inset 0 -2px 4px rgba(0,0,0,0.2); }
.mine-cell.spacer {
  background: transparent; border: none; box-shadow: none;
  cursor: default; pointer-events: auto;
}
.mine-cell.mined {
  background: rgba(135,206,235,0.25) !important;
  border-color: transparent;
  box-shadow: none;
}
.mine-cell.locked {
  cursor: not-allowed;
  position: relative;
}
.mine-cell.locked::after {
  content: 'üîí';
  position: absolute;
  font-size: 0.8rem;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.4);
  border-radius: 4px;
}
.mine-cell .block-reveal {
  animation: blockPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
@keyframes blockPop {
  0% { transform: scale(0) rotate(-20deg); opacity: 0; }
  60% { transform: scale(1.3) rotate(5deg); opacity: 1; }
  100% { transform: scale(1) rotate(0); }
}
.mine-cell.tier1 { background: linear-gradient(180deg, #8B6F47, #6B4F37); }
.mine-cell.tier2 { background: linear-gradient(180deg, #7F8C8D, #616A6B); }
.mine-cell.tier3 { background: linear-gradient(180deg, #5D6D7E, #4A5568); }
.mine-cell.tier4 { background: linear-gradient(180deg, #6B4C3B, #4A3728); }
.mine-cell.tier5 { background: linear-gradient(180deg, #2C3E6D, #1A2547); }
.mine-cell.tree { background: none; border: none; box-shadow: none; font-size: 1.5rem; cursor: pointer; }
.mine-cell.tree:hover { transform: scale(1.15); }
.mine-cell.tree.mined { background: rgba(135,206,235,0.25) !important; border: none; box-shadow: none; }
.mine-cell.animal { background: none; border: none; box-shadow: none; font-size: 1.5rem; cursor: pointer; }
.mine-cell.animal:hover { transform: scale(1.15); }
.mine-cell.animal.hostile { filter: drop-shadow(0 0 3px rgba(255,60,60,0.6)); }
.mine-cell.animal.mined { background: rgba(135,206,235,0.25) !important; border: none; box-shadow: none; }


.mine-result {
  text-align: center; margin-top: 12px; padding: 10px;
  font-family: var(--font-display); font-size: 1.05rem; font-weight: 600;
  min-height: 44px; transition: background 0.3s;
}
.mine-result.tool-broke {
  background: #FFEAA7; border-radius: 12px;
  animation: toolBrokeFlash 1.5s ease-out;
}
@keyframes toolBrokeFlash {
  0%, 20% { background: var(--error); color: white; transform: scale(1.05); }
  100% { background: #FFEAA7; color: inherit; transform: scale(1); }
}
.tool-slots { display: flex; gap: 8px; justify-content: center; margin: 8px 0; }
.tool-slot {
  display: flex; flex-direction: column; align-items: center; gap: 2px;
  padding: 6px 10px; border-radius: 10px; border: 2px solid var(--border);
  background: white; cursor: pointer; transition: all 0.15s;
  font-family: var(--font-display); position: relative; user-select: none;
  min-width: 64px;
}
.tool-slot:hover { border-color: var(--accent-dark); background: #F8F7FF; }
.tool-slot:active { transform: scale(0.96); }
.tool-slot-label { font-size: 0.65rem; color: var(--text-muted); }
.tool-slot-emoji { font-size: 1.4rem; line-height: 1.2; }
.tool-slot-name { font-size: 0.75rem; font-weight: 600; color: #2D3436; white-space: nowrap; }
.tool-slot-dur { font-size: 0.6rem; color: var(--text-muted); }
.tool-picker {
  background: white; border-radius: 12px; box-shadow: 0 8px 30px rgba(0,0,0,0.18);
  border: 1px solid var(--border); z-index: 20; min-width: 150px;
  padding: 6px 0; animation: pickerIn 0.15s ease-out;
}
@keyframes pickerIn { from { opacity: 0; transform: translateX(-50%) translateY(-4px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
.tool-picker-option {
  display: flex; align-items: center; gap: 8px;
  padding: 8px 14px; cursor: pointer; font-family: var(--font-display); font-size: 0.85rem;
  transition: background 0.1s;
}
.tool-picker-option:hover { background: #F0EFFF; }
.tool-picker-option.selected { background: #E8E6FF; font-weight: 600; }
.tool-picker-option .opt-emoji { font-size: 1.1rem; }
.tool-picker-option .opt-info { font-size: 0.7rem; color: var(--text-muted); margin-left: auto; }
.tool-picker-backdrop { position: fixed; inset: 0; z-index: 19; }
.mine-refresh {
  display: block; margin: 10px auto 0;
  padding: 6px 16px; border-radius: 20px; border: 1px solid var(--border);
  background: var(--surface);
  color: var(--text-secondary);
  font-family: var(--font-body); font-size: 0.8rem; font-weight: 400;
  cursor: pointer; transition: all 0.2s;
}
.mine-refresh:hover { background: #E0E0E8; }
.mine-refresh:disabled { opacity: 0.4; pointer-events: none; }

/* ===== ENCYCLOPEDIA ===== */
.encyclopedia-grid {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
  gap: 12px;
}
.block-card {
  background: white; border-radius: var(--radius); padding: 14px;
  text-align: center; box-shadow: var(--shadow-sm);
  border: 3px solid var(--border); transition: all 0.3s;
}
.block-card.owned { border-color: var(--success); }
.block-card.undiscovered { opacity: 0.4; }
.block-card .block-emoji { font-size: 2.2rem; margin-bottom: 6px; }
.block-card .block-name { font-family: var(--font-display); font-size: 1rem; font-weight: 600; }
.block-card .block-count { font-size: 0.85rem; color: var(--text-secondary); margin-top: 2px; }
.block-card .block-tier { font-size: 0.7rem; color: var(--accent); margin-top: 2px; }

.craft-area { max-width: 500px; margin: 0 auto; }
.craft-guide {
  text-align: center; font-family: var(--font-display);
  font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 12px;
  background: #F0FFF8; padding: 8px 16px; border-radius: 50px;
  border: 1px dashed var(--success);
}

.craft-table {
  display: flex; align-items: center; justify-content: center;
  gap: 16px; flex-wrap: wrap; margin-bottom: 16px;
}
.craft-grid {
  display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px;
  background: #8B6F47; padding: 8px; border-radius: 12px;
  box-shadow: inset 0 2px 6px rgba(0,0,0,0.3), 0 3px 10px var(--shadow);
}
.craft-slot {
  width: 52px; height: 52px; border-radius: 6px;
  background: #A0855C; border: 2px solid #6B4F37;
  display: flex; align-items: center; justify-content: center;
  font-size: 1.6rem; cursor: pointer; transition: all 0.15s;
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.15);
}
.craft-slot:hover { background: #B8976A; transform: scale(1.05); }
.craft-slot.filled { background: #C4A97D; border-color: #8B6F47; }

.craft-arrow { font-size: 1.8rem; color: var(--text-secondary); }

.craft-result-slot {
  width: 64px; height: 64px; border-radius: 8px;
  background: #A0855C; border: 3px solid #6B4F37;
  display: flex; align-items: center; justify-content: center;
  font-size: 2rem; position: relative;
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.15);
}
.craft-result-slot.matched {
  border-color: var(--success); background: #C4A97D;
  animation: correctBounce 0.5s ease;
}

.craft-actions { display: flex; gap: 8px; justify-content: center; margin-bottom: 16px; }
.craft-btn {
  padding: 10px 24px; border-radius: 50px; border: none;
  font-family: var(--font-display); font-size: 1rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
}
.craft-btn:hover { transform: translateY(-2px); }
.craft-btn:disabled { opacity: 0.4; pointer-events: none; }
.craft-btn.primary { background: linear-gradient(135deg, var(--success), #00CEC9); color: white; box-shadow: 0 4px 15px rgba(0,184,148,0.3); }
.craft-btn.secondary { background: linear-gradient(135deg, var(--border), #BDC3C7); color: #2D3436; }

.craft-inventory {
  background: #8B6F47; border-radius: 12px; padding: 10px;
  box-shadow: inset 0 2px 6px rgba(0,0,0,0.3), 0 3px 10px var(--shadow);
}
.craft-inv-title {
  font-family: var(--font-display); font-size: 0.9rem;
  color: #FFFFFF; margin-bottom: 8px; text-align: center;
}
.craft-inv-grid {
  display: flex; flex-wrap: wrap; gap: 4px; justify-content: center;
}
.craft-inv-item {
  width: 48px; height: 48px; border-radius: 6px;
  background: #A0855C; border: 2px solid #6B4F37;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  font-size: 1.2rem; cursor: pointer; transition: all 0.15s;
  position: relative;
}
.craft-inv-item:hover { background: #B8976A; transform: scale(1.08); }
.craft-inv-item.selected { border-color: #FFD93D; background: #C4A97D; box-shadow: 0 0 8px rgba(255,217,61,0.5); }
.craft-inv-item .inv-count {
  font-size: 0.55rem; font-weight: 700; color: #FFF;
  background: rgba(0,0,0,0.5); border-radius: 4px; padding: 0 3px;
  position: absolute; bottom: 2px; right: 2px;
}

.recipe-book { margin-top: 20px; }
.recipe-book-title {
  font-family: var(--font-display); font-size: 1.1rem; font-weight: 600;
  color: var(--text); text-align: center; margin-bottom: 12px;
}
.recipe-list { display: flex; flex-direction: column; gap: 10px; }
.recipe-card {
  background: white; border-radius: 14px; padding: 12px 16px;
  box-shadow: var(--shadow-sm); display: flex; align-items: center; gap: 12px;
  border: 2px solid var(--border); transition: all 0.2s;
}
.recipe-card.craftable { border-color: var(--success); background: #F0FFF8; }
.recipe-card.crafted { border-color: var(--text-muted); opacity: 0.5; }
.recipe-mini-grid {
  display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px;
  background: #8B6F47; padding: 4px; border-radius: 6px; flex-shrink: 0;
}
.recipe-mini-slot {
  width: 28px; height: 28px; border-radius: 3px;
  background: #A0855C; display: flex; align-items: center; justify-content: center;
  font-size: 0.9rem;
}
.recipe-arrow { color: var(--text-secondary); font-size: 1.2rem; flex-shrink: 0; }
.recipe-result { font-size: 1.4rem; flex-shrink: 0; }
.recipe-info { flex: 1; }
.recipe-name { font-family: var(--font-display); font-weight: 600; font-size: 0.95rem; }
.recipe-needs { font-size: 0.8rem; color: var(--text-secondary); margin-top: 2px; }
.recipe-needs .has { color: var(--success); }
.recipe-needs .need { color: var(--error); }
.recipe-category { margin-bottom: 12px; }
.recipe-category-header {
  font-family: var(--font-display); font-size: 1rem; font-weight: 600;
  color: var(--text); padding: 8px 12px; cursor: pointer;
  background: var(--surface); border-radius: 10px; margin-bottom: 8px;
  transition: all 0.2s; user-select: none;
}
.recipe-category-header:hover { background: #E0E0E8; }
.recipe-category-header.collapsed::after { content: ' ‚ñ∏'; }
.recipe-category-header:not(.collapsed)::after { content: ' ‚ñæ'; }

/* ===== BUILD (integrated into mine) ===== */
.mine-cell.build-placed {
  background: rgba(255,255,255,0.65) !important; border-color: rgba(0,0,0,0.1) !important;
  box-shadow: 0 1px 2px rgba(0,0,0,0.1) !important; cursor: pointer;
  pointer-events: auto !important;
}
.mine-cell.build-placed:hover { transform: scale(1.12); box-shadow: 0 0 8px rgba(255,80,80,0.4) !important; }
.mine-cell.build-player {
  pointer-events: auto !important;
}
.mine-cell.ghost::after {
  content: attr(data-hint); position: absolute; inset: 0;
  display: flex; align-items: center; justify-content: center;
  opacity: 0.3; font-size: inherit; pointer-events: none;
}
.build-info {
  font-size: 0.75rem; color: var(--text-secondary); text-align: center;
  margin-top: 2px; font-family: var(--font-body);
}
.mine-sidebar {
  position: sticky; bottom: 64px; z-index: 5;
  background: #8B6F47; border-radius: 12px 12px 0 0;
  padding: 6px 10px;
  display: flex; flex-wrap: wrap; gap: 4px;
  align-items: center; justify-content: center;
  box-shadow: 0 -2px 10px rgba(0,0,0,0.25), inset 0 2px 6px rgba(0,0,0,0.3);
}
.mine-sidebar-item {
  width: 44px; height: 44px; border-radius: 6px;
  background: #A0855C; border: 2px solid #6B4F37;
  display: flex; align-items: center; justify-content: center;
  cursor: pointer; font-size: 1.1rem;
  transition: all 0.15s; position: relative;
}
.mine-sidebar-item:hover { background: #B8976A; transform: scale(1.08); }
.mine-sidebar-item.selected { border-color: #FFD93D; background: #C4A97D; box-shadow: 0 0 8px rgba(255,217,61,0.5); }
.mine-sidebar-item .count {
  font-size: 0.55rem; font-weight: 700; color: #FFF;
  background: rgba(0,0,0,0.5); border-radius: 4px; padding: 0 3px;
  position: absolute; bottom: 2px; right: 2px; line-height: 1.3;
}
.build-palette {
  display: flex; flex-wrap: wrap; gap: 4px; justify-content: center;
  margin-bottom: 12px; padding: 10px;
  background: #8B6F47; border-radius: 12px;
  box-shadow: inset 0 2px 6px rgba(0,0,0,0.3), 0 3px 10px var(--shadow);
}
.build-palette-item {
  width: 48px; height: 48px; border-radius: 6px;
  background: #A0855C; border: 2px solid #6B4F37;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  cursor: pointer; font-size: 1.2rem; transition: all 0.15s; position: relative;
}
.build-palette-item:hover { background: #B8976A; transform: scale(1.08); }
.build-palette-item.selected { border-color: #FFD93D; background: #C4A97D; box-shadow: 0 0 8px rgba(255,217,61,0.5); }
.build-palette-item .count {
  font-size: 0.55rem; font-weight: 700; color: #FFF;
  background: rgba(0,0,0,0.5); border-radius: 4px; padding: 0 3px;
  position: absolute; bottom: 2px; right: 2px; line-height: 1.3;
}
.build-actions { text-align: center; margin-bottom: 12px; }
.build-actions button {
  padding: 8px 18px; border-radius: 50px; border: none;
  background: linear-gradient(135deg, var(--border), #BDC3C7); color: #2D3436;
  font-family: var(--font-display); font-size: 0.85rem; font-weight: 600;
  cursor: pointer; transition: all 0.2s;
}
.build-actions button:hover { transform: translateY(-2px); background: #E0E0E8; }

/* ===== SETTINGS MODAL ===== */
.modal-overlay {
  display: none;
  position: fixed; inset: 0;
  background: rgba(45, 52, 54, 0.5);
  z-index: 200;
  justify-content: center;
  align-items: center;
}
.modal-overlay.active {
  display: flex;
}
.modal-content {
  background: white;
  border-radius: var(--radius);
  padding: 24px;
  width: 90%;
  max-width: 360px;
  box-shadow: 0 8px 32px rgba(45, 52, 54, 0.2);
  animation: fadeIn 0.3s ease;
}
.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-family: var(--font-display);
  font-size: 1.2rem;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 16px;
}
.modal-close {
  background: none; border: none;
  font-size: 1.3rem; cursor: pointer;
  color: var(--text-muted); transition: color 0.2s;
  padding: 4px 8px; line-height: 1;
}
.modal-close:hover { color: var(--text); }
.settings-btn {
  cursor: pointer; border: none;
  background: rgba(255,255,255,0.9);
  min-width: 36px; min-height: 36px;
  display: flex; align-items: center; justify-content: center;
}
.settings-btn:hover { transform: scale(1.15); }

@media (max-width: 600px) {
  .header { padding: 6px 10px; padding-right: 70px; }
  .header h1 { font-size: 0.95rem; }
  .score-item { padding: 3px 8px; font-size: 0.7rem; }
  .gem-float { top: 6px; right: 10px; font-size: 0.7rem; padding: 3px 8px; }
  .feelings-grid { grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap: 10px; }
  .feeling-card { padding: 14px 8px; }
  .feeling-card .emoji { font-size: 2.2rem; }
  .sight-learn-grid { grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap: 10px; }
  .sight-learn-card { padding: 12px 8px; }
  .sight-learn-card .sl-word { font-size: 1.1rem; }
  .match-game { grid-template-columns: 1fr; }
  .quiz-options { grid-template-columns: 1fr; }
  .nav-tab .nav-label { font-size: 0.55rem; }
  .nav-tab .nav-icon { font-size: 1.1rem; }
  .nav-tab .stamina-hint { display: none; }
  .sentence-display { font-size: 1.2rem; }
  .mountain-scroll-hint { display: block; }
  .mine-cell { width: 38px; height: 38px; font-size: 1.2rem; }
  .mine-cell.tree { font-size: 1.4rem; }
  .mine-cell.animal { font-size: 1.4rem; }
  .encyclopedia-grid { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); }
  .craft-slot { width: 44px; height: 44px; font-size: 1.3rem; }
  .craft-result-slot { width: 52px; height: 52px; font-size: 1.6rem; }
  .craft-inv-item { width: 44px; height: 44px; font-size: 1.1rem; }
  .character-display.small { display: none !important; }
  .equip-slot { min-width: 160px; padding: 6px 10px; }
  .equip-inv-item { width: 40px; height: 40px; font-size: 1.2rem; }
  .modal-content { min-width: auto; width: 90vw; }
}
.mine-cell.mining {
  transform: scale(1.9) translateY(-20px);
  z-index: 10;
  box-shadow: 0 8px 24px rgba(0,0,0,0.35);
  transition: transform 0.15s ease-out, box-shadow 0.15s ease-out;
}
.mine-cell.tree.mining, .mine-cell.animal.mining {
  background: rgba(255,255,255,0.85);
  border-radius: 8px;
  border: 1px solid rgba(0,0,0,0.1);
}
.mine-progress {
  position: absolute; bottom: 0; left: 0; right: 0; height: 7px;
  background: rgba(0,0,0,0.2); border-radius: 0 0 4px 4px;
  overflow: hidden;
}
.mine-progress-fill {
  height: 100%; width: 0%; background: var(--success);
  transition: none;
}
.character-display {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 2px;
  justify-items: center; align-items: center;
  margin: 12px auto; width: fit-content;
}
.char-cell { font-size: 2.8rem; line-height: 1.2; text-align: center; min-width: 2.4em; padding: 4px 2px; border-radius: 10px; }
.char-cell.clickable { cursor: pointer; transition: background 0.15s; }
.char-cell.clickable:hover { background: rgba(108,92,231,0.08); }
.char-cell.clickable:active { background: rgba(108,92,231,0.15); transform: scale(0.95); }
.char-cell.empty-slot { border: 2px dashed var(--border); border-radius: 8px; min-height: 1.2em; }
.char-cell-label { font-size: 0.7rem; color: var(--text-secondary); font-family: var(--font-display); }
.character-display.small { margin: 0; }
.character-display.small .char-cell { font-size: 1.2rem; min-width: 1.6em; padding: 1px; }
.character-display.small .char-cell { font-size: 1.1rem; line-height: 1.2; min-width: 1.5em; }
.character-display.small .char-cell-label { display: none; }
.character-display.small .character-row { font-size: 1.2rem; }

.equip-area { text-align: center; }
.equip-slots {
  display: flex; flex-direction: column; align-items: center;
  gap: 8px; margin: 16px 0;
}
.equip-slot {
  display: flex; align-items: center; gap: 12px;
  background: white; padding: 8px 16px; border-radius: 12px;
  box-shadow: var(--shadow-sm); min-width: 200px;
  cursor: pointer; transition: all 0.2s;
}
.equip-slot:hover { transform: scale(1.02); box-shadow: var(--shadow-md); }
.equip-slot-label { font-size: 0.8rem; color: var(--text-secondary); font-family: var(--font-display); min-width: 50px; }
.equip-slot-item { font-size: 1.3rem; }
.equip-slot-name { font-family: var(--font-display); font-size: 0.9rem; }
.equip-slot-empty { color: var(--text-muted); font-style: italic; }

.equip-inventory {
  display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;
  margin-top: 16px; padding: 12px;
  background: var(--surface); border-radius: 12px;
}
.equip-inv-item {
  width: 48px; height: 48px;
  display: flex; align-items: center; justify-content: center;
  font-size: 1.5rem; background: white; border-radius: 8px;
  cursor: pointer; transition: all 0.2s; position: relative;
  box-shadow: var(--shadow-sm);
}
.equip-inv-item:hover { transform: scale(1.1); }
/* Furnace */
.furnace-ui {
  display: flex; align-items: center; justify-content: center; gap: 8px;
  padding: 16px; background: var(--card-bg); border-radius: var(--radius);
  box-shadow: var(--shadow-md); margin-bottom: 12px; flex-wrap: wrap;
}
.furnace-slot-section { text-align: center; }
.furnace-slot-label {
  font-family: var(--font-body); font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 4px;
}
.furnace-slot {
  width: 56px; height: 56px; background: var(--surface); border-radius: 12px;
  display: flex; align-items: center; justify-content: center;
  font-size: 1.8rem; border: 2px dashed var(--border);
}
.furnace-symbol {
  font-size: 1.5rem; color: var(--text-secondary); padding: 0 4px;
}
.furnace-status {
  text-align: center; font-family: var(--font-body); font-size: 0.9rem;
  color: #2D3436; min-height: 1.4em; margin: 8px 0;
}
.furnace-recipes {
  background: var(--card-bg); border-radius: var(--radius); padding: 12px;
  box-shadow: var(--shadow); margin-top: 12px;
}
.furnace-recipes-title {
  font-family: var(--font-display); font-weight: 600; font-size: 1rem;
  margin-bottom: 8px; color: #2D3436;
}
.furnace-recipe-row {
  display: flex; align-items: center; gap: 8px; padding: 8px 12px;
  border-radius: 10px; font-family: var(--font-body); font-size: 0.85rem;
  color: var(--text-muted); transition: all 0.2s;
}
.furnace-recipe-row.available {
  color: #2D3436; cursor: pointer; background: rgba(0,184,148,0.06);
}
.furnace-recipe-row.available:hover { background: rgba(0,184,148,0.15); }
.furnace-recipe-row.selected {
  background: rgba(0,184,148,0.2); outline: 2px solid var(--success); outline-offset: -2px;
}
.furnace-eat-section {
  background: var(--card-bg); border-radius: var(--radius); padding: 12px;
  box-shadow: var(--shadow); margin-top: 12px;
}
.furnace-eat-row {
  display: flex; align-items: center; justify-content: space-between;
  padding: 8px 0; font-family: var(--font-body);
}
</style>
</head>
<body>

<div class="header" id="appHeader">
  <h1>Feelings Fun! üé≠ <span style="font-size:0.45em;font-weight:400;color:#636E72;vertical-align:middle;">Week 1 ¬∑ v3.7.0</span></h1>
  <div class="score-bar">
    <div class="score-item" id="starBar"><span>‚≠ê</span> <span id="stars">0</span></div>
    <div class="score-item" id="streakBar"><span>üî•</span> <span id="streak">0</span></div>
    <button class="score-item settings-btn" id="settingsBtn">‚öôÔ∏è</button>
  </div>
</div>
<div class="gem-float" id="gemBar"><span>‚ö°</span> <span id="gems">0</span></div>
<nav class="bottom-nav">
  <div class="bottom-nav-inner">
    <button class="nav-tab active" data-tab="learn"><span class="nav-icon">üìñ</span><span class="nav-label">Learn</span></button>
    <button class="nav-tab" data-tab="read"><span class="nav-icon">üìó</span><span class="nav-label">Read</span></button>
    <button class="nav-tab" data-tab="sight"><span class="nav-icon">üëÄ</span><span class="nav-label">Sight</span><span class="stamina-hint">‚ö°</span></button>
    <button class="nav-tab" data-tab="match"><span class="nav-icon">üéØ</span><span class="nav-label">Match</span><span class="stamina-hint">‚ö°</span></button>
    <button class="nav-tab" data-tab="quiz"><span class="nav-icon">üß†</span><span class="nav-label">Quiz</span><span class="stamina-hint">‚ö°</span></button>
    <button class="nav-tab" data-tab="mine"><span class="nav-icon">‚õèÔ∏è</span><span class="nav-label">ÊåñÁ§¶</span></button>
    <button class="nav-tab" data-tab="craft"><span class="nav-icon">üî®</span><span class="nav-label">ÂêàÊàê</span></button>
    <button class="nav-tab" data-tab="furnace"><span class="nav-icon">üî•</span><span class="nav-label">ÁÜîÁàê</span></button>
    <button class="nav-tab" data-tab="equip"><span class="nav-icon">üë§</span><span class="nav-label">Ë£ùÂÇô</span></button>
    <button class="nav-tab" data-tab="encyclopedia"><span class="nav-icon">üì¶</span><span class="nav-label">ÂúñÈëë</span></button>
  </div>
</nav>

<div class="app">
  <div class="nav-spacer"></div>

  <div id="learn" class="section active">
    <h3 class="learn-section-title">üòä Feelings ÊÉÖÁ∑í</h3>
    <div class="feelings-grid" id="feelingsGrid"></div>
    <div class="sentence-practice">
      <h3>üó£Ô∏è Practice Sentences ÈÄ†Âè•Á∑¥Áøí</h3>
      <div class="sentence-display" id="sentenceDisplay">I feel <span class="hl">happy</span>. üòä</div>
      <div class="btn-row">
        <button class="speak-btn primary" id="speakSentenceBtn">üîä Listen ËÅΩÁôºÈü≥</button>
        <button class="speak-btn secondary" id="randomSentenceBtn">üé≤ Random Èö®Ê©ü</button>
      </div>
      <div class="feeling-chips" id="feelingChips"></div>
    </div>
    <h3 class="learn-section-title" style="margin-top:24px;">üìñ Sight Words Â∏∏Ë¶ãÂ≠ó</h3>
    <div class="sight-learn-grid" id="sightLearnGrid"></div>
  </div>

  <div id="read" class="section">
    <div class="read-header">
      <h3>üìó Sentence Reading ÊúóËÆÄÁ∑¥Áøí</h3>
      <p>ÈªûÂç°ÁâáÊúóËÆÄÔºåÊØèÂè•Âî∏ 3 Ê¨°Â∞±ÈÅéÈóúÔºÅ</p>
      <div class="read-unit-toggle">
        <button class="read-unit-btn active" data-unit="sentences">üìñ Unit 1 Sentences</button>
        <button class="read-unit-btn" data-unit="dialogues">üí¨ Q&amp;A Dialogues</button>
      </div>
      <div class="read-progress-bar"><div class="read-progress-fill" id="readProgressFill" style="width:0%"></div></div>
    </div>
    <div class="sentence-cards" id="sentenceCards"></div>
  </div>

  <div id="match" class="section">
    <div class="match-feedback" id="matchFeedback">Èªû‰∏ÄÂÄãÂñÆÂ≠óÔºåÂÜçÈªûÈÖçÂ∞çÁöÑË°®ÊÉÖÔºÅ üéØ</div>
    <div class="match-game" id="matchGame">
      <div class="match-column" id="matchWords"><h3>Words ÂñÆÂ≠ó</h3></div>
      <div class="match-column" id="matchEmojis"><h3>Emoji Ë°®ÊÉÖ</h3></div>
    </div>
    <button class="reset-btn" id="resetMatch">üîÑ New Round ÂÜç‰æÜ‰∏ÄÊ¨°</button>
  </div>

  <div id="quiz" class="section">
    <div class="quiz-container" id="quizContainer"></div>
  </div>

  <div id="sight" class="section">
    <div class="sight-words-area" id="sightWordsArea"></div>
  </div>

  <div id="mine" class="section">
    <div id="mineArea"></div>
  </div>

  <div id="craft" class="section">
    <div id="craftArea"></div>
  </div>

  <div id="furnace" class="section">
    <div id="furnaceArea"></div>
  </div>

  <div id="equip" class="section">
    <div id="equipArea"></div>
  </div>

  <div id="encyclopedia" class="section">
    <div id="encyclopediaArea"></div>
  </div>

  <footer class="app-footer">
    ÊÑüË¨ù iEA ÁæéË™ûÂ≠∏Èô¢ÁöÑÂÑ™ËâØÊïôÊùêÔºåÊú¨Á´ôÁÇ∫Â≠∏ÁîüÂÆ∂Èï∑ÂèÉËÄÉÊïôÊùêÂÖßÂÆπËá™Ë£ΩÁöÑËºîÂä©Â≠∏ÁøíÂ∑•ÂÖ∑„ÄÇ
  </footer>
</div>

<div class="confetti-box" id="confettiBox"></div>

<div class="modal-overlay" id="settingsModal">
  <div class="modal-content">
    <div class="modal-header">
      <span>‚öôÔ∏è Ë®≠ÂÆö</span>
      <button class="modal-close" id="settingsClose">‚úï</button>
    </div>
    <div class="settings-section">
      <div class="settings-label">üîä Ë™ûÈÄü Speed</div>
      <div class="speed-toggle">
        <button class="speed-btn" data-speed="slower" id="speedSlower">üêå Slower</button>
        <button class="speed-btn" data-speed="slow" id="speedSlow">üê¢ Slow</button>
        <button class="speed-btn active" data-speed="normal" id="speedNormal">üêá Normal</button>
      </div>
    </div>
    <div class="settings-section">
      <div class="settings-label">üîá ÈùúÈü≥ Mute</div>
      <div class="speed-toggle">
        <button class="speed-btn active" id="muteOff">üîä Èñã</button>
        <button class="speed-btn" id="muteOn">üîá Èóú</button>
      </div>
    </div>
    <div id="engineStatus" style="text-align:center;font-size:0.8rem;color:#B2BEC3;margin-top:12px;font-family:'Nunito',sans-serif;">üîç ÂÅµÊ∏¨‰∏≠...</div>
    <div style="text-align:center;font-size:0.7rem;color:#B2BEC3;margin-top:8px;font-family:'Nunito',sans-serif;">v3.7.0</div>
  </div>
</div>

<div class="modal-overlay" id="learnGateModal">
  <div class="modal-content" id="learnGateContent"></div>
</div>

<script>
// ===== CHEAT =====
const isCheat = new URLSearchParams(window.location.search).get('cheat') === '1';

// ===== DATA =====
const feelings = [
  { word: 'happy',   zh: 'ÈñãÂøÉÁöÑ', emoji: 'üòä', color: '#FFD93D' },
  { word: 'sad',     zh: 'Èõ£ÈÅéÁöÑ', emoji: 'üò¢', color: '#74B9FF' },
  { word: 'angry',   zh: 'ÊÜ§ÊÄíÁöÑ', emoji: 'üò†', color: '#FF6B6B' },
  { word: 'excited', zh: 'ËààÂ•ÆÁöÑ', emoji: 'ü§©', color: '#FF85CA' },
  { word: 'silly',   zh: 'ÂèØÁ¨ëÁöÑ', emoji: 'ü§™', color: '#A29BFE' },
  { word: 'tired',   zh: 'Á¥ØÁöÑ',   emoji: 'üò¥', color: '#B2BEC3' },
  { word: 'scared',  zh: 'ÂÆ≥ÊÄïÁöÑ', emoji: 'üò®', color: '#81ECEC' },
  { word: 'bored',   zh: 'ÁÑ°ËÅäÁöÑ', emoji: 'üòë', color: '#FFEAA7' },
  { word: 'sick',    zh: '‰∏çËàíÊúçÁöÑ', emoji: 'ü§í', color: '#55EFC4' },
  { word: 'proud',   zh: 'È©ïÂÇ≤ÁöÑ', emoji: 'üòé', color: '#FD79A8' },
  { word: 'brave',   zh: 'ÂãáÊï¢ÁöÑ', emoji: 'üí™', color: '#E17055' },
  { word: 'mad',     zh: 'ÁîüÊ∞£ÁöÑ', emoji: 'üò§', color: '#D63031' },
];

const sightWords = [
  { word: 'door',  zh: 'ÈñÄ', sentence: 'Open the door.' },
  { word: 'down',  zh: '‰∏ãÈù¢', sentence: 'Sit down please.' },
  { word: 'dress', zh: 'Ê¥ãË£ù', sentence: 'I like your dress.' },
  { word: 'duck',  zh: 'È¥®Â≠ê', sentence: 'Look at the duck!' },
  { word: 'each',  zh: 'ÊØè‰∏ÄÂÄã', sentence: 'Give one to each child.' },
  { word: 'egg',   zh: 'Ëõã', sentence: 'I eat an egg.' },
  { word: 'every',  zh: 'ÊØèÂÄã', sentence: 'Every day is special.' },
  { word: 'over',   zh: 'Âú®‚Ä¶‰∏äÊñπ', sentence: 'The bird flew over the house.' },
  { word: 'new',    zh: 'Êñ∞ÁöÑ', sentence: 'I got a new book.' },
  { word: 'sound',  zh: 'ËÅ≤Èü≥', sentence: 'What is that sound?' },
  { word: 'take',   zh: 'Êãø', sentence: 'Please take one.' },
  { word: 'only',   zh: 'Âè™Êúâ', sentence: 'I have only one.' },
  { word: 'little', zh: 'Â∞èÁöÑ', sentence: 'The little cat is cute.' },
  { word: 'work',   zh: 'Â∑•‰Ωú', sentence: 'We work together.' },
  { word: 'know',   zh: 'Áü•ÈÅì', sentence: 'I know the answer.' },
  { word: 'place',  zh: 'Âú∞Êñπ', sentence: 'This is a nice place.' },
  { word: 'years',  zh: 'Âπ¥', sentence: 'I am six years old.' },
];
const sightColors = ['#FF6B6B','#A29BFE','#FFD93D','#00B894','#FF85CA','#74B9FF','#E17055'];

// ===== SENTENCE READING DATA =====
const sentences = [
  { en: 'My teacher tells us interesting stories every day.', zh: 'ÊàëÁöÑËÄÅÂ∏´ÊØèÂ§©ÈÉΩÊúÉË∑üÊàëÂÄëÂàÜ‰∫´ÊúâË∂£ÁöÑÊïÖ‰∫ã„ÄÇ' },
  { en: 'I get very excited.', zh: 'ÊàëÁ∏ΩÊòØÊÑüÂà∞ÈùûÂ∏∏ËààÂ•Æ„ÄÇ' },
  { en: 'My friends think they are so silly.', zh: 'Âè™ÊòØÊàëÁöÑÊúãÂèãÂÄëË¶∫ÂæóÈÇ£‰∫õÊïÖ‰∫ãÊúâ‰∫õÂèØÁ¨ë„ÄÇ' },
  { en: 'One story was about a duck with a dress that lays eggs behind a door because she is very scared of the angry goat in the barn.', zh: 'ÊúâÂÄãÊïÖ‰∫ãÊòØÈóúÊñº‰∏ÄÈöªÁ©øËëóË£ôÂ≠êÁöÑÈ¥®Â≠ê„ÄÇÂõ†ÁÇ∫Á©ÄÂÄâË£°ÊúâÈöªÊÑõÁîüÊ∞£ÁöÑÂ±±ÁæäÔºåÈ¥®Â≠êÂæàÊÄïÈÇ£ÈöªÂ±±ÁæäÔºåÂõ†Ê≠§È¥®Â≠êÂè™ËÉΩË∫≤Âú®ÈñÄÂæåÈù¢‰∏ãËõã„ÄÇ' },
  { en: 'I feel very sad for the duck.', zh: 'ÊàëÁÇ∫ÈÇ£ÈöªÈ¥®Â≠êÊÑüÂà∞Èõ£ÈÅé„ÄÇ' },
  { en: 'Joe loves the story about the brave bear that got lost in the forest.', zh: 'ÊàëÁöÑÊúãÂèãJoeÂñúÊ≠°ÁöÑÊïÖ‰∫ãÊòØÈóúÊñº‰∏ÄÈöªÂú®Ê£ÆÊûó‰∏≠Ëø∑Ë∑Ø‰ΩÜÂçªÈùûÂ∏∏ÂãáÊï¢ÁöÑÁÜä„ÄÇ' },
  { en: 'He is so proud of the bear for never getting scared and helping other sick animals on his way.', zh: 'ÈÇ£‰∏ÄÈöªÁÜä‰∏çÊõæÊÑüÂà∞ÂÆ≥ÊÄïËÄå‰∏î‰∏ÄË∑Ø‰∏äÂπ´Âä©ÂÖ∂‰ªñÁîüÁóÖÁöÑÂãïÁâ©Ôºå‰ªñÁÇ∫ÈÇ£ÈöªÁÜäÊÑüÂà∞È©ïÂÇ≤„ÄÇ' },
  { en: 'Some of my classmates get very bored and feel sleepy in class if my teacher talks about the history of toys.', zh: 'ËÄåÁï∂ËÄÅÂ∏´Âú®Ë™≤Â†Ç‰∏äË´áÂà∞ÈóúÊñºÁé©ÂÖ∑Ê≠∑Âè≤ÁöÑÊôÇÂÄôÔºåÈÉ®ÂàÜÂêåÂ≠∏Âè™ÊúÉÊÑüÂà∞ÁÑ°ËÅä‰∏îÊÉ≥Áù°Ë¶∫„ÄÇ' },
  { en: 'They just want to play with them.', zh: '‰ªñÂÄëÂè™ÊÉ≥Áé©Áé©ÂÖ∑„ÄÇ' },
  { en: 'My teacher makes me feel loved and her stories make me feel so happy!', zh: 'ËÄÅÂ∏´Á∏ΩÊòØËÆìÊàëÊÑüÂèó‰ªñÂ∞çÂ≠∏ÁîüÂÄëÁöÑÊÑõÔºåËÄå‰∏î‰πüËÆìÊàëÊÑüÂà∞ÈñãÂøÉ„ÄÇ' },
];
let sentenceReadCount = new Array(sentences.length).fill(0);
const SENTENCE_GOAL = 3;

const dialogues = [
  { q: 'What are those?', qzh: 'ÈÇ£‰∫õÊòØ‰ªÄÈ∫ºÔºü', a: 'They are my mom\'s shoes.', azh: 'ÂÆÉÂÄëÊòØÊàëÂ™ΩÂ™ΩÁöÑÈûãÂ≠ê„ÄÇ' },
  { q: 'Are these your pants?', qzh: 'ÈÄôÊòØ‰Ω†ÁöÑÈï∑Ë§≤ÂóéÔºü', a: 'Yes, they are.', azh: 'ÊòØÔºåÂÆÉÂÄëÊòØ„ÄÇ' },
  { q: 'Are those her books?', qzh: 'ÈÇ£‰∫õÊòØÂ•πÁöÑÊõ∏ÂóéÔºü', a: 'No, they aren\'t. They are mine.', azh: '‰∏çÔºå‰∏çÊòØ„ÄÇÂÆÉÂÄëÊòØÊàëÁöÑ„ÄÇ' },
  { q: 'What color do you like?', qzh: '‰Ω†ÂñúÊ≠°‰ªÄÈ∫ºÈ°èËâ≤Ôºü', a: 'I like blue.', azh: 'ÊàëÂñúÊ≠°ËóçËâ≤„ÄÇ' },
  { q: 'What color does your mom like?', qzh: '‰Ω†Â™ΩÂ™ΩÂñúÊ≠°‰ªÄÈ∫ºÈ°èËâ≤Ôºü', a: 'She likes pink.', azh: 'Â•πÂñúÊ≠°Á≤âÁ¥ÖËâ≤„ÄÇ' },
  { q: 'Do you like carrots?', qzh: '‰Ω†ÂñúÊ≠°ËÉ°ËòøËîîÂóéÔºü', a: 'Yes, I do. But my sister doesn\'t.', azh: 'ÊòØÔºåÊàëÂñúÊ≠°„ÄÇ‰ΩÜÊàëÂ¶πÂ¶π‰∏çÂñúÊ≠°„ÄÇ' },
  { q: 'What can she do?', qzh: 'Â•πÊúÉÂÅö‰ªÄÈ∫ºÔºü', a: 'She can ride horses.', azh: 'Â•πÊúÉÈ®éÈ¶¨„ÄÇ' },
  { q: 'Can your dad speak English?', qzh: '‰Ω†Áà∏Áà∏ÊúÉË™™Ëã±ÊñáÂóéÔºü', a: 'No, he can\'t. But he can speak Japanese.', azh: '‰∏çÔºå‰ªñ‰∏çÊúÉ„ÄÇ‰ΩÜÊòØ‰ªñÊúÉË™™Êó•Êñá„ÄÇ' },
  { q: 'Can monkeys climb trees?', qzh: 'Áå¥Â≠êËÉΩÁà¨Ê®πÂóéÔºü', a: 'Yes, they can.', azh: 'ÊúÉÔºåÁâ†ÂÄëÊúÉ„ÄÇ' },
];
let dialogueReadCount = new Array(dialogues.length).fill(0);

// ===== MINING DATA =====
const blocks = [
  { id: 'dirt',     name: 'Ê≥•Âúü',   emoji: 'üü´', tier: 1, weight: 40 },
  { id: 'wood',     name: 'Êú®È†≠',   emoji: 'ü™µ', tier: 1, weight: 35 },
  { id: 'stick',    name: 'Êú®Ê£ç',   emoji: 'ü•¢', tier: 1, weight: 10 },
  { id: 'sand',     name: 'Ê≤ôÂ≠ê',   emoji: 'üèñÔ∏è', tier: 1, weight: 20 },
  { id: 'gravel',   name: 'Á§´Áü≥',   emoji: '‚ö™', tier: 1, weight: 15 },
  { id: 'clay',     name: 'ÈªèÂúü',   emoji: 'üß±', tier: 1, weight: 8 },
  { id: 'stone',    name: 'Áü≥È†≠',   emoji: 'ü™®', tier: 2, weight: 30 },
  { id: 'coal',     name: 'ÁÖ§ÁÇ≠',   emoji: '‚¨õ', tier: 2, weight: 25 },
  { id: 'iron',     name: 'ÈêµÁ§¶',   emoji: '‚¨ú', tier: 3, weight: 18 },
  { id: 'copper',   name: 'ÈäÖÁ§¶',   emoji: 'üüß', tier: 3, weight: 15 },
  { id: 'redstone', name: 'Á¥ÖÁü≥',   emoji: 'üî¥', tier: 3, weight: 10 },
  { id: 'lapis',    name: 'ÈùíÈáëÁü≥', emoji: 'üîµ', tier: 3, weight: 8 },
  { id: 'gold',     name: 'ÈáëÁ§¶',   emoji: 'üü°', tier: 4, weight: 8 },
  { id: 'emerald',  name: 'Á∂†ÂØ∂Áü≥', emoji: 'üíö', tier: 4, weight: 5 },
  { id: 'diamond',  name: 'ÈëΩÁü≥',   emoji: 'üíé', tier: 5, weight: 3 },
  { id: 'amethyst', name: 'Á¥´Ê∞¥Êô∂', emoji: 'üü£', tier: 5, weight: 2 },
  { id: 'obsidian', name: 'ÈªëÊõúÁü≥', emoji: 'üñ§', tier: 5, weight: 1 },
  // Animal drops (tier 0, weight 0 = drop-only)
  { id: 'leather',      name: 'ÁöÆÈù©',   emoji: 'üü§', tier: 0, weight: 0 },
  { id: 'pork',         name: 'Ë±¨Êéí',   emoji: 'üçñ', tier: 0, weight: 0 },
  { id: 'chicken_meat', name: 'ÁîüÈõûËÇâ', emoji: 'ü•©', tier: 0, weight: 0 },
  { id: 'feather',      name: 'ÁæΩÊØõ',   emoji: 'ü™∂', tier: 0, weight: 0 },
  { id: 'wool',         name: 'ÁæäÊØõ',   emoji: 'üß∂', tier: 0, weight: 0 },
  // Hostile mob drops (tier 0, weight 0 = drop-only)
  { id: 'rotten_flesh', name: 'ËÖêËÇâ',   emoji: 'ü•ì', tier: 0, weight: 0 },
  { id: 'bone',         name: 'È™®È†≠',   emoji: 'ü¶¥', tier: 0, weight: 0 },
  { id: 'gunpowder',    name: 'ÁÅ´Ëó•',   emoji: 'üí•', tier: 0, weight: 0 },
  { id: 'string',       name: 'ËúòËõõÁµ≤', emoji: 'üï∏Ô∏è', tier: 0, weight: 0 },
  { id: 'ender_pearl',  name: 'ÁµÇÁïåÁèçÁè†', emoji: 'üü¢', tier: 0, weight: 0 },
  // Smelted / cooked items (tier 0, weight 0 = furnace output only)
  { id: 'iron_ingot',   name: 'ÈêµÈå†',   emoji: 'üî©', tier: 0, weight: 0 },
  { id: 'gold_ingot',   name: 'ÈáëÈå†',   emoji: 'ü™ô', tier: 0, weight: 0 },
  { id: 'copper_ingot', name: 'ÈäÖÈå†',   emoji: 'üü†', tier: 0, weight: 0 },
  { id: 'cooked_pork',    name: 'ÁÉ§Ë±¨Êéí', emoji: 'ü•©', tier: 0, weight: 0 },
  { id: 'cooked_chicken', name: 'ÁÉ§ÈõûËÇâ', emoji: 'üçó', tier: 0, weight: 0 },
  // Smelted material items
  { id: 'glass',   name: 'ÁéªÁíÉ',   emoji: 'ü™ü', tier: 0, weight: 0 },
  { id: 'brick',   name: 'Á£öÂ°ä',   emoji: 'üß±', tier: 0, weight: 0 },
  // Craftable utility items
  { id: 'furnace', name: 'ÁÜîÁàê', emoji: 'üî•', tier: 0, weight: 0 },
  { id: 'bed',     name: 'Â∫ä',   emoji: 'üõèÔ∏è', tier: 0, weight: 0 },
  { id: 'torch',   name: 'ÁÅ´Êää', emoji: 'üïØÔ∏è', tier: 0, weight: 0 },
  { id: 'ladder',  name: 'Ê¢ØÂ≠ê', emoji: 'ü™ú', tier: 0, weight: 0 },
  { id: 'chest',   name: 'ÁÆ±Â≠ê', emoji: 'üì¶', tier: 0, weight: 0 },
  { id: 'door',    name: 'ÈñÄ',   emoji: 'üö™', tier: 0, weight: 0 },
  { id: 'fence',   name: 'ÊüµÊ¨Ñ', emoji: 'üèóÔ∏è', tier: 0, weight: 0 },
  { id: 'bookshelf', name: 'Êõ∏Êû∂', emoji: 'üìö', tier: 0, weight: 0 },
  { id: 'painting', name: 'Áï´',   emoji: 'üñºÔ∏è', tier: 0, weight: 0 },
  { id: 'tnt',     name: 'TNT',  emoji: 'üß®', tier: 0, weight: 0 },
  { id: 'bow',     name: 'Âºì',   emoji: 'üèπ', tier: 0, weight: 0 },
  { id: 'arrow',   name: 'ÁÆ≠',   emoji: '‚û°Ô∏è', tier: 0, weight: 0 },
  { id: 'boat',    name: 'Ëàπ',   emoji: 'üõ∂', tier: 0, weight: 0 },
  { id: 'bucket',  name: 'Ê°∂',   emoji: 'ü™£', tier: 0, weight: 0 },
  { id: 'compass', name: 'ÊåáÂçóÈáù', emoji: 'üß≠', tier: 0, weight: 0 },
  { id: 'clock',   name: 'ÊôÇÈêò', emoji: 'üïê', tier: 0, weight: 0 },
  // Tools (tier 0, weight 0 = never mined, only crafted)
  { id: 'wood_pick',    name: 'Êú®Èé¨',   emoji: '‚õèÔ∏è', tier: 0, weight: 0 },
  { id: 'stone_pick',   name: 'Áü≥Èé¨',   emoji: '‚õèÔ∏è', tier: 0, weight: 0 },
  { id: 'iron_pick',    name: 'ÈêµÈé¨',   emoji: '‚õèÔ∏è', tier: 0, weight: 0 },
  { id: 'gold_pick',    name: 'ÈáëÈé¨',   emoji: 'üî±', tier: 0, weight: 0 },
  { id: 'diamond_pick', name: 'ÈëΩÁü≥Èé¨', emoji: '‚õèÔ∏è', tier: 0, weight: 0 },
  { id: 'wood_axe',     name: 'Êú®Êñß',   emoji: 'ü™ì', tier: 0, weight: 0 },
  { id: 'stone_axe',    name: 'Áü≥Êñß',   emoji: 'ü™ì', tier: 0, weight: 0 },
  { id: 'iron_axe',     name: 'ÈêµÊñß',   emoji: 'ü™ì', tier: 0, weight: 0 },
  { id: 'gold_axe',     name: 'ÈáëÊñß',   emoji: 'ü™ì', tier: 0, weight: 0 },
  { id: 'diamond_axe',  name: 'ÈëΩÁü≥Êñß', emoji: 'ü™ì', tier: 0, weight: 0 },
  { id: 'wood_sword',    name: 'Êú®Âäç',   emoji: 'üó°Ô∏è', tier: 0, weight: 0 },
  { id: 'stone_sword',   name: 'Áü≥Âäç',   emoji: 'üó°Ô∏è', tier: 0, weight: 0 },
  { id: 'iron_sword',    name: 'ÈêµÂäç',   emoji: 'üó°Ô∏è', tier: 0, weight: 0 },
  { id: 'gold_sword',    name: 'ÈáëÂäç',   emoji: 'üó°Ô∏è', tier: 0, weight: 0 },
  { id: 'diamond_sword', name: 'ÈëΩÁü≥Âäç', emoji: 'üó°Ô∏è', tier: 0, weight: 0 },
  // Armor items (tier 0, weight 0)
  { id: 'leather_helmet',  name: 'ÁöÆÈù©È†≠Áõî', emoji: 'ü™ñ', tier: 0, weight: 0 },
  { id: 'leather_chest',   name: 'ÁöÆÈù©ÁõîÁî≤', emoji: 'ü¶∫', tier: 0, weight: 0 },
  { id: 'leather_legs',    name: 'ÁöÆÈù©Ë§≤Â≠ê', emoji: 'üëñ', tier: 0, weight: 0 },
  { id: 'leather_boots',   name: 'ÁöÆÈù©ÈûãÂ≠ê', emoji: 'üë¢', tier: 0, weight: 0 },
  { id: 'iron_helmet',     name: 'ÈêµÈ†≠Áõî',   emoji: 'ü™ñ', tier: 0, weight: 0 },
  { id: 'iron_chest',      name: 'ÈêµÁõîÁî≤',   emoji: 'ü¶∫', tier: 0, weight: 0 },
  { id: 'iron_legs',       name: 'ÈêµË§≤Â≠ê',   emoji: 'üëñ', tier: 0, weight: 0 },
  { id: 'iron_boots',      name: 'ÈêµÈûãÂ≠ê',   emoji: 'üë¢', tier: 0, weight: 0 },
  { id: 'gold_helmet',     name: 'ÈáëÈ†≠Áõî',   emoji: 'ü™ñ', tier: 0, weight: 0 },
  { id: 'gold_chest',      name: 'ÈáëÁõîÁî≤',   emoji: 'ü¶∫', tier: 0, weight: 0 },
  { id: 'gold_legs',       name: 'ÈáëË§≤Â≠ê',   emoji: 'üëñ', tier: 0, weight: 0 },
  { id: 'gold_boots',      name: 'ÈáëÈûãÂ≠ê',   emoji: 'üë¢', tier: 0, weight: 0 },
  { id: 'diamond_helmet',  name: 'ÈëΩÁü≥È†≠Áõî', emoji: 'ü™ñ', tier: 0, weight: 0 },
  { id: 'diamond_chest',   name: 'ÈëΩÁü≥ÁõîÁî≤', emoji: 'ü¶∫', tier: 0, weight: 0 },
  { id: 'diamond_legs',    name: 'ÈëΩÁü≥Ë§≤Â≠ê', emoji: 'üëñ', tier: 0, weight: 0 },
  { id: 'diamond_boots',   name: 'ÈëΩÁü≥ÈûãÂ≠ê', emoji: 'üë¢', tier: 0, weight: 0 },
];

const pickaxes = [
  { id: 'hands',        name: 'Êâã',     emoji: '‚úã', maxTier: 0, durability: Infinity, recipe: null, pattern: null },
  { id: 'wood_pick',    name: 'Êú®Èé¨',   emoji: '‚õèÔ∏è', maxTier: 2, durability: 15,
    recipe: { wood: 3, stick: 2 },
    pattern: ['wood','wood','wood', null,'stick',null, null,'stick',null] },
  { id: 'stone_pick',   name: 'Áü≥Èé¨',   emoji: '‚õèÔ∏è', maxTier: 3, durability: 30,
    recipe: { stick: 2, stone: 3 },
    pattern: ['stone','stone','stone', null,'stick',null, null,'stick',null] },
  { id: 'iron_pick',    name: 'ÈêµÈé¨',   emoji: '‚õèÔ∏è', maxTier: 5, durability: 60,
    recipe: { stick: 2, iron_ingot: 3 },
    pattern: ['iron_ingot','iron_ingot','iron_ingot', null,'stick',null, null,'stick',null] },
  { id: 'gold_pick',    name: 'ÈáëÈé¨',   emoji: 'üî±', maxTier: 4, durability: 25,
    recipe: { stick: 2, gold_ingot: 3 },
    pattern: ['gold_ingot','gold_ingot','gold_ingot', null,'stick',null, null,'stick',null] },
  { id: 'diamond_pick', name: 'ÈëΩÁü≥Èé¨', emoji: '‚õèÔ∏è', maxTier: 5, durability: 150,
    recipe: { stick: 2, diamond: 3 },
    pattern: ['diamond','diamond','diamond', null,'stick',null, null,'stick',null] },
];

// Axe recipes (XX. / XS. / .S.)
const axes = [
  { id: 'wood_axe',    name: 'Êú®Êñß',   emoji: 'ü™ì', woodBonus: 2, durability: 15,
    recipe: { wood: 3, stick: 2 },
    pattern: ['wood','wood',null, 'wood','stick',null, null,'stick',null] },
  { id: 'stone_axe',   name: 'Áü≥Êñß',   emoji: 'ü™ì', woodBonus: 2, durability: 30,
    recipe: { stick: 2, stone: 3 },
    pattern: ['stone','stone',null, 'stone','stick',null, null,'stick',null] },
  { id: 'iron_axe',    name: 'ÈêµÊñß',   emoji: 'ü™ì', woodBonus: 3, durability: 60,
    recipe: { stick: 2, iron_ingot: 3 },
    pattern: ['iron_ingot','iron_ingot',null, 'iron_ingot','stick',null, null,'stick',null] },
  { id: 'gold_axe',    name: 'ÈáëÊñß',   emoji: 'ü™ì', woodBonus: 3, durability: 25,
    recipe: { stick: 2, gold_ingot: 3 },
    pattern: ['gold_ingot','gold_ingot',null, 'gold_ingot','stick',null, null,'stick',null] },
  { id: 'diamond_axe', name: 'ÈëΩÁü≥Êñß', emoji: 'ü™ì', woodBonus: 4, durability: 150,
    recipe: { stick: 2, diamond: 3 },
    pattern: ['diamond','diamond',null, 'diamond','stick',null, null,'stick',null] },
];

const animals = [
  { id: 'cow',     name: 'Áâõ',  emoji: 'üêÑ', drops: [{ id: 'leather', min: 1, max: 2 }] },
  { id: 'pig',     name: 'Ë±¨',  emoji: 'üê∑', drops: [{ id: 'pork', min: 1, max: 1 }] },
  { id: 'chicken', name: 'Èõû',  emoji: 'üêî', drops: [{ id: 'chicken_meat', min: 1, max: 1 }, { id: 'feather', min: 1, max: 1 }] },
  { id: 'sheep',   name: 'Áæä',  emoji: 'üêë', drops: [{ id: 'wool', min: 1, max: 2 }] },
];

const hostileMobs = [
  { id: 'zombie',   name: 'ÊÆ≠Â±ç',   emoji: 'üßü', hostile: true, drops: [{ id: 'rotten_flesh', min: 1, max: 2 }] },
  { id: 'skeleton', name: 'È™∑È´è',   emoji: 'üíÄ', hostile: true, drops: [{ id: 'bone', min: 1, max: 2 }] },
  { id: 'creeper',  name: 'Ëã¶ÂäõÊÄï', emoji: 'üëæ', hostile: true, drops: [{ id: 'gunpowder', min: 1, max: 2 }] },
  { id: 'spider',   name: 'ËúòËõõ',   emoji: 'üï∑Ô∏è', hostile: true, drops: [{ id: 'string', min: 1, max: 2 }] },
  { id: 'enderman', name: 'Enderman', emoji: 'üë§', hostile: true, drops: [{ id: 'ender_pearl', min: 0, max: 1 }] },
];

const swords = [
  { id: 'hands',          name: 'Êâã',     emoji: '‚úã', holdTime: 2500, durability: Infinity, recipe: null, pattern: null },
  { id: 'wood_sword',    name: 'Êú®Âäç',   emoji: 'üó°Ô∏è', holdTime: 1500, durability: 15,
    recipe: { wood: 2, stick: 1 },
    pattern: [null,'wood',null, null,'wood',null, null,'stick',null] },
  { id: 'stone_sword',   name: 'Áü≥Âäç',   emoji: 'üó°Ô∏è', holdTime: 1000, durability: 30,
    recipe: { stick: 1, stone: 2 },
    pattern: [null,'stone',null, null,'stone',null, null,'stick',null] },
  { id: 'iron_sword',    name: 'ÈêµÂäç',   emoji: 'üó°Ô∏è', holdTime: 700, durability: 60,
    recipe: { stick: 1, iron_ingot: 2 },
    pattern: [null,'iron_ingot',null, null,'iron_ingot',null, null,'stick',null] },
  { id: 'gold_sword',    name: 'ÈáëÂäç',   emoji: 'üó°Ô∏è', holdTime: 700, durability: 25,
    recipe: { stick: 1, gold_ingot: 2 },
    pattern: [null,'gold_ingot',null, null,'gold_ingot',null, null,'stick',null] },
  { id: 'diamond_sword', name: 'ÈëΩÁü≥Âäç', emoji: 'üó°Ô∏è', holdTime: 400, durability: 150,
    recipe: { stick: 1, diamond: 2 },
    pattern: [null,'diamond',null, null,'diamond',null, null,'stick',null] },
];

const armorSlots = ['helmet', 'chest', 'legs', 'boots'];
const armorMaterials = [
  { id: 'leather', name: 'ÁöÆÈù©', emoji: 'üü§' },
  { id: 'iron',    name: 'Èêµ',   emoji: '‚¨ú' },
  { id: 'gold',    name: 'Èáë',   emoji: 'üü°' },
  { id: 'diamond', name: 'ÈëΩÁü≥', emoji: 'üíé' },
];

const armorRecipes = [
  // Helmets: XXX / X_X / ___
  { outputId: 'leather_helmet', material: 'leather', slot: 'helmet', recipe: { leather: 5 },
    pattern: ['leather','leather','leather', 'leather',null,'leather', null,null,null] },
  { outputId: 'iron_helmet', material: 'iron', slot: 'helmet', recipe: { iron_ingot: 5 },
    pattern: ['iron_ingot','iron_ingot','iron_ingot', 'iron_ingot',null,'iron_ingot', null,null,null] },
  { outputId: 'gold_helmet', material: 'gold', slot: 'helmet', recipe: { gold_ingot: 5 },
    pattern: ['gold_ingot','gold_ingot','gold_ingot', 'gold_ingot',null,'gold_ingot', null,null,null] },
  { outputId: 'diamond_helmet', material: 'diamond', slot: 'helmet', recipe: { diamond: 5 },
    pattern: ['diamond','diamond','diamond', 'diamond',null,'diamond', null,null,null] },
  // Chestplates: X_X / XXX / XXX
  { outputId: 'leather_chest', material: 'leather', slot: 'chest', recipe: { leather: 8 },
    pattern: ['leather',null,'leather', 'leather','leather','leather', 'leather','leather','leather'] },
  { outputId: 'iron_chest', material: 'iron', slot: 'chest', recipe: { iron_ingot: 8 },
    pattern: ['iron_ingot',null,'iron_ingot', 'iron_ingot','iron_ingot','iron_ingot', 'iron_ingot','iron_ingot','iron_ingot'] },
  { outputId: 'gold_chest', material: 'gold', slot: 'chest', recipe: { gold_ingot: 8 },
    pattern: ['gold_ingot',null,'gold_ingot', 'gold_ingot','gold_ingot','gold_ingot', 'gold_ingot','gold_ingot','gold_ingot'] },
  { outputId: 'diamond_chest', material: 'diamond', slot: 'chest', recipe: { diamond: 8 },
    pattern: ['diamond',null,'diamond', 'diamond','diamond','diamond', 'diamond','diamond','diamond'] },
  // Leggings: XXX / X_X / X_X
  { outputId: 'leather_legs', material: 'leather', slot: 'legs', recipe: { leather: 7 },
    pattern: ['leather','leather','leather', 'leather',null,'leather', 'leather',null,'leather'] },
  { outputId: 'iron_legs', material: 'iron', slot: 'legs', recipe: { iron_ingot: 7 },
    pattern: ['iron_ingot','iron_ingot','iron_ingot', 'iron_ingot',null,'iron_ingot', 'iron_ingot',null,'iron_ingot'] },
  { outputId: 'gold_legs', material: 'gold', slot: 'legs', recipe: { gold_ingot: 7 },
    pattern: ['gold_ingot','gold_ingot','gold_ingot', 'gold_ingot',null,'gold_ingot', 'gold_ingot',null,'gold_ingot'] },
  { outputId: 'diamond_legs', material: 'diamond', slot: 'legs', recipe: { diamond: 7 },
    pattern: ['diamond','diamond','diamond', 'diamond',null,'diamond', 'diamond',null,'diamond'] },
  // Boots: ___ / X_X / X_X
  { outputId: 'leather_boots', material: 'leather', slot: 'boots', recipe: { leather: 4 },
    pattern: [null,null,null, 'leather',null,'leather', 'leather',null,'leather'] },
  { outputId: 'iron_boots', material: 'iron', slot: 'boots', recipe: { iron_ingot: 4 },
    pattern: [null,null,null, 'iron_ingot',null,'iron_ingot', 'iron_ingot',null,'iron_ingot'] },
  { outputId: 'gold_boots', material: 'gold', slot: 'boots', recipe: { gold_ingot: 4 },
    pattern: [null,null,null, 'gold_ingot',null,'gold_ingot', 'gold_ingot',null,'gold_ingot'] },
  { outputId: 'diamond_boots', material: 'diamond', slot: 'boots', recipe: { diamond: 4 },
    pattern: [null,null,null, 'diamond',null,'diamond', 'diamond',null,'diamond'] },
];

// General crafting recipes (non-pickaxe)
// shapeless: true means the item can be placed in any slot
const craftRecipes = [
  { id: 'wood_to_sticks', name: 'Êú®Ê£ç', emoji: 'ü•¢', outputId: 'stick', outputCount: 4,
    needs: { wood: 1 }, shapeless: true },
  { id: 'furnace', name: 'ÁÜîÁàê', emoji: 'üî•', outputId: 'furnace', outputCount: 1,
    needs: { stone: 8 },
    pattern: ['stone','stone','stone', 'stone',null,'stone', 'stone','stone','stone'] },
  { id: 'bed', name: 'Â∫ä', emoji: 'üõèÔ∏è', outputId: 'bed', outputCount: 1,
    needs: { wool: 3, wood: 3 },
    pattern: ['wool','wool','wool', 'wood','wood','wood', null,null,null] },
  // Torch: coal + stick ‚Üí 4 torches
  { id: 'torch', name: 'ÁÅ´Êää', emoji: 'üïØÔ∏è', outputId: 'torch', outputCount: 4,
    needs: { coal: 1, stick: 1 },
    pattern: [null,'coal',null, null,'stick',null, null,null,null] },
  // Ladder: 7 sticks ‚Üí 3 ladders
  { id: 'ladder', name: 'Ê¢ØÂ≠ê', emoji: 'ü™ú', outputId: 'ladder', outputCount: 3,
    needs: { stick: 7 },
    pattern: ['stick',null,'stick', 'stick','stick','stick', 'stick',null,'stick'] },
  // Chest: 8 wood
  { id: 'chest', name: 'ÁÆ±Â≠ê', emoji: 'üì¶', outputId: 'chest', outputCount: 1,
    needs: { wood: 8 },
    pattern: ['wood','wood','wood', 'wood',null,'wood', 'wood','wood','wood'] },
  // Door: 6 wood ‚Üí 3 doors
  { id: 'door', name: 'ÈñÄ', emoji: 'üö™', outputId: 'door', outputCount: 3,
    needs: { wood: 6 },
    pattern: ['wood','wood',null, 'wood','wood',null, 'wood','wood',null] },
  // Fence: 4 wood + 2 sticks ‚Üí 3 fences
  { id: 'fence', name: 'ÊüµÊ¨Ñ', emoji: 'üèóÔ∏è', outputId: 'fence', outputCount: 3,
    needs: { wood: 4, stick: 2 },
    pattern: [null,null,null, 'wood','stick','wood', 'wood','stick','wood'] },
  // Bookshelf: 6 wood + 3 leather (simplified ‚Äî real MC uses paper/books)
  { id: 'bookshelf', name: 'Êõ∏Êû∂', emoji: 'üìö', outputId: 'bookshelf', outputCount: 1,
    needs: { wood: 6, leather: 3 },
    pattern: ['wood','wood','wood', 'leather','leather','leather', 'wood','wood','wood'] },
  // Painting: 8 sticks + 1 wool
  { id: 'painting', name: 'Áï´', emoji: 'üñºÔ∏è', outputId: 'painting', outputCount: 1,
    needs: { stick: 8, wool: 1 },
    pattern: ['stick','stick','stick', 'stick','wool','stick', 'stick','stick','stick'] },
  // TNT: 5 gunpowder + 4 sand
  { id: 'tnt', name: 'TNT', emoji: 'üß®', outputId: 'tnt', outputCount: 1,
    needs: { gunpowder: 5, sand: 4 },
    pattern: ['gunpowder','sand','gunpowder', 'sand','gunpowder','sand', 'gunpowder','sand','gunpowder'] },
  // Bow: 3 sticks + 3 string
  { id: 'bow', name: 'Âºì', emoji: 'üèπ', outputId: 'bow', outputCount: 1,
    needs: { stick: 3, string: 3 },
    pattern: [null,'stick','string', 'stick',null,'string', null,'stick','string'] },
  // Arrow: 1 stick + 1 feather + 1 gravel (flint simplified)
  { id: 'arrow', name: 'ÁÆ≠', emoji: '‚û°Ô∏è', outputId: 'arrow', outputCount: 4,
    needs: { gravel: 1, stick: 1, feather: 1 },
    pattern: [null,'gravel',null, null,'stick',null, null,'feather',null] },
  // Boat: 5 wood
  { id: 'boat', name: 'Ëàπ', emoji: 'üõ∂', outputId: 'boat', outputCount: 1,
    needs: { wood: 5 },
    pattern: [null,null,null, 'wood',null,'wood', 'wood','wood','wood'] },
  // Bucket: 3 iron ingots
  { id: 'bucket', name: 'Ê°∂', emoji: 'ü™£', outputId: 'bucket', outputCount: 1,
    needs: { iron_ingot: 3 },
    pattern: [null,null,null, 'iron_ingot',null,'iron_ingot', null,'iron_ingot',null] },
  // Compass: 4 iron ingots + 1 redstone
  { id: 'compass', name: 'ÊåáÂçóÈáù', emoji: 'üß≠', outputId: 'compass', outputCount: 1,
    needs: { iron_ingot: 4, redstone: 1 },
    pattern: [null,'iron_ingot',null, 'iron_ingot','redstone','iron_ingot', null,'iron_ingot',null] },
  // Clock: 4 gold ingots + 1 redstone
  { id: 'clock', name: 'ÊôÇÈêò', emoji: 'üïê', outputId: 'clock', outputCount: 1,
    needs: { gold_ingot: 4, redstone: 1 },
    pattern: [null,'gold_ingot',null, 'gold_ingot','redstone','gold_ingot', null,'gold_ingot',null] },
];

const smeltRecipes = [
  { input: 'iron',         fuel: 'coal', output: 'iron_ingot',   name: 'ÈêµÈå†',   emoji: 'üî©' },
  { input: 'gold',         fuel: 'coal', output: 'gold_ingot',   name: 'ÈáëÈå†',   emoji: 'ü™ô' },
  { input: 'copper',       fuel: 'coal', output: 'copper_ingot', name: 'ÈäÖÈå†',   emoji: 'üü†' },
  { input: 'pork',         fuel: 'coal', output: 'cooked_pork',    name: 'ÁÉ§Ë±¨Êéí', emoji: 'ü•©' },
  { input: 'chicken_meat', fuel: 'coal', output: 'cooked_chicken', name: 'ÁÉ§ÈõûËÇâ', emoji: 'üçó' },
  { input: 'sand',         fuel: 'coal', output: 'glass',    name: 'ÁéªÁíÉ', emoji: 'ü™ü' },
  { input: 'clay',         fuel: 'coal', output: 'brick',    name: 'Á£öÂ°ä', emoji: 'üß±' },
];

// Cooked food effects: item id ‚Üí stamina gained
const foodEffects = {
  cooked_pork: 3,
  cooked_chicken: 2,
};


const tierColors = ['#8B7355', '#A0A0A0', '#C0C0C0', '#FFD700', '#B9F2FF'];

// ===== STATE =====
let stars = 0, streak = 0, currentFeeling = 'happy';
let matchSelected = null, matchedPairs = new Set();
let quizQuestions = [], quizIndex = 0, quizScore = 0, quizAnswered = false, quizWrong = new Set();
let speechSpeed = 'normal'; // 'slow' or 'normal'
let isMuted = false;

// ===== MINING STATE =====
let gems = 0;
let inventory = {};
let buildGrid = {}; // sparse grid: { "row,col": blockId } for free-form building
let buildSelected = null; // currently selected block ID for placement
let buildPlayerPos = null; // { r, c } ‚Äî player position on build grid
let savedMineGrid = null; // serialized mineData for persistence across reloads
let toolDurability = {}; // { 'stone_pick': 28, ... } ‚Äî remaining uses for active tool
let discovered = new Set(); // permanently tracks every item ID ever obtained
let equipped = { helmet: null, chest: null, legs: null, boots: null };
let selectedTools = { tool: null, weapon: null }; // null = bare hands

function getEquippedTool() {
  const id = selectedTools.tool;
  if (!id) return null;
  const lists = [pickaxes, axes];
  for (const list of lists) {
    const t = list.find(x => x.id === id);
    if (t && t.id !== 'hands' && getBlockCount(t.id) > 0) {
      if (t.durability !== Infinity && toolDurability[t.id] === undefined) toolDurability[t.id] = t.durability;
      return t;
    }
  }
  selectedTools.tool = null;
  return null;
}

function getEquippedWeapon() {
  const id = selectedTools.weapon;
  if (!id) return null;
  const t = swords.find(x => x.id === id);
  if (t && t.id !== 'hands' && getBlockCount(t.id) > 0) {
    if (t.durability !== Infinity && toolDurability[t.id] === undefined) toolDurability[t.id] = t.durability;
    return t;
  }
  selectedTools.weapon = null;
  return null;
}

function getEffectivePickaxeLevel() {
  const tool = getEquippedTool();
  if (!tool) return 0;
  const idx = pickaxes.indexOf(tool);
  return idx >= 0 ? idx : 0;
}

function getEffectiveAxeBonus() {
  const tool = getEquippedTool();
  return (tool && tool.woodBonus) ? tool.woodBonus : 1;
}

function getEffectiveSword() {
  return getEquippedWeapon() || swords[0];
}

function getEffectiveSwordHoldTime() {
  const sword = getEffectiveSword();
  return sword ? sword.holdTime : 2000;
}

// Use a tool: decrement durability, return break message or null
function useTool(tool) {
  if (!tool || tool.durability === Infinity) return null;
  if (toolDurability[tool.id] === undefined) toolDurability[tool.id] = tool.durability;
  toolDurability[tool.id]--;
  if (toolDurability[tool.id] <= 0) {
    // Tool broke
    playToolBreakSfx();
    inventory[tool.id] = (inventory[tool.id] || 1) - 1;
    if (inventory[tool.id] <= 0) delete inventory[tool.id];
    delete toolDurability[tool.id];
    // If more of same tool, set durability for next one
    if (getBlockCount(tool.id) > 0) {
      toolDurability[tool.id] = tool.durability;
    }
    saveGame();
    return tool.name;
  }
  saveGame();
  return null;
}

function getToolDurabilityText(tool) {
  if (!tool || tool.durability === Infinity) return '';
  const cur = toolDurability[tool.id] || tool.durability;
  return ` (${cur}/${tool.durability})`;
}

function serializeMineData() {
  if (!mineData.length) return savedMineGrid || null;
  return mineData.map(row => row.map(cell => {
    if (!cell) return null;
    const s = { t: cell.tier, m: cell.mined ? 1 : 0 };
    if (cell.block) s.b = cell.block.id;
    if (cell.animal) { s.a = cell.animal.id; if (cell.animal.hostile) s.h = 1; }
    if (cell.treeEmoji) s.te = cell.treeEmoji;
    return s;
  }));
}

function saveGame() {
  localStorage.setItem('mineGame', JSON.stringify({ gems, inventory, buildGrid, buildPlayerPos, stars, streak, craftGrid, toolDurability, discovered: [...discovered], equipped, selectedTools, sightEarned: [...sightEarned], _houseMigrated: true, mineGrid: serializeMineData(), sentenceReadCount, dialogueReadCount }));
}

function loadGame() {
  try {
    const d = JSON.parse(localStorage.getItem('mineGame'));
    if (!d) return;
    gems = d.gems || 0;
    inventory = d.inventory || {};
    toolDurability = d.toolDurability || {};
    if (d.discovered) discovered = new Set(d.discovered);
    if (d.equipped) equipped = { helmet: null, chest: null, legs: null, boots: null, ...d.equipped };
    if (d.selectedTools) {
      // Migrate old format { pickaxe, axe, sword } ‚Üí { tool, weapon }
      if ('pickaxe' in d.selectedTools || 'sword' in d.selectedTools) {
        selectedTools = { tool: d.selectedTools.pickaxe || d.selectedTools.axe || null, weapon: d.selectedTools.sword || null };
      } else {
        selectedTools = { tool: null, weapon: null, ...d.selectedTools };
      }
    }
    // Also mark any current inventory items as discovered
    Object.keys(inventory).forEach(id => discovered.add(id));
    Object.values(equipped).forEach(id => { if (id) discovered.add(id); });
    // Migration: convert old pickaxeLevel to inventory item (index shifted by +1 for hands entry)
    if (d.pickaxeLevel > 0 && (d.pickaxeLevel + 1) < pickaxes.length) {
      const oldPick = pickaxes[d.pickaxeLevel + 1];
      if (!inventory[oldPick.id]) inventory[oldPick.id] = 1;
    }
    if (d.buildGrid && typeof d.buildGrid === 'object') buildGrid = d.buildGrid;
    if (d.buildPlayerPos) buildPlayerPos = d.buildPlayerPos;
    if (d.mineGrid && Array.isArray(d.mineGrid)) savedMineGrid = d.mineGrid;
    // Migration: refund old house materials back to inventory
    if (d.houseProgress > 0 && !d._houseMigrated) {
      const oldStages = [
        { stone: 6 }, { wood: 8 }, { wood: 4, iron_ingot: 2 },
        { gold_ingot: 1, emerald: 1 }, { bed: 1 },
      ];
      for (let i = 0; i < Math.min(d.houseProgress, oldStages.length); i++) {
        Object.entries(oldStages[i]).forEach(([id, count]) => {
          inventory[id] = (inventory[id] || 0) + count;
        });
      }
    }
    if (d.craftGrid) craftGrid = d.craftGrid;
    if (d.sightEarned) sightEarned = new Set(d.sightEarned);
    if (d.sentenceReadCount) {
      sentenceReadCount = d.sentenceReadCount;
      // Pad if sentences were added after save
      while (sentenceReadCount.length < sentences.length) sentenceReadCount.push(0);
    }
    if (d.dialogueReadCount) {
      dialogueReadCount = d.dialogueReadCount;
      while (dialogueReadCount.length < dialogues.length) dialogueReadCount.push(0);
    }
    stars = d.stars || 0;
    streak = d.streak || 0;
    document.getElementById('stars').textContent = Math.floor(stars);
    document.getElementById('streak').textContent = streak;
    updateGemDisplay();
  } catch (e) { console.warn('Failed to load save', e); }
}

function addGems(n) {
  gems += n;
  updateGemDisplay();
  saveGame();
}

function updateGemDisplay() {
  const el = document.getElementById('gems');
  if (el) el.textContent = gems;
  const bar = document.getElementById('gemBar');
  if (bar) { bar.classList.remove('pop'); void bar.offsetWidth; bar.classList.add('pop'); }
}

function getBlockCount(id) { return inventory[id] || 0; }

function addBlock(id, n) {
  inventory[id] = (inventory[id] || 0) + (n || 1);
  discovered.add(id);
  saveGame();
}

function removeBlocks(recipe) {
  for (const [id, count] of Object.entries(recipe)) {
    inventory[id] = (inventory[id] || 0) - count;
    if (inventory[id] <= 0) delete inventory[id];
  }
  saveGame();
}

function hasBlocks(recipe) {
  return Object.entries(recipe).every(([id, count]) => getBlockCount(id) >= count);
}

// ===== TTS ENGINE =====
// Primary: SpeechSynthesis with smart voice selection
// macOS has many novelty voices (Albert, Bad News, Bells, etc.) ‚Äî filter those out
let lastEngine = 'none';
let cachedVoice = null;

const noveltyVoices = new Set([
  'Albert','Bad News','Bahh','Bells','Boing','Bubbles','Cellos','Good News',
  'Jester','Organ','Superstar','Trinoids','Whisper','Wobble','Zarvox',
  'Ralph','Fred','Kathy','Junior','Princess'
]);

function pickBestVoice(voices) {
  if (cachedVoice) return cachedVoice;
  const preferred = ['Samantha','Alex','Karen','Daniel','Moira','Tessa','Ava','Tom','Allison'];
  for (const name of preferred) {
    const v = voices.find(v => v.name.includes(name) && v.lang.startsWith('en'));
    if (v) { cachedVoice = v; return v; }
  }
  const enUS = voices.filter(v => v.lang === 'en-US' && !noveltyVoices.has(v.name));
  if (enUS.length) { cachedVoice = enUS[0]; return enUS[0]; }
  const en = voices.filter(v => v.lang.startsWith('en') && !noveltyVoices.has(v.name));
  if (en.length) { cachedVoice = en[0]; return en[0]; }
  cachedVoice = voices.find(v => v.lang.startsWith('en')) || voices[0];
  return cachedVoice;
}

// Unlock SpeechSynthesis on first user interaction (iOS requirement)
function unlockAudio() {
  if (window.speechSynthesis) {
    const u = new SpeechSynthesisUtterance('');
    u.volume = 0;
    speechSynthesis.speak(u);
  }
}
document.addEventListener('touchstart', unlockAudio, { once: true });
document.addEventListener('click', unlockAudio, { once: true });

function updateEngineDisplay(engine, detail) {
  lastEngine = engine;
  const el = document.getElementById('engineStatus');
  if (engine === 'speech-synthesis') {
    el.textContent = `üü¢ SpeechSynthesis${detail ? ' ‚Äî ' + detail : ''}`;
    el.style.color = '#00B894';
  } else if (engine === 'error') {
    el.textContent = `üî¥ ÁÑ°Ê≥ïÁôºÈü≥${detail ? ' ‚Äî ' + detail : ''}`;
    el.style.color = '#FF6B6B';
  } else {
    el.textContent = 'üîç ÂÅµÊ∏¨‰∏≠...';
    el.style.color = '#B2BEC3';
  }
}

function speak(text, forceSpeed) {
  const synth = window.speechSynthesis;
  if (!synth) {
    updateEngineDisplay('error', 'SpeechSynthesis not available');
    return null;
  }
  synth.cancel();

  const speed = forceSpeed || speechSpeed;
  const rateMap = { slower: 0.4, slow: 0.6, normal: 0.85 };
  const u = new SpeechSynthesisUtterance(text);
  u.lang = 'en-US';
  u.rate = rateMap[speed] || 0.85;
  u.pitch = 1.05;
  const pick = pickBestVoice(synth.getVoices());
  if (pick) u.voice = pick;
  u.onstart = () => updateEngineDisplay('speech-synthesis', pick ? pick.name : 'default voice');
  u.onerror = (e) => updateEngineDisplay('error', e.error);
  synth.speak(u);
  return u;
}

// Speak word first, then sentence after a pause
function speakWordThenSentence(word, sentence) {
  const synth = window.speechSynthesis;
  if (!synth) return;
  synth.cancel();

  const rateMap2 = { slower: 0.4, slow: 0.6, normal: 0.85 };
  const u = new SpeechSynthesisUtterance(word);
  u.lang = 'en-US';
  u.rate = rateMap2[speechSpeed] || 0.85;
  u.pitch = 1.05;
  const pick = pickBestVoice(synth.getVoices());
  if (pick) u.voice = pick;
  u.onstart = () => updateEngineDisplay('speech-synthesis', pick ? pick.name : 'default voice');
  u.onend = () => {
    setTimeout(() => speak(sentence), 400);
  };
  u.onerror = (e) => updateEngineDisplay('error', e.error);
  synth.speak(u);
}

// ===== SPEED TOGGLE =====
document.querySelectorAll('.speed-btn[data-speed]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.speed-btn[data-speed]').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    speechSpeed = btn.dataset.speed;
  });
});

// ===== SFX (Web Audio API) =====
let audioCtx = null;
function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

function playMineSfx(tier) {
  if (isMuted) return;
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();

  // Noise burst ‚Äî sounds like stone breaking
  const bufferSize = ctx.sampleRate * 0.08;
  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize); // decaying noise
  }
  const noise = ctx.createBufferSource();
  noise.buffer = buffer;

  // Filter ‚Äî higher tier = higher pitch
  const filter = ctx.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.value = 400 + tier * 200;
  filter.Q.value = 1.5;

  const gain = ctx.createGain();
  gain.gain.value = 0.3;
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);

  noise.connect(filter).connect(gain).connect(ctx.destination);
  noise.start();
  noise.stop(ctx.currentTime + 0.08);

  // Extra "ding" for rare blocks (tier 4+)
  if (tier >= 4) {
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = tier >= 5 ? 1200 : 900;
    const oscGain = ctx.createGain();
    oscGain.gain.value = 0.15;
    oscGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);
    osc.connect(oscGain).connect(ctx.destination);
    osc.start(ctx.currentTime + 0.05);
    osc.stop(ctx.currentTime + 0.3);
  }
}

function playLockedSfx() {
  if (isMuted) return;
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();
  const osc = ctx.createOscillator();
  osc.type = 'square';
  osc.frequency.value = 120;
  const gain = ctx.createGain();
  gain.gain.value = 0.1;
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
  osc.connect(gain).connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.15);
}

function playCraftSfx() {
  if (isMuted) return;
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();
  // Ascending arpeggio
  [0, 1, 2].forEach((i) => {
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = 600 + i * 200;
    const gain = ctx.createGain();
    gain.gain.value = 0.12;
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15 + i * 0.1);
    osc.connect(gain).connect(ctx.destination);
    osc.start(ctx.currentTime + i * 0.1);
    osc.stop(ctx.currentTime + 0.15 + i * 0.1);
  });
}

function playToolBreakSfx() {
  if (isMuted) return;
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();
  // Descending crack ‚Äî falling pitch + noise burst
  const osc = ctx.createOscillator();
  osc.type = 'sawtooth';
  osc.frequency.setValueAtTime(800, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(120, ctx.currentTime + 0.25);
  const oscGain = ctx.createGain();
  oscGain.gain.setValueAtTime(0.2, ctx.currentTime);
  oscGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.25);
  osc.connect(oscGain).connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.25);
  // Noise burst ‚Äî shatter texture
  const bufferSize = ctx.sampleRate * 0.15;
  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
  const noise = ctx.createBufferSource();
  noise.buffer = buffer;
  const nGain = ctx.createGain();
  nGain.gain.value = 0.25;
  nGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
  noise.connect(nGain).connect(ctx.destination);
  noise.start(ctx.currentTime + 0.03);
  noise.stop(ctx.currentTime + 0.18);
}

function playPlaceSfx() {
  if (isMuted) return;
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();
  const osc = ctx.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = 500;
  const gain = ctx.createGain();
  gain.gain.value = 0.08;
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.06);
  osc.connect(gain).connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.06);
}

function playRemoveSfx() {
  if (isMuted) return;
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();
  const osc = ctx.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = 300;
  const gain = ctx.createGain();
  gain.gain.value = 0.08;
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
  osc.connect(gain).connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.1);
}

// ===== LEARN GATE =====
let learnGatePending = null; // { callback } ‚Äî execute after correct answer
let learnGateAttempts = 0;

function rollLearnGate(callback) {
  if (Math.random() < 0.3) {
    learnGatePending = { callback };
    learnGateAttempts = 0;
    showLearnGate();
  } else {
    callback();
  }
}

function showLearnGate() {
  const modal = document.getElementById('learnGateModal');
  const content = document.getElementById('learnGateContent');
  content.textContent = '';

  const header = document.createElement('div');
  header.style.cssText = 'text-align:center;font-family:var(--font-display);font-size:1.2rem;font-weight:700;margin-bottom:12px;';
  header.textContent = 'üìñ Â≠∏‰∏Ä‰∏ãÔºÅLearn First!';
  content.appendChild(header);

  // Pick quiz type: 0 = feelings (emoji‚Üíword), 1 = sight word (zh‚Üíen)
  const quizType = Math.random() < 0.5 ? 0 : 1;
  let correctItem, prompt, allItems, correctAnswer;

  if (quizType === 0) {
    correctItem = feelings[Math.floor(Math.random() * feelings.length)];
    prompt = correctItem.emoji + ' ÈÄôÊòØ‰ªÄÈ∫ºÊÑüË¶∫Ôºü';
    correctAnswer = correctItem.word;
    allItems = feelings.map(f => f.word);
  } else {
    correctItem = sightWords[Math.floor(Math.random() * sightWords.length)];
    prompt = '„Äå' + correctItem.zh + '„ÄçÁöÑËã±ÊñáÊòØÔºü';
    correctAnswer = correctItem.word;
    allItems = sightWords.map(s => s.word);
  }

  const promptEl = document.createElement('div');
  promptEl.style.cssText = 'text-align:center;font-size:1.3rem;margin-bottom:16px;';
  promptEl.textContent = prompt;
  content.appendChild(promptEl);

  // Build 4 options (1 correct + 3 distractors)
  const others = allItems.filter(w => w !== correctAnswer);
  const distractors = shuffle(others).slice(0, 3);
  const options = shuffle([correctAnswer, ...distractors]);

  const optGrid = document.createElement('div');
  optGrid.style.cssText = 'display:grid;grid-template-columns:1fr 1fr;gap:8px;';

  options.forEach(word => {
    const btn = document.createElement('button');
    btn.style.cssText = 'padding:12px 8px;border-radius:12px;border:2px solid var(--border);background:var(--card-bg);font-family:var(--font-display);font-size:1rem;font-weight:600;cursor:pointer;transition:all 0.15s;';
    btn.textContent = word;
    btn.addEventListener('click', () => handleLearnGateAnswer(word === correctAnswer, correctAnswer, optGrid));
    optGrid.appendChild(btn);
  });
  content.appendChild(optGrid);

  modal.classList.add('active');
}

function handleLearnGateAnswer(isCorrect, correctWord, optGrid) {
  const modal = document.getElementById('learnGateModal');
  if (isCorrect) {
    speak(correctWord);
    addStars(1);
    modal.classList.remove('active');
    if (learnGatePending) {
      learnGatePending.callback();
      learnGatePending = null;
    }
  } else {
    learnGateAttempts++;
    // Highlight correct answer green, wrong red
    Array.from(optGrid.children).forEach(btn => {
      btn.disabled = true;
      if (btn.textContent === correctWord) {
        btn.style.background = '#00B894';
        btn.style.color = '#FFF';
        btn.style.borderColor = '#00B894';
      } else {
        btn.style.opacity = '0.4';
      }
    });
    if (learnGateAttempts >= 2) {
      // Show skip button after 2 wrong attempts
      const skipBtn = document.createElement('button');
      skipBtn.style.cssText = 'display:block;margin:12px auto 0;padding:8px 20px;border-radius:20px;border:1px solid var(--border);background:var(--surface);font-family:var(--font-display);font-size:0.85rem;cursor:pointer;color:var(--text-muted);';
      skipBtn.textContent = 'Ë∑≥ÈÅé Skip';
      skipBtn.addEventListener('click', () => {
        modal.classList.remove('active');
        if (learnGatePending) {
          learnGatePending.callback();
          learnGatePending = null;
        }
      });
      document.getElementById('learnGateContent').appendChild(skipBtn);
    } else {
      setTimeout(() => showLearnGate(), 1200);
    }
  }
}

// ===== UTILS =====
function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function addStars(n) {
  stars += n;
  document.getElementById('stars').textContent = Math.floor(stars);
  const el = document.getElementById('starBar');
  el.classList.remove('pop');
  void el.offsetWidth;
  el.classList.add('pop');
  saveGame();
}

function bumpStreak() {
  streak++;
  document.getElementById('streak').textContent = streak;
  const el = document.getElementById('streakBar');
  el.classList.remove('pop');
  void el.offsetWidth;
  el.classList.add('pop');
}

function resetStreak() { streak = 0; document.getElementById('streak').textContent = 0; saveGame(); }

function doConfetti() {
  const box = document.getElementById('confettiBox');
  const colors = ['#FFD93D','#FF6B6B','#A29BFE','#FF85CA','#00B894','#74B9FF'];
  for (let i = 0; i < 35; i++) {
    const p = document.createElement('div');
    p.className = 'confetti-piece';
    p.style.left = Math.random() * 100 + '%';
    p.style.background = colors[Math.floor(Math.random() * colors.length)];
    p.style.animationDelay = Math.random() * 0.5 + 's';
    p.style.animationDuration = (1.5 + Math.random()) + 's';
    const size = 6 + Math.random() * 8;
    p.style.width = size + 'px';
    p.style.height = size + 'px';
    box.appendChild(p);
  }
  setTimeout(() => box.innerHTML = '', 3000);
}

// ===== HEADER HIDE ON SCROLL DOWN, SHOW ON SCROLL UP =====
let lastScrollY = 0;
window.addEventListener('scroll', () => {
  const header = document.getElementById('appHeader');
  const y = window.scrollY;
  if (y > lastScrollY && y > 50) {
    header.classList.add('hidden');    // scrolling down ‚Äî hide
  } else {
    header.classList.remove('hidden'); // scrolling up ‚Äî show
  }
  lastScrollY = y;
}, { passive: true });

// ===== NAV =====
document.querySelectorAll('.nav-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById(tab.dataset.tab).classList.add('active');
    if (tab.dataset.tab === 'match') { if (!document.querySelector('#matchWords .match-item') || matchedPairs.size >= 6) initMatch(); }
    if (tab.dataset.tab === 'quiz') { if (quizIndex === 0 || quizIndex >= quizQuestions.length) initQuiz(); }
    if (tab.dataset.tab === 'read') { if (!document.getElementById('sentenceCards').children.length) initRead(); }
    if (tab.dataset.tab === 'sight') { if (!document.getElementById('sightWordsArea').children.length) initSightWords(); }
    if (tab.dataset.tab === 'mine') { if (!mineData.length) initMine(); else refreshMineHeader(); }
    if (tab.dataset.tab === 'craft') initCraftTab();
    if (tab.dataset.tab === 'furnace') initFurnaceTab();
    if (tab.dataset.tab === 'equip') initEquipTab();
    if (tab.dataset.tab === 'encyclopedia') initEncyclopediaTab();
  });
});

// ===== LEARN =====
function initLearn() {
  const grid = document.getElementById('feelingsGrid');
  grid.innerHTML = '';
  feelings.forEach(f => {
    const card = document.createElement('div');
    card.className = 'feeling-card';
    card.innerHTML = `
      <span class="speaker-hint">üîä</span>
      <span class="emoji">${f.emoji}</span>
      <div class="word">${f.word}</div>
      <div class="chinese">${f.zh}</div>
    `;
    card.style.borderBottom = `4px solid ${f.color}`;
    card.addEventListener('click', () => {
      card.classList.add('speaking');
      setTimeout(() => card.classList.remove('speaking'), 800);
      speak(f.word);
      selectFeeling(f.word);
    });
    grid.appendChild(card);
  });

  const chips = document.getElementById('feelingChips');
  chips.innerHTML = '';
  feelings.forEach(f => {
    const chip = document.createElement('button');
    chip.className = 'feeling-chip' + (f.word === currentFeeling ? ' selected' : '');
    chip.textContent = `${f.emoji} ${f.word}`;
    chip.addEventListener('click', () => {
      selectFeeling(f.word);
      speak(`I feel ${f.word}.`);
    });
    chips.appendChild(chip);
  });

  // Sight words section
  const slGrid = document.getElementById('sightLearnGrid');
  slGrid.innerHTML = '';
  sightWords.forEach((sw, i) => {
    const card = document.createElement('div');
    card.className = 'sight-learn-card';
    card.style.borderBottom = `4px solid ${sightColors[i % sightColors.length]}`;
    card.innerHTML = `
      <span class="speaker-hint">üîä</span>
      <div class="sl-word">${sw.word}</div>
      <div class="sl-zh">${sw.zh}</div>
      <div class="sl-sentence">${sw.sentence}</div>
    `;
    card.addEventListener('click', () => {
      card.classList.add('speaking');
      setTimeout(() => card.classList.remove('speaking'), 800);
      speakWordThenSentence(sw.word, sw.sentence);
    });
    slGrid.appendChild(card);
  });
}

// ===== READ (Sentence Reading + Dialogues) =====
function createEl(tag, className, textContent) {
  const el = document.createElement(tag);
  if (className) el.className = className;
  if (textContent) el.textContent = textContent;
  return el;
}

let currentReadUnit = 'sentences';

function initRead() {
  // Unit toggle listeners (only bind once)
  document.querySelectorAll('.read-unit-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.read-unit-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentReadUnit = btn.dataset.unit;
      renderReadCards();
    });
  });
  renderReadCards();
}

function renderReadCards() {
  const container = document.getElementById('sentenceCards');
  container.textContent = '';
  if (currentReadUnit === 'sentences') {
    sentences.forEach((s, i) => container.appendChild(buildSentenceCard(s, i)));
  } else {
    dialogues.forEach((d, i) => container.appendChild(buildDialogueCard(d, i)));
  }
  updateReadProgress();
}

function buildCardShell(id, done) {
  const card = createEl('div', 'sentence-card' + (done ? ' done' : ''));
  card.id = id;
  return card;
}

function buildCardBottom(count, listenFn, readFn) {
  const bottom = createEl('div', 'sc-bottom');
  const dots = createEl('div', 'sc-dots');
  for (let d = 0; d < SENTENCE_GOAL; d++) {
    dots.appendChild(createEl('div', 'sc-dot' + (d < count ? ' filled' : '')));
  }
  bottom.appendChild(dots);
  const listenBtn = createEl('button', 'sc-listen-btn', 'üîä Listen');
  listenBtn.addEventListener('click', (e) => { e.stopPropagation(); listenFn(); });
  bottom.appendChild(listenBtn);
  bottom.appendChild(createEl('div', 'sc-count', count >= SENTENCE_GOAL ? '‚úÖ' : `${count}/${SENTENCE_GOAL}`));
  return bottom;
}

function buildSentenceCard(s, i) {
  const count = sentenceReadCount[i];
  const card = buildCardShell(`sc-${i}`, count >= SENTENCE_GOAL);
  card.appendChild(createEl('div', 'sc-number', `#${i + 1}`));
  card.appendChild(createEl('div', 'sc-en', s.en));
  card.appendChild(createEl('div', 'sc-zh', s.zh));
  card.appendChild(buildCardBottom(count,
    () => { card.classList.add('speaking'); setTimeout(() => card.classList.remove('speaking'), 1200); speak(s.en); },
    () => trackRead('sentences', i, card)
  ));
  card.addEventListener('click', () => trackRead('sentences', i, card));
  return card;
}

function buildDialogueCard(d, i) {
  const count = dialogueReadCount[i];
  const card = buildCardShell(`dc-${i}`, count >= SENTENCE_GOAL);
  card.appendChild(createEl('div', 'sc-number', `#${i + 1}`));

  const qa = createEl('div', 'sc-qa');
  const qRow = createEl('div', 'sc-qa-row');
  qRow.appendChild(createEl('span', 'sc-qa-label q', 'Q'));
  qRow.appendChild(createEl('span', 'sc-qa-text', d.q));
  qa.appendChild(qRow);
  qa.appendChild(createEl('div', 'sc-qa-zh', d.qzh));
  const aRow = createEl('div', 'sc-qa-row');
  aRow.appendChild(createEl('span', 'sc-qa-label a', 'A'));
  aRow.appendChild(createEl('span', 'sc-qa-text', d.a));
  qa.appendChild(aRow);
  qa.appendChild(createEl('div', 'sc-qa-zh', d.azh));
  card.appendChild(qa);

  card.appendChild(buildCardBottom(count,
    () => {
      card.classList.add('speaking');
      const synth = window.speechSynthesis;
      if (synth) {
        synth.cancel();
        const listenRate = ({ slower: 0.4, slow: 0.6, normal: 0.65 })[speechSpeed] || 0.65;
        const uq = new SpeechSynthesisUtterance(d.q); uq.lang = 'en-US'; uq.rate = listenRate;
        const ua = new SpeechSynthesisUtterance(d.a); ua.lang = 'en-US'; ua.rate = listenRate;
        uq.onend = () => setTimeout(() => { synth.speak(ua); }, 600);
        ua.onend = () => card.classList.remove('speaking');
        synth.speak(uq);
      }
    },
    () => trackRead('dialogues', i, card)
  ));
  card.addEventListener('click', () => trackRead('dialogues', i, card));
  return card;
}

function trackRead(unit, i, card) {
  const counts = unit === 'sentences' ? sentenceReadCount : dialogueReadCount;
  const data = unit === 'sentences' ? sentences[i] : dialogues[i];
  card.classList.add('speaking');
  const text = unit === 'sentences' ? data.en : (data.q + ' ' + data.a);
  const u = speak(text);
  let incremented = false;
  const increment = () => {
    if (incremented) return;
    incremented = true;
    card.classList.remove('speaking');
    if (counts[i] < SENTENCE_GOAL) {
      counts[i]++;
      // Rebuild the card in place
      const fresh = unit === 'sentences' ? buildSentenceCard(data, i) : buildDialogueCard(data, i);
      card.replaceWith(fresh);
      if (counts[i] >= SENTENCE_GOAL) addGems(2);
      updateReadProgress();
      saveGame();
    }
  };
  if (u && u.addEventListener) { u.addEventListener('end', increment); setTimeout(increment, 15000); }
  else { increment(); }
}

function updateReadProgress() {
  const counts = currentReadUnit === 'sentences' ? sentenceReadCount : dialogueReadCount;
  const total = currentReadUnit === 'sentences' ? sentences.length : dialogues.length;
  const done = counts.filter(c => c >= SENTENCE_GOAL).length;
  const pct = Math.round((done / total) * 100);
  const fill = document.getElementById('readProgressFill');
  if (fill) fill.style.width = pct + '%';
}

function selectFeeling(word) {
  currentFeeling = word;
  const f = feelings.find(x => x.word === word);
  document.getElementById('sentenceDisplay').innerHTML =
    `I feel <span class="hl">${word}</span>. ${f?.emoji || ''}`;
  document.querySelectorAll('.feeling-chip').forEach(c => {
    c.classList.toggle('selected', c.textContent.includes(word));
  });
}

document.getElementById('speakSentenceBtn').addEventListener('click', () => speak(`I feel ${currentFeeling}.`));
document.getElementById('randomSentenceBtn').addEventListener('click', () => {
  const r = feelings[Math.floor(Math.random() * feelings.length)];
  selectFeeling(r.word);
  speak(`I feel ${r.word}.`);
});

// ===== MATCH =====
function initMatch() {
  const pool = shuffle(feelings).slice(0, 6);
  const wCol = document.getElementById('matchWords');
  const eCol = document.getElementById('matchEmojis');
  wCol.innerHTML = '<h3>Words ÂñÆÂ≠ó</h3>';
  eCol.innerHTML = '<h3>Emoji Ë°®ÊÉÖ</h3>';
  matchSelected = null;
  matchedPairs = new Set();
  document.getElementById('matchFeedback').textContent = 'Èªû‰∏ÄÂÄãÂñÆÂ≠óÔºåÂÜçÈªûÈÖçÂ∞çÁöÑË°®ÊÉÖÔºÅ üéØ';

  shuffle(pool).forEach(f => {
    const item = document.createElement('div');
    item.className = 'match-item';
    item.textContent = f.word;
    item.dataset.word = f.word;
    item.dataset.type = 'word';
    item.addEventListener('click', () => matchClick(item));
    wCol.appendChild(item);
  });
  shuffle(pool).forEach(f => {
    const item = document.createElement('div');
    item.className = 'match-item emoji-item';
    item.textContent = f.emoji;
    item.dataset.word = f.word;
    item.dataset.type = 'emoji';
    item.addEventListener('click', () => matchClick(item));
    eCol.appendChild(item);
  });
}

function matchClick(item) {
  if (item.classList.contains('matched')) return;

  if (!matchSelected) {
    matchSelected = item;
    item.classList.add('selected');
    if (item.dataset.type === 'word') speak(item.dataset.word);
    return;
  }
  if (matchSelected === item) {
    item.classList.remove('selected');
    matchSelected = null;
    return;
  }
  if (matchSelected.dataset.type === item.dataset.type) {
    matchSelected.classList.remove('selected');
    matchSelected = item;
    item.classList.add('selected');
    if (item.dataset.type === 'word') speak(item.dataset.word);
    return;
  }

  if (matchSelected.dataset.word === item.dataset.word) {
    const prev = matchSelected;
    prev.classList.remove('selected');
    prev.classList.add('correct');
    item.classList.add('correct');
    const f = feelings.find(x => x.word === item.dataset.word);
    speak(item.dataset.word);
    document.getElementById('matchFeedback').textContent = `‚úÖ ${f?.emoji} ${f?.word} = ${f?.zh}ÔºÅ`;
    addStars(1); bumpStreak(); addGems(1);
    setTimeout(() => {
      prev.classList.add('matched'); prev.classList.remove('correct');
      item.classList.add('matched'); item.classList.remove('correct');
    }, 600);
    matchedPairs.add(item.dataset.word);
    if (matchedPairs.size >= 6) {
      setTimeout(() => {
        document.getElementById('matchFeedback').textContent = 'üéâ ÂÖ®ÈÉ®ÈÖçÂ∞çÂÆåÊàêÔºÅÂ§™Ê£í‰∫ÜÔºÅ';
        addStars(3); doConfetti(); addGems(2);
      }, 700);
    }
  } else {
    const prev = matchSelected;
    prev.classList.add('wrong'); item.classList.add('wrong');
    resetStreak();
    document.getElementById('matchFeedback').textContent = '‚ùå ÂÜçË©¶‰∏ÄÊ¨°ÔºÅ';
    setTimeout(() => {
      prev.classList.remove('wrong', 'selected');
      item.classList.remove('wrong');
    }, 500);
  }
  matchSelected = null;
}

document.getElementById('resetMatch').addEventListener('click', initMatch);

// ===== QUIZ =====
function initQuiz() {
  quizQuestions = shuffle(feelings).map(f => {
    const others = shuffle(feelings.filter(x => x.word !== f.word)).slice(0, 3);
    return { feeling: f, options: shuffle([f, ...others]), type: Math.random() > 0.5 ? 'e2w' : 'w2e' };
  });
  quizIndex = 0; quizScore = 0; quizWrong = new Set();
  renderQuiz();
}

function renderQuiz() {
  const c = document.getElementById('quizContainer');
  if (quizIndex >= quizQuestions.length) {
    const pct = Math.round(quizScore / quizQuestions.length * 100);
    const msg = pct === 100 ? 'üèÜ Perfect! ÂÆåÁæéÔºÅ' : pct >= 75 ? 'üåü Great! ÂæàÊ£íÔºÅ' : 'üí™ Keep going! Âä†Ê≤πÔºÅ';
    c.innerHTML = `<div class="quiz-result">
      <div class="big-emoji">${pct === 100 ? 'üéâ' : pct >= 75 ? 'üåü' : 'üí™'}</div>
      <div class="result-text">${msg}</div>
      <div class="result-detail">${quizScore} / ${quizQuestions.length} Á≠îÂ∞ç</div>
      <button class="speak-btn primary" onclick="initQuiz()">üîÑ ÂÜç‰æÜ‰∏ÄÊ¨°</button>
    </div>`;
    if (pct >= 75) { addStars(5); doConfetti(); addGems(3); }
    return;
  }

  const q = quizQuestions[quizIndex];
  quizAnswered = false;
  const dots = quizQuestions.map((_, i) => `<div class="quiz-dot${i < quizIndex ? (quizWrong.has(i) ? ' wrong-dot' : ' done') : ''}${i === quizIndex ? ' current' : ''}"></div>`).join('');

  if (q.type === 'e2w') {
    c.innerHTML = `
      <div class="quiz-progress">${dots}</div>
      <div class="quiz-prompt">${q.feeling.emoji}</div>
      <div class="quiz-question">ÈÄôÊòØ‰ªÄÈ∫ºÊÑüË¶∫Ôºü</div>
      <button class="speak-btn small primary" style="margin-bottom:16px" id="quizHint">üîä ËÅΩÊèêÁ§∫</button>
      <div class="quiz-options">
        ${q.options.map(o => `<button class="quiz-option" data-word="${o.word}">${o.word}</button>`).join('')}
      </div>`;
  } else {
    c.innerHTML = `
      <div class="quiz-progress">${dots}</div>
      <div class="quiz-prompt" style="font-size:2.2rem;font-family:'Fredoka',sans-serif;font-weight:700">${q.feeling.word}</div>
      <div class="quiz-question">Âì™ÂÄãË°®ÊÉÖÁ¨¶ÂêàÔºü</div>
      <button class="speak-btn small primary" style="margin-bottom:16px" id="quizHint">üîä ËÅΩÁôºÈü≥</button>
      <div class="quiz-options">
        ${q.options.map(o => `<button class="quiz-option" data-word="${o.word}">${o.emoji} ${o.zh}</button>`).join('')}
      </div>`;
  }

  // Don't auto-speak ‚Äî iOS blocks audio without a direct user gesture.
  // The hint button below lets the user trigger it.

  // Hint button
  c.querySelector('#quizHint')?.addEventListener('click', () => speak(q.feeling.word));

  c.querySelectorAll('.quiz-option').forEach(btn => {
    btn.addEventListener('click', () => {
      if (quizAnswered) return;
      quizAnswered = true;
      const correct = btn.dataset.word === q.feeling.word;
      if (correct) {
        btn.classList.add('correct-answer');
        quizScore++; addStars(1); bumpStreak(); addGems(1);
        speak('Great job!');
      } else {
        btn.classList.add('wrong-answer');
        quizWrong.add(quizIndex);
        resetStreak();
        c.querySelector(`[data-word="${q.feeling.word}"]`)?.classList.add('correct-answer');
        speak(q.feeling.word);
      }
      setTimeout(() => { quizIndex++; renderQuiz(); }, 1300);
    });
  });
}

// ===== SIGHT WORDS =====
let sightEarned = new Set();

function initSightWords() {
  const area = document.getElementById('sightWordsArea');
  area.textContent = '';

  sightWords.forEach((sw, i) => {
    const card = document.createElement('div');
    card.className = 'sight-word-card';
    card.style.borderLeft = `5px solid ${sightColors[i % sightColors.length]}`;

    const info = document.createElement('div');
    const wordEl = document.createElement('div');
    wordEl.className = 'sight-word-text';
    wordEl.textContent = sw.word;
    const zhEl = document.createElement('div');
    zhEl.className = 'sight-word-chinese';
    zhEl.textContent = `${sw.zh} ‚Äî "${sw.sentence}"`;
    info.appendChild(wordEl);
    info.appendChild(zhEl);

    const playIcon = document.createElement('div');
    playIcon.className = 'play-icon';
    playIcon.textContent = 'üîä';

    // Create confirm button immediately (disabled)
    const btn = document.createElement('button');
    btn.className = 'sight-confirm';
    btn.textContent = 'üé§ ÊàëË∑üËëóÂî∏‰∫ÜÔºÅ+‚ö°';
    btn.disabled = true;
    btn.style.opacity = '0.4';

    if (sightEarned.has(sw.word)) {
      playIcon.textContent = '‚úÖ';
      card.classList.add('earned');
    } else {
      info.appendChild(btn);
    }

    card.appendChild(info);
    card.appendChild(playIcon);

    card.addEventListener('click', () => {
      if (sightEarned.has(sw.word)) {
        speakWordThenSentence(sw.word, sw.sentence);
        return;
      }
      card.classList.add('speaking');
      speakWordThenSentence(sw.word, sw.sentence);
      // Enable button after audio plays
      setTimeout(() => {
        card.classList.remove('speaking');
        if (sightEarned.has(sw.word)) return;
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.animation = 'fadeIn 0.3s ease';
      }, 2500);
    });

    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      sightEarned.add(sw.word);
      addGems(1);
      btn.remove();
      card.classList.add('earned');
      playIcon.textContent = '‚úÖ';
    });
    area.appendChild(card);
  });

  const extra = document.createElement('div');
  extra.className = 'sentence-practice';
  extra.style.marginTop = '8px';
  extra.innerHTML = `
    <h3>üìå Weekly Quote ÊØèÈÄ±‰Ω≥Âè•</h3>
    <div class="sentence-display" style="font-size:1.3rem">"Life is better when you are happy." üòä</div>
    <button class="speak-btn primary small" onclick="speak('Life is better when you are happy.')">üîä Listen</button>
    <div style="margin-top:18px">
      <h3>üéµ Song & Rhyme</h3>
      <div class="sentence-display" style="font-size:1.4rem;margin-top:8px">‚ú® Hakuna Matata ‚ú®</div>
      <button class="speak-btn secondary small" onclick="speak('Hakuna Matata! It means no worries!')">üîä Listen</button>
    </div>`;
  area.appendChild(extra);
}

// ===== MINE =====
// Mountain shape: each row = { width, tier } ‚Äî triangle from peak to base
const mountainShape = [
  { width: 24, tier: 0 },  // mountain top surface ‚Äî trees & animals
  { width: 28, tier: 1 },  // dirt/wood
  { width: 34, tier: 1 },
  { width: 38, tier: 1 },
  { width: 42, tier: 2 },  // stone/coal
  { width: 46, tier: 2 },
  { width: 50, tier: 2 },
  { width: 50, tier: 3 },  // iron/copper/redstone/lapis
  { width: 50, tier: 3 },
  { width: 50, tier: 3 },
  { width: 50, tier: 4 },  // gold/emerald
  { width: 50, tier: 4 },
  { width: 50, tier: 5 },  // diamond/amethyst/obsidian
  { width: 50, tier: 5 },
];

let mineData = []; // 2D array: each cell = { block, mined, tier, el } or null

function rollBlockForTier(tier) {
  const pool = blocks.filter(b => b.tier === tier);
  const totalWeight = pool.reduce((s, b) => s + b.weight, 0);
  let r = Math.random() * totalWeight;
  for (const b of pool) {
    r -= b.weight;
    if (r <= 0) return b;
  }
  return pool[pool.length - 1];
}

function isExposed(row, col) {
  if (mineData[row][col] === null || mineData[row][col].mined) return false;
  // Check 4 neighbors ‚Äî if any is outside mountain or mined, this cell is exposed
  const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
  for (const [dr, dc] of dirs) {
    const nr = row + dr, nc = col + dc;
    if (nr < 0 || nr >= mineData.length) return true; // top/bottom edge
    if (nc < 0 || nc >= mineData[nr].length) return true; // side edge
    if (mineData[nr][nc] === null) return true; // outside mountain shape
    if (mineData[nr][nc].mined) return true; // adjacent to mined cell
    if (mineData[nr][nc].tier === 0) return true; // tree row counts as open
  }
  return false;
}

function updateExposure() {
  const maxTier = pickaxes[getEffectivePickaxeLevel()].maxTier;
  for (let r = 0; r < mineData.length; r++) {
    for (let c = 0; c < mineData[r].length; c++) {
      const cell = mineData[r][c];
      if (!cell || cell.mined || cell.tier === 0) continue;
      const exposed = isExposed(r, c);
      const locked = cell.tier > maxTier;
      cell.el.classList.toggle('unexposed', !exposed);
      cell.el.classList.toggle('locked', exposed && locked);
    }
  }
}

function resetCellProgress(el) {
  const fill = el.querySelector('.mine-progress-fill');
  if (fill) fill.style.width = '0%';
}

function showMineResult(msg, toolBroke) {
  const el = document.getElementById('mineResult');
  el.textContent = msg;
  el.classList.remove('tool-broke');
  if (toolBroke) {
    // Force reflow to restart animation
    void el.offsetWidth;
    el.classList.add('tool-broke');
  }
}

let mineHoldRAF = null;
let mineHoldTarget = null;
let mineHoldStart = 0;

function getMineHoldDuration(cellData) {
  if (cellData.animal) {
    const sword = getEffectiveSword();
    return sword ? sword.holdTime : 2000;
  }
  if (cellData.tier === 0) {
    const tool = getEquippedTool();
    if (!tool || !tool.woodBonus) return 2000; // bare hands or non-axe tool
    return tool.woodBonus >= 3 ? 600 : 1000; // iron+ axe : wood/stone axe
  }
  const pickLevel = getEffectivePickaxeLevel();
  const pick = pickaxes[pickLevel];
  if (cellData.tier > pick.maxTier) return Infinity;
  const tierDiff = cellData.tier - pickLevel;
  if (tierDiff <= 0) return 800;
  return 800 + tierDiff * 600;
}

function startMineHold(cellData) {
  if (cellData.mined) return;
  // Auto-deselect palette item when starting to mine/attack
  if (buildSelected) { buildSelected = null; refreshBuildPalette(); }
  const duration = getMineHoldDuration(cellData);
  if (duration === Infinity) {
    playLockedSfx();
    const needed = pickaxes.find(p => p.maxTier >= cellData.tier && p.id !== 'hands');
    const neededName = needed ? needed.name : 'Êõ¥Â•ΩÁöÑÂ∑•ÂÖ∑';
    showMineResult('üîí ÈúÄË¶Å ' + neededName + ' ‰ª•‰∏äÊâçËÉΩÊåñÁ¨¨ ' + cellData.tier + ' Â±§ÔºÅ', false);
    return;
  }

  let bar = cellData.el.querySelector('.mine-progress');
  if (!bar) {
    bar = document.createElement('div');
    bar.className = 'mine-progress';
    const fill = document.createElement('div');
    fill.className = 'mine-progress-fill';
    bar.appendChild(fill);
    cellData.el.appendChild(bar);
  }
  const fill = bar.querySelector('.mine-progress-fill');
  fill.style.width = '0%';

  cellData.el.classList.add('mining');
  mineHoldStart = Date.now();
  mineHoldTarget = { cellData, duration, fill };

  function updateProgress() {
    if (!mineHoldTarget) return;
    const elapsed = Date.now() - mineHoldStart;
    const pct = Math.min(100, (elapsed / duration) * 100);
    fill.style.width = pct + '%';
    if (elapsed >= duration) {
      completeMineHold();
      return;
    }
    mineHoldRAF = requestAnimationFrame(updateProgress);
  }
  mineHoldRAF = requestAnimationFrame(updateProgress);
}

function completeMineHold() {
  if (!mineHoldTarget) return;
  const { cellData } = mineHoldTarget;
  cancelMineHold(false);

  if (cellData.animal) {
    attackAnimal(cellData);
  } else if (cellData.tier === 0) {
    chopTree(cellData);
  } else {
    for (let r = 0; r < mineData.length; r++) {
      for (let c = 0; c < mineData[r].length; c++) {
        if (mineData[r][c] === cellData) {
          mineMountainCell(r, c, cellData);
          return;
        }
      }
    }
  }
}

function cancelMineHold(resetBar) {
  if (resetBar === undefined) resetBar = true;
  if (mineHoldRAF) cancelAnimationFrame(mineHoldRAF);
  mineHoldRAF = null;
  if (mineHoldTarget) {
    const cd = mineHoldTarget.cellData;
    cd.el.classList.remove('mining');
    if (resetBar) mineHoldTarget.fill.style.width = '0%';
    // Quick tap ‚Üí show block/animal info
    const elapsed = Date.now() - mineHoldStart;
    if (resetBar && elapsed < 250 && !cd.mined) {
      let info = '';
      if (cd.animal) info = cd.animal.emoji + ' ' + cd.animal.name;
      else if (cd.block) info = cd.block.emoji + ' ' + cd.block.name;
      if (info) showMineResult(info, false);
    }
  }
  mineHoldTarget = null;
}

let _mineDragAC = null;
function initMine() {
  if (_mineDragAC) _mineDragAC.abort();
  _mineDragAC = new AbortController();
  const area = document.getElementById('mineArea');
  const pick = pickaxes[getEffectivePickaxeLevel()];
  area.textContent = '';
  mineData = [];

  // Header
  const header = document.createElement('div');
  header.className = 'mine-header';
  const h3 = document.createElement('h3');
  h3.className = 'section-title';
  h3.textContent = '‚õèÔ∏è ÊåñÁ§¶/Âª∫ÈÄ† Mine & Build';
  const toolChips = document.createElement('div');
  toolChips.className = 'tool-slots';
  toolChips.id = 'toolChips';
  renderToolChips(toolChips);
  header.appendChild(h3);
  header.appendChild(toolChips);
  area.appendChild(header);

  // Result (above mountain so it's visible on short screens)
  const result = document.createElement('div');
  result.className = 'mine-result';
  result.id = 'mineResult';
  area.appendChild(result);

  // Mountain
  const mountain = document.createElement('div');
  mountain.className = 'mountain';
  const maxWidth = 50;

  const restoring = savedMineGrid && savedMineGrid.length > 0;

  mountainShape.forEach((rowDef, r) => {
    const rowEl = document.createElement('div');
    rowEl.className = 'mountain-row';
    const rowData = [];

    // Pad to maxWidth with nulls for consistent indexing
    const offset = Math.floor((maxWidth - rowDef.width) / 2);
    for (let c = 0; c < maxWidth; c++) {
      if (c < offset || c >= offset + rowDef.width) {
        rowData.push(null);
        const spacer = document.createElement('div');
        spacer.className = 'mine-cell spacer';
        rowEl.appendChild(spacer);
        continue;
      }

      const cellEl = document.createElement('div');
      cellEl.className = 'mine-cell';

      const saved = (restoring && savedMineGrid[r] && savedMineGrid[r][c]) ? savedMineGrid[r][c] : null;

      if (saved) {
        // Restore from saved data
        const cellData = { tier: saved.t, mined: !!saved.m, block: null, animal: null, el: cellEl };
        if (saved.b) cellData.block = blocks.find(b => b.id === saved.b) || null;
        if (saved.a) {
          cellData.animal = (saved.h ? hostileMobs : animals).find(a => a.id === saved.a) || null;
        }
        if (saved.te) cellData.treeEmoji = saved.te;

        if (cellData.mined) {
          cellEl.classList.add('mined');
          if (cellData.animal) cellEl.classList.add('animal');
          if (saved.te) cellEl.classList.add('tree');
          if (saved.h) cellEl.classList.add('hostile');
        } else if (cellData.animal) {
          cellEl.classList.add('animal');
          if (cellData.animal.hostile) cellEl.classList.add('hostile');
          cellEl.textContent = cellData.animal.emoji;
        } else if (saved.te) {
          cellEl.classList.add('tree');
          cellEl.textContent = saved.te;
        } else {
          cellEl.classList.add('tier' + cellData.tier);
        }
        rowData.push(cellData);
      } else if (!restoring) {
        // Fresh generation
        const isSurface = rowDef.tier === 0;
        // Ledge: cell on the slope edge where the row above has no block
        const isLedge = !isSurface && (r === 0 || mineData[r - 1][c] === null);

        if (isSurface || isLedge) {
          const roll = Math.random();
          if (roll < 0.25) {
            const animal = animals[Math.floor(Math.random() * animals.length)];
            cellEl.classList.add('animal');
            cellEl.textContent = animal.emoji;
            rowData.push({ tier: 0, mined: false, block: null, animal: animal, el: cellEl });
          } else if (roll < 0.40) {
            const mob = hostileMobs[Math.floor(Math.random() * hostileMobs.length)];
            cellEl.classList.add('animal', 'hostile');
            cellEl.textContent = mob.emoji;
            rowData.push({ tier: 0, mined: false, block: null, animal: mob, el: cellEl });
          } else {
            cellEl.classList.add('tree');
            const treeEmoji = Math.random() > 0.5 ? 'üå≥' : 'üå≤';
            cellEl.textContent = treeEmoji;
            const woodBlock = blocks.find(b => b.id === 'wood');
            rowData.push({ tier: 0, mined: false, block: woodBlock, treeEmoji, el: cellEl });
          }
        } else {
          const block = rollBlockForTier(rowDef.tier);
          cellEl.classList.add('tier' + rowDef.tier);
          rowData.push({ tier: rowDef.tier, mined: false, block, el: cellEl });
        }
      } else {
        // Restoring but saved cell is null (shouldn't happen for non-spacers)
        rowData.push(null);
      }

      // Hold-to-mine events (touch + mouse)
      const holdData = rowData[rowData.length - 1];
      if (holdData) bindMineHoldEvents(cellEl, holdData);

      // Build-mode click: place/remove blocks on mined cells
      ((row, col, cd) => {
        cellEl.addEventListener('click', () => {
          if (!cd || !cd.mined) return;
          const key = row + ',' + col;
          const existing = buildGrid[key];
          if (existing) {
            // Remove placed block
            delete buildGrid[key];
            inventory[existing] = (inventory[existing] || 0) + 1;
            cd.el.textContent = '';
            cd.el.classList.remove('build-placed');
            cd.el.classList.add('mined');
            playRemoveSfx();
            saveGame();
            refreshBuildPalette();
            return;
          }
          if (buildSelected === '_player') {
            buildPlayerPos = { r: row, c: col };
            document.querySelectorAll('.mine-cell.build-player').forEach(el => {
              el.classList.remove('build-player');
              el.textContent = '';
            });
            cd.el.textContent = 'üßç';
            cd.el.classList.add('build-player');
            playPlaceSfx();
            return;
          }
          if (!buildSelected || buildSelected === '_player') return;
          if (getBlockCount(buildSelected) <= 0) return;
          const doPlace = () => {
            buildGrid[key] = buildSelected;
            inventory[buildSelected] = (inventory[buildSelected] || 1) - 1;
            if (inventory[buildSelected] <= 0) delete inventory[buildSelected];
            const b = blocks.find(x => x.id === buildSelected);
            cd.el.textContent = b ? b.emoji : '?';
            cd.el.classList.remove('mined');
            cd.el.classList.add('build-placed');
            playPlaceSfx();
            saveGame();
            if (getBlockCount(buildSelected) <= 0) buildSelected = null;
            refreshBuildPalette();
          };
          rollLearnGate(doPlace);
        });
      })(r, c, rowData[rowData.length - 1]);

      rowEl.appendChild(cellEl);
    }

    mineData.push(rowData);
    mountain.appendChild(rowEl);
  });

  const mountainScroll = document.createElement('div');
  mountainScroll.className = 'mountain-scroll';
  mountainScroll.appendChild(mountain);
  const scrollHint = document.createElement('div');
  scrollHint.className = 'mountain-scroll-hint';
  mountainScroll.appendChild(scrollHint);
  mountainScroll.addEventListener('scroll', () => {
    if (mountainScroll.scrollLeft > 10) scrollHint.style.display = 'none';
  }, { passive: true });

  // Mouse drag-to-scroll
  let dragState = null;
  mountainScroll.addEventListener('mousedown', (e) => {
    if (e.target.closest('.mine-cell:not(.spacer):not(.mined)')) return;
    dragState = { startX: e.pageX, scrollL: mountainScroll.scrollLeft };
    mountainScroll.style.cursor = 'grabbing';
  });
  document.addEventListener('mousemove', (e) => {
    if (!dragState) return;
    mountainScroll.scrollLeft = dragState.scrollL - (e.pageX - dragState.startX);
  }, { signal: _mineDragAC.signal });
  document.addEventListener('mouseup', () => {
    if (dragState) { mountainScroll.style.cursor = ''; dragState = null; }
  }, { signal: _mineDragAC.signal });

  // Wrap with arrow buttons
  const scrollWrap = document.createElement('div');
  scrollWrap.className = 'mountain-scroll-wrap';
  const leftBtn = document.createElement('button');
  leftBtn.className = 'mountain-arrow mountain-arrow-left';
  leftBtn.textContent = '‚óÄ';
  const rightBtn = document.createElement('button');
  rightBtn.className = 'mountain-arrow mountain-arrow-right';
  rightBtn.textContent = '‚ñ∂';
  const scrollStep = 120;
  leftBtn.addEventListener('click', () => {
    mountainScroll.scrollBy({ left: -scrollStep, behavior: 'smooth' });
  });
  rightBtn.addEventListener('click', () => {
    mountainScroll.scrollBy({ left: scrollStep, behavior: 'smooth' });
  });
  scrollWrap.appendChild(leftBtn);
  scrollWrap.appendChild(mountainScroll);
  scrollWrap.appendChild(rightBtn);

  area.appendChild(scrollWrap);

  // Build palette (sticky bottom bar)
  const sidebar = document.createElement('div');
  sidebar.className = 'mine-sidebar';
  sidebar.id = 'mineBuildPalette';
  renderMineBuildPalette(sidebar);
  area.appendChild(sidebar);

  // Build action buttons (screenshot, clear)
  const buildActionsWrap = document.createElement('div');
  buildActionsWrap.id = 'mineBuildActions';
  renderMineBuildActions(buildActionsWrap);
  area.appendChild(buildActionsWrap);

  // Restore placed blocks and player from buildGrid on existing mined cells
  for (let mr = 0; mr < mineData.length; mr++) {
    for (let mc = 0; mc < mineData[mr].length; mc++) {
      const cd = mineData[mr][mc];
      if (!cd) continue;
      const key = mr + ',' + mc;
      const placedId = buildGrid[key];
      if (placedId && cd.mined) {
        const b = blocks.find(x => x.id === placedId);
        cd.el.textContent = b ? b.emoji : '?';
        cd.el.classList.remove('mined');
        cd.el.classList.add('build-placed');
      }
      if (buildPlayerPos && buildPlayerPos.r === mr && buildPlayerPos.c === mc && cd.mined) {
        cd.el.textContent = 'üßç';
        cd.el.classList.add('build-player');
      }
    }
  }

  // Refresh button
  const refreshBtn = document.createElement('button');
  refreshBtn.className = 'mine-refresh';
  refreshBtn.id = 'mineRefresh';
  refreshBtn.textContent = 'üîÑ Êñ∞Âú∞Âúñ New Map';
  refreshBtn.addEventListener('click', () => {
    const placedCount = Object.keys(buildGrid).length;
    const msg = placedCount > 0
      ? 'Á¢∫ÂÆöË¶ÅÁî¢ÁîüÊñ∞Âú∞ÂúñÂóéÔºüÂ∑≤ÊîæÁΩÆÁöÑ ' + placedCount + ' ÂÄãÊñπÂ°äÊúÉÈÄÄÂõûËÉåÂåÖ„ÄÇ'
      : 'Á¢∫ÂÆöË¶ÅÁî¢ÁîüÊñ∞Âú∞ÂúñÂóéÔºü';
    if (!confirm(msg)) return;
    Object.values(buildGrid).forEach(id => {
      inventory[id] = (inventory[id] || 0) + 1;
    });
    buildGrid = {};
    buildPlayerPos = null;
    savedMineGrid = null; // force fresh generation
    saveGame();
    initMine();
  });
  area.appendChild(refreshBtn);

  savedMineGrid = null; // consumed ‚Äî future initMine calls generate fresh
  updateExposure();
  updateMineRefreshBtn();
}

function renderMineBuildPalette(container) {
  container.textContent = '';

  // Placeable block items
  const placeable = blocks.filter(b => getBlockCount(b.id) > 0);
  if (placeable.length === 0 && !buildSelected) {
    const hint = document.createElement('div');
    hint.style.cssText = 'color:#FFF;font-size:0.6rem;padding:4px;opacity:0.7;text-align:center;';
    hint.textContent = '‚õèÔ∏è';
    container.appendChild(hint);
  }
  placeable.forEach(b => {
    const item = document.createElement('div');
    item.className = 'mine-sidebar-item' + (buildSelected === b.id ? ' selected' : '');
    item.appendChild(document.createTextNode(b.emoji));
    const countSpan = document.createElement('span');
    countSpan.className = 'count';
    countSpan.textContent = getBlockCount(b.id);
    item.appendChild(countSpan);
    item.title = b.name + ' (' + getBlockCount(b.id) + ')';
    item.addEventListener('click', () => {
      buildSelected = (buildSelected === b.id) ? null : b.id;
      if (buildSelected === b.id) showMineResult(b.emoji + ' ' + b.name + ' (' + getBlockCount(b.id) + 'ÂÄã)', false);
      refreshBuildPalette();
    });
    container.appendChild(item);
  });

  // Player avatar button
  const playerItem = document.createElement('div');
  playerItem.className = 'mine-sidebar-item' + (buildSelected === '_player' ? ' selected' : '');
  playerItem.appendChild(document.createTextNode('üßç'));
  playerItem.title = 'ÊîæÁΩÆËá™Â∑±';
  playerItem.addEventListener('click', () => {
    buildSelected = (buildSelected === '_player') ? null : '_player';
    if (buildSelected === '_player') showMineResult('üßç ÊîæÁΩÆËá™Â∑±', false);
    refreshBuildPalette();
  });
  container.appendChild(playerItem);
}

function renderMineBuildActions(container) {
  container.textContent = '';
  const totalPlaced = Object.keys(buildGrid).length;
  const actions = document.createElement('div');
  actions.className = 'build-actions';
  if (totalPlaced > 0) {
    const info = document.createElement('span');
    info.style.cssText = 'font-size:0.75rem;color:var(--text-secondary);margin-right:8px;';
    info.textContent = 'Â∑≤Êîæ ' + totalPlaced + ' ÂÄãÊñπÂ°ä';
    actions.appendChild(info);
  }
  const screenshotBtn = document.createElement('button');
  screenshotBtn.textContent = 'üì∏ Â≠òÁÖßÁâá';
  screenshotBtn.addEventListener('click', () => screenshotBuild());
  actions.appendChild(screenshotBtn);
  if (totalPlaced > 0) {
    const clearBtn = document.createElement('button');
    clearBtn.textContent = 'üóëÔ∏è Ê∏ÖÈô§Âª∫ÈÄ†';
    clearBtn.addEventListener('click', () => {
      if (!confirm('Á¢∫ÂÆöË¶ÅÊ∏ÖÈô§ÊâÄÊúâÊîæÁΩÆÁöÑÊñπÂ°äÔºüÊñπÂ°äÊúÉÈÄÄÂõûËÉåÂåÖ„ÄÇ')) return;
      Object.values(buildGrid).forEach(id => {
        inventory[id] = (inventory[id] || 0) + 1;
      });
      buildGrid = {};
      buildPlayerPos = null;
      saveGame();
      initMine();
    });
    actions.appendChild(clearBtn);
  }
  container.appendChild(actions);
}

function refreshBuildPalette() {
  const el = document.getElementById('mineBuildPalette');
  if (el) renderMineBuildPalette(el);
  const act = document.getElementById('mineBuildActions');
  if (act) renderMineBuildActions(act);
  updateGhostHints();
}

function updateGhostHints() {
  const selectedBlock = buildSelected && buildSelected !== '_player' ? blocks.find(b => b.id === buildSelected) : null;
  const hintEmoji = selectedBlock ? selectedBlock.emoji : '';
  for (let r = 0; r < mineData.length; r++) {
    for (let c = 0; c < mineData[r].length; c++) {
      const cd = mineData[r][c];
      if (!cd) continue;
      const key = r + ',' + c;
      if (cd.mined && !buildGrid[key]) {
        if (hintEmoji) {
          cd.el.classList.add('ghost');
          cd.el.setAttribute('data-hint', hintEmoji);
        } else {
          cd.el.classList.remove('ghost');
          cd.el.removeAttribute('data-hint');
        }
      } else {
        cd.el.classList.remove('ghost');
        cd.el.removeAttribute('data-hint');
      }
    }
  }
}

function attackAnimal(cellData) {
  if (cellData.mined) return;
  const animal = cellData.animal;
  const activeSword = getEffectiveSword();
  // Hostile mobs require a real weapon (not bare hands)
  if (animal.hostile && (!activeSword || activeSword.id === 'hands')) {
    playLockedSfx();
    resetCellProgress(cellData.el);
    showMineResult('‚öîÔ∏è ' + animal.emoji + ' ' + animal.name + ' Â§™Âç±Èö™‰∫ÜÔºÅÈúÄË¶ÅË£ùÂÇôÊ≠¶Âô®ÊâçËÉΩÊîªÊìäÔºÅ', false);
    return;
  }
  if (!isCheat && gems < 1) {
    playLockedSfx();
    resetCellProgress(cellData.el);
    document.getElementById('mineResult').textContent = '‚ö° È´îÂäõ‰∏çË∂≥ÔºÅÂéªÁ≠îÈ°åË£úÂÖÖÂêßÔºÅ';
    return;
  }
  playMineSfx(1);
  if (!isCheat) gems--;
  updateGemDisplay();
  cellData.mined = true;
  cellData.el.classList.add('mined');
  cellData.el.textContent = '';
  const brokeName = useTool(activeSword);

  let msg = animal.emoji + ' ÊìäÊïó' + animal.name + 'ÔºÅÁç≤ÂæóÔºö';
  animal.drops.forEach(drop => {
    const count = drop.min + Math.floor(Math.random() * (drop.max - drop.min + 1));
    addBlock(drop.id, count);
    const b = blocks.find(x => x.id === drop.id);
    msg += ' ' + b.emoji + b.name + ' x' + count;
  });
  if (brokeName) msg += '\nüí• ' + brokeName + ' Â£ûÊéâ‰∫ÜÔºÅ';

  showMineResult(msg, !!brokeName);
  if (brokeName) refreshToolChips();
  updateExposure();
  updateMineRefreshBtn();
  refreshBuildPalette();
  saveGame();
}

function chopTree(cellData) {
  if (cellData.mined) return;
  if (!isCheat && gems < 1) {
    playLockedSfx();
    resetCellProgress(cellData.el);
    document.getElementById('mineResult').textContent = '‚ö° È´îÂäõ‰∏çË∂≥ÔºÅÂéªÁ≠îÈ°åË£úÂÖÖÂêßÔºÅ';
    return;
  }
  playMineSfx(1);
  if (!isCheat) gems--;
  updateGemDisplay();
  cellData.mined = true;
  cellData.el.classList.add('mined');
  cellData.el.textContent = '';
  const activeTool = getEquippedTool();
  const isAxe = activeTool && activeTool.woodBonus;
  const woodCount = isAxe ? activeTool.woodBonus : 1;
  addBlock('wood', woodCount);
  const stickDrop = Math.random() < 0.5 ? 1 : 0;
  if (stickDrop) addBlock('stick', stickDrop);
  const brokeName = isAxe ? useTool(activeTool) : null;
  const axeMsg = woodCount > 1 ? ` (ü™ì ÊñßÈ†≠Âä†Êàê x${woodCount})` : '';
  const stickMsg = stickDrop ? ` + ü•¢ Êú®Ê£ç x${stickDrop}` : '';
  const breakMsg = brokeName ? `\nüí• ${brokeName} Â£ûÊéâ‰∫ÜÔºÅ` : '';
  showMineResult(`ü™µ Êú®È†≠ x${woodCount}${stickMsg}${axeMsg}${breakMsg}`, !!brokeName);
  if (brokeName) refreshToolChips();
  updateExposure();
  applyAnimalGravity();
  updateMineRefreshBtn();
  refreshBuildPalette();
  saveGame();
}

function mineMountainCell(row, col, cellData) {
  if (cellData.mined) return;

  const maxTier = pickaxes[getEffectivePickaxeLevel()].maxTier;
  if (cellData.tier > maxTier) {
    playLockedSfx();
    document.getElementById('mineResult').textContent = `üîí ÈúÄË¶ÅÊõ¥Â•ΩÁöÑÂ∑•ÂÖ∑ÊâçËÉΩÊåñÁ¨¨ ${cellData.tier} Â±§ÔºÅ`;
    return;
  }

  if (!isExposed(row, col)) return;

  if (!isCheat && gems < 1) {
    playLockedSfx();
    resetCellProgress(cellData.el);
    document.getElementById('mineResult').textContent = '‚ö° È´îÂäõ‰∏çË∂≥ÔºÅÂéªÁ≠îÈ°åË£úÂÖÖÂêßÔºÅ';
    return;
  }

  playMineSfx(cellData.tier);
  if (!isCheat) gems--;
  updateGemDisplay();
  cellData.mined = true;
  cellData.el.classList.add('mined');
  cellData.el.textContent = '';
  const reveal = document.createElement('span');
  reveal.className = 'block-reveal';
  reveal.textContent = cellData.block.emoji;
  cellData.el.appendChild(reveal);
  // Fade out emoji after animation (only if cell is still mined ‚Äî animal gravity may have claimed it)
  setTimeout(() => { if (cellData.mined && !cellData.animal) cellData.el.textContent = ''; }, 800);

  addBlock(cellData.block.id);

  const activePick = getEquippedTool();
  const brokeName = useTool(activePick);

  const b = cellData.block;
  const rarity = b.tier >= 4 ? ' ‚ú® Á®ÄÊúâÔºÅ' : b.tier >= 3 ? ' ‰∏çÈåØÔºÅ' : '';
  const breakMsg = brokeName ? `\nüí• ${brokeName} Â£ûÊéâ‰∫ÜÔºÅ` : '';
  showMineResult(`${b.emoji} ÊåñÂà∞ ${b.name}ÔºÅ${rarity}${breakMsg}ÔºàÊìÅÊúâ ${getBlockCount(b.id)} ÂÄãÔºâ`, !!brokeName);

  if (brokeName) refreshToolChips();
  if (b.tier >= 4) doConfetti();
  updateExposure();
  applyAnimalGravity();
  updateMineRefreshBtn();
  refreshBuildPalette();
  saveGame();
}

function bindMineHoldEvents(cellEl, cellData) {
  // Abort previous listeners on this element to prevent duplicates (e.g. animal gravity)
  if (cellEl._mineAC) cellEl._mineAC.abort();
  const ac = new AbortController();
  cellEl._mineAC = ac;
  const sig = { signal: ac.signal };
  const startHold = (e) => { if (!cellData.mined) e.preventDefault(); startMineHold(cellData); };
  const endHold = () => cancelMineHold();
  cellEl.addEventListener('mousedown', startHold, sig);
  cellEl.addEventListener('mouseup', endHold, sig);
  cellEl.addEventListener('mouseleave', endHold, sig);
  cellEl.addEventListener('touchstart', startHold, { passive: false, ...sig });
  cellEl.addEventListener('touchend', endHold, sig);
  cellEl.addEventListener('touchcancel', endHold, sig);
}

function applyAnimalGravity() {
  // After mining, check if any animals/mobs lost their ground support ‚Äî they fall to the next solid block
  let changed = false;
  for (let r = 0; r < mineData.length; r++) {
    for (let c = 0; c < mineData[r].length; c++) {
      const cell = mineData[r][c];
      if (!cell || cell.mined || !cell.animal) continue;
      // Check immediate ground below
      if (r >= mineData.length - 1) continue; // bottom edge = supported
      const below = mineData[r + 1] ? mineData[r + 1][c] : null;
      if (below && !below.mined) continue; // solid ground directly below
      if (!below) continue; // null = outside mountain shape, ledge edge

      // Ground below is mined ‚Äî scan downward for first solid block
      let landingRow = -1;
      for (let sr = r + 1; sr < mineData.length; sr++) {
        const scanCell = mineData[sr] ? mineData[sr][c] : null;
        if (!scanCell) break; // fell off mountain shape
        if (!scanCell.mined) { landingRow = sr; break; } // found solid ground
      }

      changed = true;
      const animal = cell.animal;
      const oldEl = cell.el;

      // Clear old position
      oldEl.style.transition = 'transform 0.3s, opacity 0.3s';
      oldEl.style.transform = 'translateY(20px)';
      oldEl.style.opacity = '0';
      cell.mined = true;
      cell.animal = null;
      const capturedOldEl = oldEl;
      setTimeout(() => {
        capturedOldEl.textContent = '';
        capturedOldEl.style.transform = '';
        capturedOldEl.style.opacity = '';
        capturedOldEl.classList.add('mined');
        capturedOldEl.classList.remove('animal', 'hostile');
      }, 350);

      if (landingRow === -1) {
        // Fell off the bottom ‚Äî animal disappears, no drops
        showMineResult(animal.emoji + ' ' + animal.name + ' Êéâ‰∏ãÂ±±‰∫ÜÔºÅ', false);
        continue;
      }

      // Land on the cell ABOVE the solid block (the mined gap just above it)
      // If landingRow - 1 === r, the animal stays at r (shouldn't happen since below was mined)
      const destRow = landingRow - 1;
      if (destRow <= r) continue; // no actual fall distance

      const destCell = mineData[destRow][c];
      if (!destCell || !destCell.mined) continue; // safety check

      // Return build-placed block to inventory if animal lands on it
      const destKey = destRow + ',' + c;
      if (buildGrid[destKey]) {
        inventory[buildGrid[destKey]] = (inventory[buildGrid[destKey]] || 0) + 1;
        delete buildGrid[destKey];
      }

      // Move animal into destination cell
      destCell.mined = false;
      destCell.animal = animal;
      destCell.tier = 0;
      destCell.block = null;
      const destEl = destCell.el;
      destEl.classList.remove('mined');
      destEl.classList.add('animal');
      if (animal.hostile) destEl.classList.add('hostile');
      destEl.textContent = animal.emoji;

      // Pop-in animation on new cell
      setTimeout(() => {
        destEl.style.transition = 'transform 0.25s cubic-bezier(0.34,1.56,0.64,1)';
        destEl.style.transform = 'scale(1.3)';
        setTimeout(() => { destEl.style.transform = ''; }, 250);
      }, 380);

      // Bind fresh hold-to-mine events on new cell
      bindMineHoldEvents(destEl, destCell);

      showMineResult(animal.emoji + ' ' + animal.name + ' Êéâ‰∏ã‰æÜ‰∫ÜÔºÅÈÇÑÊ¥ªËëóÔºÅ', false);
    }
  }
  if (changed) updateExposure();
}

function updateMineRefreshBtn() {
  const btn = document.getElementById('mineRefresh');
  if (btn) btn.disabled = !isCheat && gems < 1;
}

function renderToolChips(container) {
  container.textContent = '';
  const tool = getEquippedTool();
  const weapon = getEquippedWeapon();

  const slots = [
    { category: 'Â∑•ÂÖ∑', equip: tool, fallbackEmoji: '‚úã', fallbackName: 'Êâã', type: 'tool' },
    { category: 'Ê≠¶Âô®', equip: weapon, fallbackEmoji: '‚úã', fallbackName: 'Êâã', type: 'weapon' },
  ];

  slots.forEach(s => {
    const slot = document.createElement('div');
    slot.className = 'tool-slot';
    const label = document.createElement('div');
    label.className = 'tool-slot-label';
    label.textContent = s.category;
    const emoji = document.createElement('div');
    emoji.className = 'tool-slot-emoji';
    emoji.textContent = s.equip ? s.equip.emoji : s.fallbackEmoji;
    const name = document.createElement('div');
    name.className = 'tool-slot-name';
    name.textContent = s.equip ? s.equip.name : s.fallbackName;
    slot.appendChild(label);
    slot.appendChild(emoji);
    slot.appendChild(name);
    if (s.equip && s.equip.durability !== Infinity) {
      const cur = toolDurability[s.equip.id] || s.equip.durability;
      const pct = (cur / s.equip.durability) * 100;
      const barColor = pct > 50 ? '#00B894' : pct > 20 ? '#FDCB6E' : '#FF6B6B';
      const bar = document.createElement('div');
      bar.style.cssText = 'position:absolute;bottom:2px;left:6px;right:6px;height:3px;border-radius:2px;background:rgba(0,0,0,0.15);';
      const fill = document.createElement('div');
      fill.style.cssText = `height:100%;width:${pct}%;border-radius:2px;background:${barColor};transition:width 0.3s;`;
      bar.appendChild(fill);
      slot.appendChild(bar);
    }
    slot.addEventListener('click', (e) => { e.stopPropagation(); openToolPicker(slot, s.type); });
    container.appendChild(slot);
  });
}

function openToolPicker(chipEl, type) {
  // type: 'tool' or 'weapon'
  closeToolPicker();

  const selKey = type;
  const currentId = selectedTools[selKey]; // null = bare hands

  // Build available items: always start with bare hands
  const options = [{ id: 'hands', name: 'Êâã', emoji: '‚úã', _isHands: true }];

  if (type === 'tool') {
    pickaxes.forEach(t => { if (t.id !== 'hands' && getBlockCount(t.id) > 0) options.push(t); });
    axes.forEach(t => { if (getBlockCount(t.id) > 0) options.push(t); });
  } else {
    swords.forEach(t => { if (t.id !== 'hands' && getBlockCount(t.id) > 0) options.push(t); });
  }

  // Backdrop
  const backdrop = document.createElement('div');
  backdrop.className = 'tool-picker-backdrop';
  backdrop.addEventListener('click', closeToolPicker);
  (document.querySelector('.app') || document.body).appendChild(backdrop);

  // Picker
  const picker = document.createElement('div');
  picker.className = 'tool-picker';
  picker.id = 'activeToolPicker';

  options.forEach(t => {
    const opt = document.createElement('div');
    opt.className = 'tool-picker-option';
    const isHands = t._isHands || t.id === 'hands';
    const dur = isHands ? '' : getToolDurabilityText(t);
    const info = t.maxTier ? 'ÂèØÊåñÁ¨¨ ' + t.maxTier + ' Â±§' :
                 t.woodBonus ? 'Á†çÊ®π x' + t.woodBonus : '';
    // Build option content with safe DOM methods
    const emojiSpan = document.createElement('span');
    emojiSpan.className = 'opt-emoji';
    emojiSpan.textContent = t.emoji;
    opt.appendChild(emojiSpan);
    opt.appendChild(document.createTextNode(' ' + t.name));
    if (info) { const s = document.createElement('span'); s.className = 'opt-info'; s.textContent = info; opt.appendChild(s); }
    if (dur) { const s = document.createElement('span'); s.className = 'opt-info'; s.textContent = dur; opt.appendChild(s); }
    if ((isHands && !currentId) || t.id === currentId) opt.classList.add('selected');
    opt.addEventListener('click', (e) => {
      e.stopPropagation();
      selectedTools[selKey] = isHands ? null : t.id;
      saveGame(); closeToolPicker(); refreshToolChips(); updateExposure();
      if (document.getElementById('equip').classList.contains('active')) initEquipTab();
    });
    picker.appendChild(opt);
  });

  // Append picker to .app (same stacking context as backdrop) and position near chip
  const appEl = document.querySelector('.app') || document.body;
  const rect = chipEl.getBoundingClientRect();
  picker.style.position = 'fixed';
  picker.style.left = rect.left + rect.width / 2 + 'px';
  picker.style.transform = 'translateX(-50%)';
  appEl.appendChild(picker);

  // Flip upward if picker overflows the viewport bottom
  const pickerRect = picker.getBoundingClientRect();
  if (rect.bottom + 6 + pickerRect.height > window.innerHeight) {
    picker.style.top = (rect.top - pickerRect.height - 6) + 'px';
  } else {
    picker.style.top = rect.bottom + 6 + 'px';
  }
}

function closeToolPicker() {
  const picker = document.getElementById('activeToolPicker');
  if (picker) picker.remove();
  const backdrop = document.querySelector('.tool-picker-backdrop');
  if (backdrop) backdrop.remove();
}

function refreshToolChips() {
  const el = document.getElementById('toolChips');
  if (el) renderToolChips(el);
}

function openArmorPicker(cellEl, slot) {
  closeToolPicker();
  const slotNames = { helmet: 'È†≠Áõî', chest: 'ÁõîÁî≤', legs: 'Ë§≤Â≠ê', boots: 'ÈûãÂ≠ê' };

  // Build options: unequip + available armor for this slot
  const options = [];
  if (equipped[slot]) options.push({ id: '__unequip__', emoji: '‚ùå', name: 'ËÑ´‰∏ã' });
  blocks.forEach(b => {
    if (!b.id.includes('_' + slot)) return;
    const count = getBlockCount(b.id);
    if (count <= 0 && b.id !== equipped[slot]) return;
    options.push({ id: b.id, emoji: b.emoji, name: b.name, count, wearing: b.id === equipped[slot] });
  });

  if (options.length === 0) return; // nothing to do

  const backdrop = document.createElement('div');
  backdrop.className = 'tool-picker-backdrop';
  backdrop.addEventListener('click', closeToolPicker);
  (document.querySelector('.app') || document.body).appendChild(backdrop);

  const picker = document.createElement('div');
  picker.className = 'tool-picker';
  picker.id = 'activeToolPicker';

  // Title
  const title = document.createElement('div');
  title.style.cssText = 'padding:8px 14px 4px;font-family:Fredoka,sans-serif;font-size:0.75rem;color:#B2BEC3;';
  title.textContent = slotNames[slot];
  picker.appendChild(title);

  options.forEach(o => {
    const opt = document.createElement('div');
    opt.className = 'tool-picker-option';
    if (o.wearing) opt.classList.add('selected');
    const countText = o.count ? ' x' + o.count : '';
    const emojiSpan = document.createElement('span');
    emojiSpan.className = 'opt-emoji';
    emojiSpan.textContent = o.emoji;
    opt.appendChild(emojiSpan);
    opt.appendChild(document.createTextNode(' ' + o.name + countText));
    opt.addEventListener('click', (e) => {
      e.stopPropagation(); // prevent bubble to parent cell re-opening picker
      if (o.id === '__unequip__') {
        addBlock(equipped[slot]);
        equipped[slot] = null;
      } else if (o.wearing) {
        // Already wearing, unequip
        addBlock(equipped[slot]);
        equipped[slot] = null;
      } else {
        // Equip: return current to inventory, take new from inventory
        if (equipped[slot]) addBlock(equipped[slot]);
        inventory[o.id] = (inventory[o.id] || 1) - 1;
        if (inventory[o.id] <= 0) delete inventory[o.id];
        equipped[slot] = o.id;
      }
      saveGame(); closeToolPicker(); initEquipTab();
    });
    picker.appendChild(opt);
  });

  // Append picker to .app (same stacking context as backdrop)
  const appEl = document.querySelector('.app') || document.body;
  const rect = cellEl.getBoundingClientRect();
  picker.style.position = 'fixed';
  picker.style.left = rect.left + rect.width / 2 + 'px';
  picker.style.transform = 'translateX(-50%)';
  appEl.appendChild(picker);
  const pickerRect = picker.getBoundingClientRect();
  if (rect.bottom + 6 + pickerRect.height > window.innerHeight) {
    picker.style.top = (rect.top - pickerRect.height - 6) + 'px';
  } else {
    picker.style.top = rect.bottom + 6 + 'px';
  }
}

function refreshMineHeader() {
  refreshToolChips();
  updateExposure();
  updateMineRefreshBtn();
}

// ===== COLLECTION =====

function renderCharacter(container, size) {
  container.textContent = '';
  const display = document.createElement('div');
  display.className = 'character-display' + (size === 'small' ? ' small' : '');

  const getEquip = (slot, fallback) => {
    if (!equipped[slot]) return { emoji: fallback, name: null, empty: true };
    const b = blocks.find(x => x.id === equipped[slot]);
    return b ? { emoji: b.emoji, name: b.name, empty: false } : { emoji: fallback, name: null, empty: true };
  };

  const tool = getEquippedTool();
  const weapon = getEquippedWeapon();
  const small = size === 'small';
  const helmet = getEquip('helmet', small ? 'üòä' : 'üß¢');
  const chest = getEquip('chest', small ? '¬∑' : 'üëï');
  const legs = getEquip('legs', small ? '¬∑' : 'üëñ');
  const boots = getEquip('boots', small ? '¬∑' : 'üëü');

  // Grid: 3 columns √ó 4 rows
  //    _   È†≠    _
  //  Ê≠¶Âô®  Ë°£  Â∑•ÂÖ∑
  //    _   Ë§≤    _
  //    _   Èûã    _
  const grid = [
    { emoji: '',           label: '',                              action: null },
    { emoji: helmet.emoji, label: helmet.name || 'È†≠', empty: helmet.empty, action: { type: 'armor', slot: 'helmet' } },
    { emoji: '',           label: '',                              action: null },
    { emoji: weapon ? weapon.emoji : '‚úã', label: weapon ? weapon.name : 'Ê≠¶Âô®', empty: !weapon, action: { type: 'tool', toolType: 'weapon' } },
    { emoji: chest.emoji,  label: chest.name || 'Ë°£', empty: chest.empty,  action: { type: 'armor', slot: 'chest' } },
    { emoji: tool ? tool.emoji : '‚úã',    label: tool ? tool.name : 'Â∑•ÂÖ∑', empty: !tool, action: { type: 'tool', toolType: 'tool' } },
    { emoji: '',           label: '',                              action: null },
    { emoji: legs.emoji,   label: legs.name || 'Ë§≤', empty: legs.empty,   action: { type: 'armor', slot: 'legs' } },
    { emoji: '',           label: '',                              action: null },
    { emoji: '',           label: '',                              action: null },
    { emoji: boots.emoji,  label: boots.name || 'Èûã', empty: boots.empty, action: { type: 'armor', slot: 'boots' } },
    { emoji: '',           label: '',                              action: null },
  ];

  grid.forEach(cell => {
    const el = document.createElement('div');
    el.className = 'char-cell';
    const hasContent = cell.emoji || cell.action;
    if (hasContent) {
      if (cell.emoji) {
        el.textContent = cell.emoji;
        if (cell.empty) el.style.opacity = '0.3';
      } else if (cell.action) {
        el.classList.add('empty-slot');
      }
      if (cell.label) {
        const lbl = document.createElement('div');
        lbl.className = 'char-cell-label';
        lbl.textContent = cell.label;
        el.appendChild(lbl);
      }
      if (cell.action && size !== 'small') {
        el.classList.add('clickable');
        el.style.position = 'relative';
        el.addEventListener('click', (e) => {
          e.stopPropagation();
          if (cell.action.type === 'tool') {
            openToolPicker(el, cell.action.toolType);
          } else {
            openArmorPicker(el, cell.action.slot);
          }
        });
      }
    }
    display.appendChild(el);
  });

  container.appendChild(display);
}

function initCraftTab() {
  const area = document.getElementById('craftArea');
  area.textContent = '';
  renderCraft(area);
}

function initFurnaceTab() {
  const area = document.getElementById('furnaceArea');
  area.textContent = '';

  const title = document.createElement('h3');
  title.textContent = 'üî• ÁÜîÁàê Furnace';
  title.className = 'section-title';
  area.appendChild(title);

  const ownedCount = getBlockCount('furnace');
  if (ownedCount < 1) {
    const msg = document.createElement('div');
    msg.className = 'section-empty';
    const line1 = document.createTextNode('ÈúÄË¶ÅÂÖàÂêàÊàê üî• ÁÜîÁàê');
    const br = document.createElement('br');
    const line2 = document.createElement('span');
    line2.textContent = '8 ü™® Áü≥È†≠ ‚Üí ÂêàÊàêË°®';
    msg.appendChild(line1);
    msg.appendChild(br);
    msg.appendChild(line2);
    area.appendChild(msg);
    return;
  }

  // Furnace UI
  const furnaceUI = document.createElement('div');
  furnaceUI.className = 'furnace-ui';

  // Input slot
  const inputSection = document.createElement('div');
  inputSection.className = 'furnace-slot-section';
  const inputLabel = document.createElement('div');
  inputLabel.className = 'furnace-slot-label';
  inputLabel.textContent = 'ÂéüÊñô';
  const inputSlot = document.createElement('div');
  inputSlot.className = 'furnace-slot';
  inputSlot.id = 'furnaceInput';
  inputSlot.textContent = '?';
  inputSection.appendChild(inputLabel);
  inputSection.appendChild(inputSlot);

  // Plus sign
  const plus = document.createElement('div');
  plus.className = 'furnace-symbol';
  plus.textContent = '+';

  // Fuel slot
  const fuelSection = document.createElement('div');
  fuelSection.className = 'furnace-slot-section';
  const fuelLabel = document.createElement('div');
  fuelLabel.className = 'furnace-slot-label';
  fuelLabel.textContent = 'ÁáÉÊñô';
  const fuelSlot = document.createElement('div');
  fuelSlot.className = 'furnace-slot';
  fuelSlot.id = 'furnaceFuel';
  fuelSlot.textContent = '‚¨õ';
  fuelSlot.style.opacity = '0.5';
  fuelSection.appendChild(fuelLabel);
  fuelSection.appendChild(fuelSlot);

  // Arrow
  const arrowEl = document.createElement('div');
  arrowEl.className = 'furnace-symbol';
  arrowEl.textContent = '‚û°Ô∏è';

  // Output slot
  const outputSection = document.createElement('div');
  outputSection.className = 'furnace-slot-section';
  const outputLabel = document.createElement('div');
  outputLabel.className = 'furnace-slot-label';
  outputLabel.textContent = 'Áî¢Âá∫';
  const outputSlot = document.createElement('div');
  outputSlot.className = 'furnace-slot';
  outputSlot.id = 'furnaceOutput';
  outputSlot.textContent = '?';
  outputSection.appendChild(outputLabel);
  outputSection.appendChild(outputSlot);

  furnaceUI.appendChild(inputSection);
  furnaceUI.appendChild(plus);
  furnaceUI.appendChild(fuelSection);
  furnaceUI.appendChild(arrowEl);
  furnaceUI.appendChild(outputSection);
  area.appendChild(furnaceUI);

  // Status / smelt button
  const status = document.createElement('div');
  status.id = 'furnaceStatus';
  status.className = 'furnace-status';
  area.appendChild(status);

  const smeltBtn = document.createElement('button');
  smeltBtn.className = 'speak-btn primary';
  smeltBtn.id = 'furnaceSmeltBtn';
  smeltBtn.textContent = 'üî• ÁÜîÁÖâ Smelt';
  smeltBtn.disabled = true;
  smeltBtn.style.cssText = 'display:block;margin:8px auto;';
  area.appendChild(smeltBtn);

  // Recipe selector
  const recipeList = document.createElement('div');
  recipeList.className = 'furnace-recipes';
  const recipeTitle = document.createElement('div');
  recipeTitle.className = 'furnace-recipes-title';
  recipeTitle.textContent = 'üìú ÁÜîÁÖâË°® Smelting Recipes';
  recipeList.appendChild(recipeTitle);

  let selectedRecipe = null;

  smeltRecipes.forEach(recipe => {
    const inputBlock = blocks.find(b => b.id === recipe.input);
    const outputBlock = blocks.find(b => b.id === recipe.output);
    const fuelBlock = blocks.find(b => b.id === recipe.fuel);
    const haveInput = getBlockCount(recipe.input);
    const haveFuel = getBlockCount(recipe.fuel);
    const canSmelt = haveInput >= 1 && haveFuel >= 1;

    const row = document.createElement('div');
    row.className = 'furnace-recipe-row' + (canSmelt ? ' available' : '');

    const inputSpan = document.createElement('span');
    inputSpan.className = 'furnace-recipe-input';
    inputSpan.textContent = inputBlock.emoji + ' ' + inputBlock.name + ' (' + haveInput + ')';
    const arrowSpan = document.createElement('span');
    arrowSpan.className = 'furnace-recipe-arrow';
    arrowSpan.textContent = '+ ' + fuelBlock.emoji + ' (' + haveFuel + ') ‚û°Ô∏è';
    const outputSpan = document.createElement('span');
    outputSpan.className = 'furnace-recipe-output';
    outputSpan.textContent = outputBlock.emoji + ' ' + recipe.name;
    row.appendChild(inputSpan);
    row.appendChild(arrowSpan);
    row.appendChild(outputSpan);

    if (canSmelt) {
      row.addEventListener('click', () => {
        selectedRecipe = recipe;
        recipeList.querySelectorAll('.furnace-recipe-row').forEach(r => r.classList.remove('selected'));
        row.classList.add('selected');
        inputSlot.textContent = inputBlock.emoji;
        inputSlot.style.opacity = '1';
        fuelSlot.textContent = fuelBlock.emoji;
        fuelSlot.style.opacity = '1';
        outputSlot.textContent = outputBlock.emoji;
        smeltBtn.disabled = false;
        status.textContent = inputBlock.name + ' + ' + fuelBlock.name + ' ‚Üí ' + recipe.name;
      });
    }
    recipeList.appendChild(row);
  });

  area.appendChild(recipeList);

  // Smelt action
  smeltBtn.addEventListener('click', () => {
    if (!selectedRecipe) return;
    const haveInput = getBlockCount(selectedRecipe.input);
    const haveFuel = getBlockCount(selectedRecipe.fuel);
    if (haveInput < 1 || haveFuel < 1) {
      status.textContent = 'ÊùêÊñô‰∏çË∂≥ÔºÅ';
      return;
    }
    inventory[selectedRecipe.input] = (inventory[selectedRecipe.input] || 0) - 1;
    if (inventory[selectedRecipe.input] <= 0) delete inventory[selectedRecipe.input];
    inventory[selectedRecipe.fuel] = (inventory[selectedRecipe.fuel] || 0) - 1;
    if (inventory[selectedRecipe.fuel] <= 0) delete inventory[selectedRecipe.fuel];
    addBlock(selectedRecipe.output);
    playCraftSfx();
    doConfetti();
    status.textContent = '‚úÖ ÁÜîÁÖâÊàêÂäüÔºÅÁç≤Âæó ' + selectedRecipe.emoji + ' ' + selectedRecipe.name;
    saveGame();
    setTimeout(() => initFurnaceTab(), 800);
  });

  // Eat section for cooked food
  const eatableItems = Object.keys(foodEffects).filter(id => getBlockCount(id) > 0);
  if (eatableItems.length > 0) {
    const eatSection = document.createElement('div');
    eatSection.className = 'furnace-eat-section';
    const eatTitle = document.createElement('div');
    eatTitle.className = 'furnace-recipes-title';
    eatTitle.textContent = 'üçΩÔ∏è È£üÁî® Eat Food';
    eatSection.appendChild(eatTitle);

    eatableItems.forEach(id => {
      const b = blocks.find(x => x.id === id);
      const count = getBlockCount(id);
      const effect = foodEffects[id];
      const row = document.createElement('div');
      row.className = 'furnace-eat-row';
      const label = document.createElement('span');
      label.textContent = b.emoji + ' ' + b.name + ' x' + count;
      row.appendChild(label);
      const eatBtn = document.createElement('button');
      eatBtn.className = 'speak-btn small primary';
      eatBtn.textContent = 'üçΩÔ∏è È£üÁî® (+' + effect + ' ‚ö°)';
      eatBtn.addEventListener('click', () => {
        inventory[id] = (inventory[id] || 0) - 1;
        if (inventory[id] <= 0) delete inventory[id];
        addGems(effect);
        saveGame();
        initFurnaceTab();
      });
      row.appendChild(eatBtn);
      eatSection.appendChild(row);
    });
    area.appendChild(eatSection);
  }
}

function initEquipTab() {
  const area = document.getElementById('equipArea');
  area.textContent = '';
  renderEquipment(area);
}

function initEncyclopediaTab() {
  const area = document.getElementById('encyclopediaArea');
  area.textContent = '';
  renderEncyclopedia(area);
}

function renderEncyclopedia(c) {
  const title = document.createElement('h3');
  title.className = 'section-title';
  title.textContent = 'üìñ ÂúñÈëë Encyclopedia';
  c.appendChild(title);

  const discoveredCount = discovered.size;
  const counter = document.createElement('div');
  counter.className = 'section-subtitle';
  counter.textContent = `Â∑≤ÁôºÁèæ ${discoveredCount} / ${blocks.length} Á®ÆÁâ©ÂìÅ`;
  c.appendChild(counter);

  const grid = document.createElement('div');
  grid.className = 'encyclopedia-grid';
  blocks.forEach(b => {
    const count = getBlockCount(b.id);
    const owned = discovered.has(b.id);
    const card = document.createElement('div');
    card.className = 'block-card ' + (owned ? 'owned' : 'undiscovered');
    if (b.tier > 0) card.style.borderBottomColor = tierColors[b.tier - 1];
    else card.style.borderBottomColor = '#A29BFE'; // tools

    const emoji = document.createElement('div');
    emoji.className = 'block-emoji';
    emoji.textContent = owned ? b.emoji : '‚ùì';
    const name = document.createElement('div');
    name.className = 'block-name';
    name.textContent = owned ? b.name : '???';
    const cnt = document.createElement('div');
    cnt.className = 'block-count';
    cnt.textContent = owned ? `x${count}` : 'Êú™ÁôºÁèæ';
    const tier = document.createElement('div');
    tier.className = 'block-tier';
    tier.textContent = b.tier > 0 ? '‚≠ê'.repeat(b.tier) : 'üîß';

    card.appendChild(emoji);
    card.appendChild(name);
    card.appendChild(cnt);
    card.appendChild(tier);
    grid.appendChild(card);
  });
  c.appendChild(grid);
}

// ===== CRAFTING TABLE =====
let craftGrid = [null,null,null, null,null,null, null,null,null]; // 9 slots, block id or null
let craftSelected = null; // selected block id from inventory

function renderCraft(c) {
  // craftGrid persists across tab switches (items are already deducted from inventory)

  const title = document.createElement('h3');
  title.className = 'section-title';
  title.textContent = 'üî® ÂêàÊàê Craft';
  c.appendChild(title);

  const area = document.createElement('div');
  area.className = 'craft-area';

  // Onboarding guide
  const guide = document.createElement('div');
  guide.className = 'craft-guide';
  guide.textContent = '‚ë† ËÉåÂåÖÈÅ∏ÊùêÊñô ‚Üí ‚ë° ÈªûÊ†ºÂ≠êÊîæÂÖ• ‚Üí ‚ë¢ ÊåâÂêàÊàêÔºÅ';
  area.appendChild(guide);

  // Craft table: grid + arrow + result
  const table = document.createElement('div');
  table.className = 'craft-table';

  const grid = document.createElement('div');
  grid.className = 'craft-grid';
  grid.id = 'craftGrid';
  for (let i = 0; i < 9; i++) {
    const slot = document.createElement('div');
    slot.className = 'craft-slot';
    slot.dataset.idx = i;
    slot.addEventListener('click', () => craftSlotClick(i));
    grid.appendChild(slot);
  }
  table.appendChild(grid);

  const arrow = document.createElement('div');
  arrow.className = 'craft-arrow';
  arrow.textContent = '‚û°Ô∏è';
  table.appendChild(arrow);

  const resultSlot = document.createElement('div');
  resultSlot.className = 'craft-result-slot';
  resultSlot.id = 'craftResultSlot';
  resultSlot.style.cursor = 'pointer';
  resultSlot.addEventListener('click', () => {
    if (checkCraftMatch()) doCraft();
  });
  table.appendChild(resultSlot);

  area.appendChild(table);

  // Action buttons
  const actions = document.createElement('div');
  actions.className = 'craft-actions';
  const craftBtn = document.createElement('button');
  craftBtn.className = 'craft-btn primary';
  craftBtn.id = 'craftBtn';
  craftBtn.textContent = 'üî® ÂêàÊàê';
  craftBtn.disabled = true;
  craftBtn.addEventListener('click', doCraft);
  const clearBtn = document.createElement('button');
  clearBtn.className = 'craft-btn secondary';
  clearBtn.textContent = 'üîÑ Ê∏ÖÁ©∫';
  clearBtn.addEventListener('click', () => {
    // Return all placed blocks to inventory
    craftGrid.forEach(id => { if (id) addBlock(id); });
    craftGrid = [null,null,null, null,null,null, null,null,null];
    updateCraftUI();
  });
  actions.appendChild(craftBtn);
  actions.appendChild(clearBtn);
  area.appendChild(actions);

  // Inventory panel
  const inv = document.createElement('div');
  inv.className = 'craft-inventory';
  const invTitle = document.createElement('div');
  invTitle.className = 'craft-inv-title';
  invTitle.textContent = 'üéí ËÉåÂåÖÔºàÈªûÈÅ∏ÊñπÂ°äÂÜçÊîæÂà∞Ê†ºÂ≠ê‰∏äÔºâ';
  inv.appendChild(invTitle);
  const craftInfo = document.createElement('div');
  craftInfo.id = 'craftInfo';
  craftInfo.style.cssText = 'position:absolute;font-size:0.75rem;color:#fff;background:rgba(0,0,0,0.8);padding:3px 8px;border-radius:6px;pointer-events:none;white-space:nowrap;z-index:20;opacity:0;transition:opacity 0.15s;';
  inv.style.position = 'relative';
  inv.appendChild(craftInfo);
  const invGrid = document.createElement('div');
  invGrid.className = 'craft-inv-grid';
  invGrid.id = 'craftInvGrid';
  inv.appendChild(invGrid);
  area.appendChild(inv);

  c.appendChild(area);

  // Recipe book
  renderRecipeBook(c);

  updateCraftUI();
}

function renderRecipeBook(c) {
  const book = document.createElement('div');
  book.className = 'recipe-book';
  const title = document.createElement('div');
  title.className = 'recipe-book-title';
  title.textContent = 'üìú ÂêàÊàêË°® Recipes';
  book.appendChild(title);

  // Collect recipes by category
  const categories = [
    { name: '‚õèÔ∏è Â∑•ÂÖ∑ Tools', recipes: [] },
    { name: 'ü™ì Êñß Axes', recipes: [] },
    { name: 'üó°Ô∏è Ê≠¶Âô® Weapons', recipes: [] },
    { name: 'üõ°Ô∏è ÁõîÁî≤ Armor', recipes: [] },
    { name: 'üîß ÂÖ∂‰ªñ Other', recipes: [] },
    { name: 'üî• ÁÜîÁàê Smelting', recipes: [] },
  ];

  pickaxes.forEach((pick) => {
    if (!pick.pattern) return;
    categories[0].recipes.push({
      pattern: pick.pattern, emoji: pick.emoji, name: pick.name,
      needs: pick.recipe, itemId: pick.id, type: 'pickaxe'
    });
  });
  axes.forEach((axe) => {
    categories[1].recipes.push({
      pattern: axe.pattern, emoji: axe.emoji, name: axe.name,
      needs: axe.recipe, itemId: axe.id, type: 'axe'
    });
  });
  swords.forEach((sword) => {
    if (!sword.pattern) return;
    categories[2].recipes.push({
      pattern: sword.pattern, emoji: sword.emoji, name: sword.name,
      needs: sword.recipe, itemId: sword.id, type: 'sword'
    });
  });
  armorRecipes.forEach((armor) => {
    const b = blocks.find(x => x.id === armor.outputId);
    categories[3].recipes.push({
      pattern: armor.pattern, emoji: b ? b.emoji : '?', name: b ? b.name : armor.outputId,
      needs: armor.recipe, itemId: armor.outputId, type: 'armor'
    });
  });
  craftRecipes.forEach(recipe => {
    const needs = recipe.needs || {};
    const pattern = recipe.pattern || (recipe.shapeless ?
      (() => {
        const p = [null,null,null, null,null,null, null,null,null];
        const ids = Object.entries(needs);
        if (ids.length === 1) { p[4] = ids[0][0]; }
        return p;
      })() : [null,null,null, null,null,null, null,null,null]);
    categories[4].recipes.push({
      pattern, emoji: recipe.emoji,
      name: recipe.name + ' x' + recipe.outputCount,
      needs, itemId: recipe.outputId, type: 'item',
      shapeless: recipe.shapeless
    });
  });
  smeltRecipes.forEach(recipe => {
    const inputBlock = blocks.find(b => b.id === recipe.input);
    const fuelBlock = blocks.find(b => b.id === recipe.fuel);
    // Show as: input in center, fuel below
    const pattern = [null,null,null, null,recipe.input,null, null,recipe.fuel,null];
    categories[5].recipes.push({
      pattern, emoji: recipe.emoji, name: recipe.name,
      needs: { [recipe.input]: 1, [recipe.fuel]: 1 },
      itemId: recipe.output, type: 'smelt'
    });
  });

  categories.forEach((cat, catIdx) => {
    if (cat.recipes.length === 0) return;

    const section = document.createElement('div');
    section.className = 'recipe-category';

    const header = document.createElement('div');
    header.className = 'recipe-category-header';
    header.textContent = cat.name + ' (' + cat.recipes.length + ')';
    let expanded = catIdx < 3;
    header.addEventListener('click', () => {
      expanded = !expanded;
      list.style.display = expanded ? 'flex' : 'none';
      header.classList.toggle('collapsed', !expanded);
    });
    if (!expanded) header.classList.add('collapsed');
    section.appendChild(header);

    const list = document.createElement('div');
    list.className = 'recipe-list';
    list.style.display = expanded ? 'flex' : 'none';

    cat.recipes.forEach(r => {
      const canCraft = hasBlocks(r.needs);
      const owned = r.itemId ? getBlockCount(r.itemId) : 0;
      const card = document.createElement('div');
      card.className = 'recipe-card' + (canCraft ? ' craftable' : '');

      const miniGrid = document.createElement('div');
      miniGrid.className = 'recipe-mini-grid';
      r.pattern.forEach(slot => {
        const cell = document.createElement('div');
        cell.className = 'recipe-mini-slot';
        if (slot) {
          const b = blocks.find(x => x.id === slot);
          if (b) cell.textContent = b.emoji;
        }
        miniGrid.appendChild(cell);
      });
      card.appendChild(miniGrid);

      const arrow = document.createElement('div');
      arrow.className = 'recipe-arrow';
      arrow.textContent = '‚û°Ô∏è';
      card.appendChild(arrow);

      const result = document.createElement('div');
      result.className = 'recipe-result';
      result.textContent = r.emoji;
      card.appendChild(result);

      const info = document.createElement('div');
      info.className = 'recipe-info';
      const nameEl = document.createElement('div');
      nameEl.className = 'recipe-name';
      const ownedLabel = owned > 0 ? ' (ÊìÅÊúâ x' + owned + ')' : '';
      nameEl.textContent = r.name + ownedLabel + (r.shapeless ? ' (‰ªªÊÑè‰ΩçÁΩÆ)' : '');
      info.appendChild(nameEl);

      const needsEl = document.createElement('div');
      needsEl.className = 'recipe-needs';
      Object.entries(r.needs).forEach(([id, count], idx) => {
        const b = blocks.find(x => x.id === id);
        const have = getBlockCount(id);
        const span = document.createElement('span');
        span.className = have >= count ? 'has' : 'need';
        span.textContent = (b ? b.emoji : id) + ' ' + have + '/' + count;
        if (idx > 0) needsEl.appendChild(document.createTextNode('  '));
        needsEl.appendChild(span);
      });
      info.appendChild(needsEl);
      card.appendChild(info);

      list.appendChild(card);
    });

    section.appendChild(list);
    book.appendChild(section);
  });

  c.appendChild(book);
}

function craftSlotClick(idx) {
  if (craftGrid[idx]) {
    // Remove block from grid, return to inventory
    playPlaceSfx();
    addBlock(craftGrid[idx]);
    craftGrid[idx] = null;
    updateCraftUI();
  } else if (craftSelected && getBlockCount(craftSelected) > 0) {
    // Place selected block
    playPlaceSfx();
    craftGrid[idx] = craftSelected;
    // Deduct from inventory (temporarily)
    inventory[craftSelected] = (inventory[craftSelected] || 0) - 1;
    if (inventory[craftSelected] <= 0) delete inventory[craftSelected];
    saveGame();
    updateCraftUI();
  }
}

function checkCraftMatch() {
  // Check pickaxe recipes (all repeatable)
  for (const pick of pickaxes) {
    if (!pick.pattern) continue;
    const match = pick.pattern.every((need, i) => {
      if (need === null) return craftGrid[i] === null;
      return craftGrid[i] === need;
    });
    if (match) return { type: 'pickaxe', item: pick, emoji: pick.emoji, name: pick.name };
  }
  // Check axe recipes
  for (const axe of axes) {
    const match = axe.pattern.every((need, i) => {
      if (need === null) return craftGrid[i] === null;
      return craftGrid[i] === need;
    });
    if (match) return { type: 'axe', item: axe, emoji: axe.emoji, name: axe.name };
  }
  // Check sword recipes
  for (const sword of swords) {
    if (!sword.pattern) continue;
    const match = sword.pattern.every((need, i) => {
      if (need === null) return craftGrid[i] === null;
      return craftGrid[i] === need;
    });
    if (match) return { type: 'sword', item: sword, emoji: sword.emoji, name: sword.name };
  }
  // Check armor recipes
  for (const armor of armorRecipes) {
    const match = armor.pattern.every((need, i) => {
      if (need === null) return craftGrid[i] === null;
      return craftGrid[i] === need;
    });
    if (match) {
      const b = blocks.find(x => x.id === armor.outputId);
      return { type: 'armor', item: armor, emoji: b.emoji, name: b.name };
    }
  }
  // Check general recipes
  for (const recipe of craftRecipes) {
    if (recipe.shapeless) {
      // Shapeless: count placed blocks, must match needs exactly
      const placed = {};
      craftGrid.forEach(id => { if (id) placed[id] = (placed[id] || 0) + 1; });
      const placedKeys = Object.keys(placed);
      const needKeys = Object.keys(recipe.needs);
      if (placedKeys.length === needKeys.length &&
          needKeys.every(k => placed[k] === recipe.needs[k])) {
        return { type: 'item', item: recipe, emoji: recipe.emoji, name: `${recipe.name} x${recipe.outputCount}` };
      }
    } else if (recipe.pattern) {
      const match = recipe.pattern.every((need, i) => {
        if (need === null) return craftGrid[i] === null;
        return craftGrid[i] === need;
      });
      if (match) return { type: 'item', item: recipe, emoji: recipe.emoji, name: `${recipe.name} x${recipe.outputCount}` };
    }
  }
  return null;
}

function updateCraftUI() {
  // Update grid slots
  const gridEl = document.getElementById('craftGrid');
  if (!gridEl) return;
  const slots = gridEl.children;
  for (let i = 0; i < 9; i++) {
    const slot = slots[i];
    slot.textContent = '';
    slot.classList.toggle('filled', craftGrid[i] !== null);
    if (craftGrid[i]) {
      const b = blocks.find(x => x.id === craftGrid[i]);
      if (b) slot.textContent = b.emoji;
    }
  }

  // Check for recipe match
  const match = checkCraftMatch();
  const resultSlot = document.getElementById('craftResultSlot');
  const craftBtn = document.getElementById('craftBtn');
  if (resultSlot) {
    resultSlot.textContent = match ? match.emoji : '';
    resultSlot.classList.toggle('matched', !!match);
  }
  if (craftBtn) craftBtn.disabled = !match;

  // Update inventory panel
  const invGrid = document.getElementById('craftInvGrid');
  if (!invGrid) return;
  invGrid.textContent = '';
  blocks.forEach(b => {
    const count = getBlockCount(b.id);
    if (count <= 0) return;
    const item = document.createElement('div');
    item.className = 'craft-inv-item' + (craftSelected === b.id ? ' selected' : '');
    item.title = b.name;
    item.textContent = b.emoji;
    const countEl = document.createElement('span');
    countEl.className = 'inv-count';
    countEl.textContent = count;
    item.appendChild(countEl);
    // Show durability bar for tools
    if (toolDurability[b.id] && b.tier === 0) {
      const toolDef = pickaxes.find(p => p.id === b.id) || axes.find(a => a.id === b.id) || swords.find(s => s.id === b.id);
      if (toolDef && toolDef.durability !== Infinity) {
        const pct = (toolDurability[b.id] / toolDef.durability) * 100;
        const barColor = pct > 50 ? '#00B894' : pct > 20 ? '#FDCB6E' : '#FF6B6B';
        const bar = document.createElement('div');
        bar.style.cssText = `position:absolute;bottom:0;left:2px;right:2px;height:3px;border-radius:2px;background:rgba(0,0,0,0.2);`;
        const fill = document.createElement('div');
        fill.style.cssText = `height:100%;width:${pct}%;border-radius:2px;background:${barColor};transition:width 0.3s;`;
        bar.appendChild(fill);
        item.appendChild(bar);
      }
    }
    item.addEventListener('click', (e) => {
      e.stopPropagation();
      craftSelected = (craftSelected === b.id) ? null : b.id;
      const info = document.getElementById('craftInfo');
      if (info) {
        if (craftSelected === b.id) {
          info.textContent = b.emoji + ' ' + b.name + ' (' + getBlockCount(b.id) + 'ÂÄã)';
          info.style.opacity = '1';
          const itemRect = item.getBoundingClientRect();
          const parentRect = info.parentElement.getBoundingClientRect();
          info.style.left = (itemRect.left - parentRect.left + itemRect.width / 2) + 'px';
          info.style.top = (itemRect.top - parentRect.top - 28) + 'px';
          info.style.transform = 'translateX(-50%)';
        } else {
          info.style.opacity = '0';
        }
      }
      updateCraftUI();
    });
    invGrid.appendChild(item);
  });
}

function doCraft() {
  const match = checkCraftMatch();
  if (!match) return;
  playCraftSfx();
  // Clear the grid (blocks already deducted when placed)
  craftGrid = [null,null,null, null,null,null, null,null,null];
  saveGame(); // persist cleared grid before learn gate to prevent material loss on refresh

  const finishCraft = () => {
    if (match.type === 'pickaxe' || match.type === 'axe' || match.type === 'sword') {
      addBlock(match.item.id);
      if (!toolDurability[match.item.id] && match.item.durability !== Infinity) {
        toolDurability[match.item.id] = match.item.durability;
      }
    } else if (match.type === 'armor') {
      addBlock(match.item.outputId);
    } else if (match.type === 'item') {
      addBlock(match.item.outputId, match.item.outputCount);
    }
    saveGame();
    doConfetti();
    initCraftTab();
  };

  rollLearnGate(finishCraft);
}



function screenshotBuild() {
  if (mineData.length === 0) return;
  const cellSize = 24;
  const maxWidth = mineData[0].length;
  const rows = mineData.length;
  const cvs = document.createElement('canvas');
  cvs.width = maxWidth * cellSize;
  cvs.height = rows * cellSize;
  const ctx = cvs.getContext('2d');

  // Sky background
  ctx.fillStyle = '#87CEEB';
  ctx.fillRect(0, 0, cvs.width, cvs.height);

  const tierBg = { 1: '#8B6F47', 2: '#7F8C8D', 3: '#5D6D7E', 4: '#6B4C3B', 5: '#2C3E6D' };

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < maxWidth; c++) {
      const x = c * cellSize, y = r * cellSize;
      const cellData = mineData[r][c];
      const key = r + ',' + c;
      const placedId = buildGrid[key];

      if (!cellData) continue; // spacer

      if (placedId) {
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(x, y, cellSize, cellSize);
        const b = blocks.find(bl => bl.id === placedId);
        if (b) {
          ctx.font = (cellSize * 0.7) + 'px serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(b.emoji, x + cellSize / 2, y + cellSize / 2);
        }
      } else if (cellData.mined) {
        ctx.fillStyle = 'rgba(135,206,235,0.4)';
        ctx.fillRect(x, y, cellSize, cellSize);
      } else if (cellData.animal) {
        ctx.font = (cellSize * 0.7) + 'px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(cellData.animal.emoji, x + cellSize / 2, y + cellSize / 2);
      } else if (cellData.treeEmoji) {
        ctx.font = (cellSize * 0.7) + 'px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(cellData.treeEmoji, x + cellSize / 2, y + cellSize / 2);
      } else {
        ctx.fillStyle = tierBg[cellData.tier] || '#8B6F47';
        ctx.fillRect(x, y, cellSize, cellSize);
      }

      // Player avatar
      if (buildPlayerPos && buildPlayerPos.r === r && buildPlayerPos.c === c) {
        ctx.font = (cellSize * 0.8) + 'px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('üßç', x + cellSize / 2, y + cellSize / 2);
      }
    }
  }

  cvs.toBlob(blob => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'my-build-' + Date.now() + '.png';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  });
}

function renderEquipment(c) {
  const title = document.createElement('h3');
  title.className = 'section-title';
  title.textContent = 'üë§ Ë£ùÂÇô Equipment';
  c.appendChild(title);

  const area = document.createElement('div');
  area.className = 'equip-area';

  const hint = document.createElement('div');
  hint.className = 'section-subtitle';
  hint.textContent = 'üëÜ ÈªûÊìäÈÉ®‰ΩçÂèØÊõ¥ÊèõË£ùÂÇôËàáÂ∑•ÂÖ∑';
  area.appendChild(hint);

  const charContainer = document.createElement('div');
  renderCharacter(charContainer, 'large');
  area.appendChild(charContainer);

  c.appendChild(area);
}

// ===== INIT =====
loadGame();
initLearn();

// Settings modal
const settingsModal = document.getElementById('settingsModal');
const settingsBtn = document.getElementById('settingsBtn');
const settingsClose = document.getElementById('settingsClose');
settingsBtn.addEventListener('click', () => { settingsModal.classList.add('active'); });
settingsClose.addEventListener('click', () => { settingsModal.classList.remove('active'); });
settingsModal.addEventListener('click', (e) => {
  if (e.target === settingsModal) settingsModal.classList.remove('active');
});

// Mute toggle
isMuted = localStorage.getItem('isMuted') === 'true';
const muteOffBtn = document.getElementById('muteOff');
const muteOnBtn = document.getElementById('muteOn');
function updateMuteUI() {
  muteOffBtn.classList.toggle('active', !isMuted);
  muteOnBtn.classList.toggle('active', isMuted);
}
updateMuteUI();
muteOffBtn.addEventListener('click', () => { isMuted = false; localStorage.setItem('isMuted', 'false'); updateMuteUI(); });
muteOnBtn.addEventListener('click', () => { isMuted = true; localStorage.setItem('isMuted', 'true'); updateMuteUI(); });

// Pre-warm: load voices so pickBestVoice works on first click
if (window.speechSynthesis) {
  speechSynthesis.getVoices();
  speechSynthesis.onvoiceschanged = () => {
    cachedVoice = null; // re-pick on voice list change
    speechSynthesis.getVoices();
  };
}
</script>
</body>
</html>
