<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Feelings Fun! ğŸ­</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&family=Nunito:wght@400;600;700;800&display=swap');

:root {
  --bg: #FFF8E7;
  --text: #2D3436;
  --card-bg: #FFFFFF;
  --shadow: rgba(45, 52, 54, 0.1);
  --radius: 20px;
  --accent: #A29BFE;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Nunito', sans-serif;
  background: var(--bg);
  min-height: 100vh;
  overflow-x: hidden;
}

body::before {
  content: '';
  position: fixed;
  inset: 0;
  background:
    radial-gradient(circle at 10% 20%, rgba(255,217,61,0.15) 0%, transparent 50%),
    radial-gradient(circle at 90% 80%, rgba(162,155,254,0.12) 0%, transparent 50%),
    radial-gradient(circle at 50% 50%, rgba(255,133,202,0.08) 0%, transparent 60%);
  pointer-events: none;
  z-index: 0;
}

.app { position: relative; z-index: 1; max-width: 900px; margin: 0 auto; padding: 16px; }

.header { text-align: center; padding: 20px 0 10px; }
.header h1 {
  font-family: 'Fredoka', sans-serif;
  font-size: 2.4rem;
  font-weight: 700;
  background: linear-gradient(135deg, #FF6B6B, #A29BFE, #FFD93D);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}
.header .subtitle { font-size: 1rem; color: #636E72; margin-top: 4px; font-weight: 600; }

.score-bar { display: flex; justify-content: center; gap: 20px; margin: 12px 0; flex-wrap: wrap; }
.score-item {
  background: white;
  padding: 8px 18px;
  border-radius: 50px;
  font-weight: 700;
  font-size: 0.95rem;
  box-shadow: 0 2px 10px var(--shadow);
  display: flex;
  align-items: center;
  gap: 6px;
  transition: transform 0.3s;
}
.score-item.pop { animation: pop 0.4s ease; }
@keyframes pop { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }

.nav-tabs { display: flex; gap: 8px; justify-content: center; margin: 16px 0; flex-wrap: wrap; }
.nav-tab {
  padding: 10px 20px;
  border-radius: 50px;
  border: 2px solid #DFE6E9;
  background: white;
  font-family: 'Fredoka', sans-serif;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s;
  color: #636E72;
}
.nav-tab:hover { transform: translateY(-2px); box-shadow: 0 4px 12px var(--shadow); }
.nav-tab.active {
  background: linear-gradient(135deg, #A29BFE, #FF85CA);
  color: white;
  border-color: transparent;
  box-shadow: 0 4px 16px rgba(162,155,254,0.4);
}

.section { display: none; animation: fadeIn 0.4s ease; }
.section.active { display: block; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: none; } }

/* ===== LEARN ===== */
.feelings-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 14px;
  margin-top: 10px;
}
.feeling-card {
  background: var(--card-bg);
  border-radius: var(--radius);
  padding: 18px 12px;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  box-shadow: 0 3px 15px var(--shadow);
  border: 3px solid transparent;
  position: relative;
}
.feeling-card:hover { transform: translateY(-6px) scale(1.03); box-shadow: 0 8px 25px var(--shadow); }
.feeling-card:active { transform: scale(0.95); }
.feeling-card .emoji { font-size: 2.8rem; margin-bottom: 8px; display: block; }
.feeling-card .word { font-family: 'Fredoka', sans-serif; font-size: 1.15rem; font-weight: 600; color: var(--text); }
.feeling-card .chinese { font-size: 0.85rem; color: #636E72; margin-top: 2px; }
.feeling-card .speaker-hint {
  position: absolute; top: 8px; right: 8px;
  font-size: 1rem; opacity: 0.3; transition: opacity 0.2s;
}
.feeling-card:hover .speaker-hint { opacity: 0.7; }
.feeling-card.speaking {
  border-color: var(--accent);
  animation: speakRing 0.6s ease;
}
@keyframes speakRing {
  0%, 100% { box-shadow: 0 3px 15px var(--shadow); }
  50% { box-shadow: 0 0 0 6px rgba(162,155,254,0.3), 0 3px 15px var(--shadow); }
}

.sentence-practice {
  background: white;
  border-radius: var(--radius);
  padding: 24px;
  margin-top: 20px;
  box-shadow: 0 3px 15px var(--shadow);
  text-align: center;
}
.sentence-practice h3 { font-family: 'Fredoka', sans-serif; font-size: 1.2rem; color: var(--text); margin-bottom: 14px; }
.sentence-display {
  font-size: 1.6rem;
  font-family: 'Fredoka', sans-serif;
  font-weight: 600;
  color: #2D3436;
  padding: 14px;
  background: #F8F9FA;
  border-radius: 14px;
  margin-bottom: 14px;
  min-height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  flex-wrap: wrap;
  line-height: 1.4;
}
.sentence-display .hl { color: var(--accent); font-weight: 700; }

.btn-row { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
.speak-btn {
  padding: 12px 28px;
  border-radius: 50px;
  border: none;
  font-family: 'Fredoka', sans-serif;
  font-size: 1.1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s;
  display: inline-flex;
  align-items: center;
  gap: 8px;
}
.speak-btn:hover { transform: translateY(-2px); }
.speak-btn:active { transform: scale(0.95); }
.speak-btn.primary {
  background: linear-gradient(135deg, #A29BFE, #6C5CE7);
  color: white;
  box-shadow: 0 4px 15px rgba(108,92,231,0.3);
}
.speak-btn.secondary {
  background: linear-gradient(135deg, #FFD93D, #FDCB6E);
  color: #2D3436;
  box-shadow: 0 4px 15px rgba(253,203,110,0.3);
}
.speak-btn.small { padding: 8px 18px; font-size: 0.95rem; }
.speak-btn.playing { opacity: 0.7; pointer-events: none; }

.feeling-chips { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-top: 14px; }
.feeling-chip {
  padding: 8px 16px;
  border-radius: 50px;
  border: 2px solid #DFE6E9;
  background: white;
  font-family: 'Fredoka', sans-serif;
  font-size: 0.95rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}
.feeling-chip:hover { background: #F8F9FA; transform: scale(1.05); }
.feeling-chip.selected { border-color: var(--accent); background: #F0EDFF; }

/* ===== MATCH ===== */
.match-feedback {
  text-align: center; padding: 16px;
  font-family: 'Fredoka', sans-serif; font-size: 1.3rem; font-weight: 600;
  min-height: 56px; display: flex; align-items: center; justify-content: center;
}
.match-game { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start; }
.match-column h3 { font-family: 'Fredoka', sans-serif; text-align: center; margin-bottom: 12px; color: #636E72; font-size: 1rem; }
.match-item {
  padding: 14px 18px; border-radius: 14px; margin-bottom: 10px;
  cursor: pointer; transition: all 0.3s;
  font-family: 'Fredoka', sans-serif; font-size: 1.1rem; font-weight: 600;
  text-align: center; user-select: none;
  background: white; border: 3px solid #DFE6E9; box-shadow: 0 2px 10px var(--shadow);
}
.match-item.emoji-item { font-size: 2rem; }
.match-item:hover { transform: scale(1.05); }
.match-item.selected { border-color: var(--accent); background: #F0EDFF; box-shadow: 0 4px 16px rgba(162,155,254,0.3); }
.match-item.correct { border-color: #00B894; background: #E8FFF5; animation: correctBounce 0.5s ease; }
.match-item.wrong { border-color: #FF6B6B; background: #FFE8E8; animation: shake 0.4s ease; }
.match-item.matched { opacity: 0.35; pointer-events: none; transform: scale(0.95); }
@keyframes correctBounce { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.12); } }
@keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-8px); } 75% { transform: translateX(8px); } }

.reset-btn {
  display: block; margin: 16px auto 0;
  padding: 12px 32px; border-radius: 50px; border: none;
  background: linear-gradient(135deg, #FFD93D, #FDCB6E);
  color: #2D3436;
  font-family: 'Fredoka', sans-serif; font-size: 1.05rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
  box-shadow: 0 4px 15px rgba(253,203,110,0.3);
}
.reset-btn:hover { transform: translateY(-2px); }

/* ===== QUIZ ===== */
.quiz-container {
  background: white; border-radius: var(--radius); padding: 30px;
  box-shadow: 0 3px 15px var(--shadow); text-align: center;
}
.quiz-progress { display: flex; gap: 6px; justify-content: center; margin-bottom: 20px; }
.quiz-dot { width: 12px; height: 12px; border-radius: 50%; background: #DFE6E9; transition: all 0.3s; }
.quiz-dot.done { background: #00B894; }
.quiz-dot.current { background: var(--accent); transform: scale(1.3); }
.quiz-dot.wrong-dot { background: #FF6B6B; }
.quiz-prompt { font-size: 3.5rem; margin: 20px 0; }
.quiz-question { font-family: 'Fredoka', sans-serif; font-size: 1.3rem; color: #636E72; margin-bottom: 20px; }
.quiz-options { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; max-width: 500px; margin: 0 auto; }
.quiz-option {
  padding: 16px; border-radius: 14px; border: 3px solid #DFE6E9;
  background: white; font-family: 'Fredoka', sans-serif; font-size: 1.15rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
}
.quiz-option:hover { border-color: var(--accent); transform: translateY(-2px); }
.quiz-option.correct-answer { border-color: #00B894; background: #E8FFF5; }
.quiz-option.wrong-answer { border-color: #FF6B6B; background: #FFE8E8; }

.quiz-result { padding: 30px; text-align: center; }
.quiz-result .big-emoji { font-size: 4rem; margin-bottom: 16px; }
.quiz-result .result-text { font-family: 'Fredoka', sans-serif; font-size: 1.6rem; font-weight: 700; margin-bottom: 8px; }
.quiz-result .result-detail { font-size: 1.1rem; color: #636E72; margin-bottom: 20px; }

/* ===== SIGHT WORDS ===== */
.sight-words-area { display: flex; flex-direction: column; gap: 14px; }
.sight-word-card {
  background: white; border-radius: var(--radius); padding: 20px 24px;
  display: flex; align-items: center; justify-content: space-between;
  box-shadow: 0 3px 15px var(--shadow); cursor: pointer; transition: all 0.3s;
}
.sight-word-card:hover { transform: translateY(-3px); box-shadow: 0 6px 20px var(--shadow); }
.sight-word-card:active { transform: scale(0.97); }
.sight-word-text { font-family: 'Fredoka', sans-serif; font-size: 2rem; font-weight: 700; color: var(--text); }
.sight-word-chinese { font-size: 1rem; color: #636E72; margin-top: 2px; }
.sight-word-card .play-icon {
  width: 48px; height: 48px; border-radius: 50%;
  background: linear-gradient(135deg, #A29BFE, #6C5CE7);
  display: flex; align-items: center; justify-content: center;
  color: white; font-size: 1.3rem; flex-shrink: 0;
}
.sight-word-card.speaking { border-left: 5px solid var(--accent); }

/* Speed toggle */
.speed-toggle {
  display: flex; gap: 6px; justify-content: center; margin: 10px 0;
}
.speed-btn {
  padding: 6px 14px; border-radius: 50px;
  border: 2px solid #DFE6E9; background: white;
  font-family: 'Fredoka', sans-serif; font-size: 0.85rem; font-weight: 600;
  cursor: pointer; color: #636E72; transition: all 0.2s;
}
.speed-btn.active { border-color: var(--accent); background: #F0EDFF; color: var(--accent); }

.confetti-box { position: fixed; inset: 0; pointer-events: none; z-index: 100; }
.confetti-piece {
  position: absolute; width: 10px; height: 10px; border-radius: 2px;
  animation: confDrop 2s ease-out forwards;
}
@keyframes confDrop {
  0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
  100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
}

/* ===== MINE ===== */
.mine-header { text-align: center; margin-bottom: 12px; }
.mine-header h3 { font-family: 'Fredoka', sans-serif; font-size: 1.3rem; color: var(--text); }
.mine-pickaxe { font-size: 1rem; color: #636E72; margin-top: 4px; }
.mine-cost { font-size: 0.9rem; color: var(--accent); margin-top: 2px; }

.mountain {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  margin: 0 auto;
  padding: 10px 0;
  background: linear-gradient(180deg, #87CEEB 0%, #87CEEB 20%, #E8D5B7 100%);
  border-radius: var(--radius);
  overflow: hidden;
}
.mountain-row {
  display: flex;
  gap: 2px;
}
.mine-cell {
  width: 38px; height: 38px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.3rem;
  cursor: pointer;
  transition: all 0.15s;
  border: 1px solid rgba(0,0,0,0.15);
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.2);
  position: relative;
  user-select: none;
}
.mine-cell:hover:not(.mined):not(.locked) { transform: scale(1.12); z-index: 2; box-shadow: 0 0 8px rgba(255,255,255,0.5); }
.mine-cell:active:not(.mined):not(.locked) { transform: scale(0.9); }
.mine-cell.unexposed { opacity: 0.85; cursor: default; }
.mine-cell.unexposed:hover { transform: none; box-shadow: inset 0 -2px 4px rgba(0,0,0,0.2); }
.mine-cell.mined {
  background: #1a1a2e !important;
  border-color: #0d0d1a;
  box-shadow: inset 0 2px 6px rgba(0,0,0,0.5);
  pointer-events: none;
}
.mine-cell.locked {
  cursor: not-allowed;
  position: relative;
}
.mine-cell.locked::after {
  content: 'ğŸ”’';
  position: absolute;
  font-size: 0.8rem;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.4);
  border-radius: 4px;
}
.mine-cell .block-reveal {
  animation: blockPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
@keyframes blockPop {
  0% { transform: scale(0) rotate(-20deg); opacity: 0; }
  60% { transform: scale(1.3) rotate(5deg); opacity: 1; }
  100% { transform: scale(1) rotate(0); }
}
.mine-cell.tier1 { background: linear-gradient(180deg, #8B6F47, #6B4F37); }
.mine-cell.tier2 { background: linear-gradient(180deg, #7F8C8D, #616A6B); }
.mine-cell.tier3 { background: linear-gradient(180deg, #5D6D7E, #4A5568); }
.mine-cell.tier4 { background: linear-gradient(180deg, #6B4C3B, #4A3728); }
.mine-cell.tier5 { background: linear-gradient(180deg, #2C3E6D, #1A2547); }
.mine-cell.tree { background: none; border: none; box-shadow: none; font-size: 1.5rem; cursor: default; pointer-events: none; }

.mine-result {
  text-align: center; margin-top: 12px; padding: 10px;
  font-family: 'Fredoka', sans-serif; font-size: 1.05rem; font-weight: 600;
  min-height: 44px;
}
.mine-refresh {
  display: block; margin: 10px auto 0;
  padding: 10px 28px; border-radius: 50px; border: none;
  background: linear-gradient(135deg, #A29BFE, #6C5CE7);
  color: white;
  font-family: 'Fredoka', sans-serif; font-size: 1rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
  box-shadow: 0 4px 15px rgba(108,92,231,0.3);
}
.mine-refresh:hover { transform: translateY(-2px); }
.mine-refresh:disabled { opacity: 0.4; pointer-events: none; }

/* ===== COLLECTION ===== */
.collection-tabs { display: flex; gap: 8px; justify-content: center; margin-bottom: 16px; }
.collection-tab {
  padding: 8px 16px; border-radius: 50px; border: 2px solid #DFE6E9;
  background: white; font-family: 'Fredoka', sans-serif; font-size: 0.9rem;
  font-weight: 600; cursor: pointer; color: #636E72; transition: all 0.2s;
}
.collection-tab.active { border-color: var(--accent); background: #F0EDFF; color: var(--accent); }

.encyclopedia-grid {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
  gap: 12px;
}
.block-card {
  background: white; border-radius: var(--radius); padding: 14px;
  text-align: center; box-shadow: 0 2px 10px var(--shadow);
  border: 3px solid #DFE6E9; transition: all 0.3s;
}
.block-card.owned { border-color: #00B894; }
.block-card.undiscovered { opacity: 0.4; }
.block-card .block-emoji { font-size: 2.2rem; margin-bottom: 6px; }
.block-card .block-name { font-family: 'Fredoka', sans-serif; font-size: 1rem; font-weight: 600; }
.block-card .block-count { font-size: 0.85rem; color: #636E72; margin-top: 2px; }
.block-card .block-tier { font-size: 0.7rem; color: var(--accent); margin-top: 2px; }

.craft-area { max-width: 500px; margin: 0 auto; }
.craft-current { text-align: center; font-family: 'Fredoka', sans-serif; color: #636E72; margin-bottom: 12px; font-size: 1rem; }

.craft-table {
  display: flex; align-items: center; justify-content: center;
  gap: 16px; flex-wrap: wrap; margin-bottom: 16px;
}
.craft-grid {
  display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px;
  background: #8B6F47; padding: 8px; border-radius: 12px;
  box-shadow: inset 0 2px 6px rgba(0,0,0,0.3), 0 3px 10px var(--shadow);
}
.craft-slot {
  width: 52px; height: 52px; border-radius: 6px;
  background: #A0855C; border: 2px solid #6B4F37;
  display: flex; align-items: center; justify-content: center;
  font-size: 1.6rem; cursor: pointer; transition: all 0.15s;
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.15);
}
.craft-slot:hover { background: #B8976A; transform: scale(1.05); }
.craft-slot.filled { background: #C4A97D; border-color: #8B6F47; }

.craft-arrow { font-size: 1.8rem; color: #636E72; }

.craft-result-slot {
  width: 64px; height: 64px; border-radius: 8px;
  background: #A0855C; border: 3px solid #6B4F37;
  display: flex; align-items: center; justify-content: center;
  font-size: 2rem; position: relative;
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.15);
}
.craft-result-slot.matched {
  border-color: #00B894; background: #C4A97D;
  animation: correctBounce 0.5s ease;
}

.craft-actions { display: flex; gap: 8px; justify-content: center; margin-bottom: 16px; }
.craft-btn {
  padding: 10px 24px; border-radius: 50px; border: none;
  font-family: 'Fredoka', sans-serif; font-size: 1rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
}
.craft-btn:hover { transform: translateY(-2px); }
.craft-btn:disabled { opacity: 0.4; pointer-events: none; }
.craft-btn.primary { background: linear-gradient(135deg, #00B894, #00CEC9); color: white; box-shadow: 0 4px 15px rgba(0,184,148,0.3); }
.craft-btn.secondary { background: linear-gradient(135deg, #DFE6E9, #BDC3C7); color: #2D3436; }

.craft-inventory {
  background: #8B6F47; border-radius: 12px; padding: 10px;
  box-shadow: inset 0 2px 6px rgba(0,0,0,0.3), 0 3px 10px var(--shadow);
}
.craft-inv-title {
  font-family: 'Fredoka', sans-serif; font-size: 0.9rem;
  color: #E8D5B7; margin-bottom: 8px; text-align: center;
}
.craft-inv-grid {
  display: flex; flex-wrap: wrap; gap: 4px; justify-content: center;
}
.craft-inv-item {
  width: 48px; height: 48px; border-radius: 6px;
  background: #A0855C; border: 2px solid #6B4F37;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  font-size: 1.2rem; cursor: pointer; transition: all 0.15s;
  position: relative;
}
.craft-inv-item:hover { background: #B8976A; transform: scale(1.08); }
.craft-inv-item.selected { border-color: #FFD93D; background: #C4A97D; box-shadow: 0 0 8px rgba(255,217,61,0.5); }
.craft-inv-item .inv-count {
  font-size: 0.55rem; font-weight: 700; color: #FFF;
  background: rgba(0,0,0,0.5); border-radius: 4px; padding: 0 3px;
  position: absolute; bottom: 2px; right: 2px;
}

.house-area { text-align: center; max-width: 400px; margin: 0 auto; }
.house-visual {
  font-size: 1.2rem; line-height: 1.8;
  background: white; border-radius: var(--radius); padding: 24px;
  box-shadow: 0 2px 10px var(--shadow); margin-bottom: 16px;
  min-height: 180px; display: flex; align-items: center; justify-content: center;
  white-space: pre; font-family: 'Fredoka', sans-serif;
}
.house-stage {
  background: white; border-radius: 14px; padding: 14px 18px;
  margin-bottom: 10px; box-shadow: 0 2px 10px var(--shadow);
  display: flex; align-items: center; justify-content: space-between;
}
.house-stage.done { border-left: 4px solid #00B894; }
.house-stage.current { border-left: 4px solid var(--accent); }
.house-stage.locked { opacity: 0.5; }
.house-stage-info { text-align: left; }
.house-stage-name { font-family: 'Fredoka', sans-serif; font-weight: 600; }
.house-stage-needs { font-size: 0.85rem; color: #636E72; margin-top: 2px; }
.house-build-btn {
  padding: 8px 18px; border-radius: 50px; border: none;
  background: linear-gradient(135deg, #FFD93D, #FDCB6E); color: #2D3436;
  font-family: 'Fredoka', sans-serif; font-size: 0.9rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
}
.house-build-btn:disabled { opacity: 0.4; pointer-events: none; }

@media (max-width: 600px) {
  .header h1 { font-size: 1.8rem; }
  .feelings-grid { grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap: 10px; }
  .feeling-card { padding: 14px 8px; }
  .feeling-card .emoji { font-size: 2.2rem; }
  .match-game { grid-template-columns: 1fr; }
  .quiz-options { grid-template-columns: 1fr; }
  .nav-tab { padding: 8px 14px; font-size: 0.9rem; }
  .sentence-display { font-size: 1.2rem; }
  .mine-cell { width: 32px; height: 32px; font-size: 1.1rem; }
  .mine-cell.tree { font-size: 1.3rem; }
  .encyclopedia-grid { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); }
  .craft-slot { width: 44px; height: 44px; font-size: 1.3rem; }
  .craft-result-slot { width: 52px; height: 52px; font-size: 1.6rem; }
  .craft-inv-item { width: 40px; height: 40px; font-size: 1rem; }
  .collection-tab { padding: 6px 12px; font-size: 0.8rem; }
}
</style>
</head>
<body>

<div class="app">
  <div class="header">
    <h1>Feelings Fun! ğŸ­</h1>
    <div class="subtitle">å­¸ç¿’è¡¨é”æƒ…ç·’çš„è‹±æ–‡ Â· Learn to express feelings</div>
    <div style="font-size:0.7rem;color:#B2BEC3;margin-top:2px;font-family:'Nunito',sans-serif;">v2.1.1</div>
  </div>

  <div class="score-bar">
    <div class="score-item" id="starBar"><span>â­</span> <span id="stars">0</span> Stars</div>
    <div class="score-item" id="streakBar"><span>ğŸ”¥</span> <span id="streak">0</span> Streak</div>
    <div class="score-item" id="gemBar"><span>ğŸ’</span> <span id="gems">0</span> Gems</div>
  </div>

  <div class="speed-toggle">
    <button class="speed-btn" data-speed="slow" id="speedSlow">ğŸ¢ Slow</button>
    <button class="speed-btn active" data-speed="normal" id="speedNormal">ğŸ‡ Normal</button>
  </div>
  <div id="engineStatus" style="text-align:center;font-size:0.8rem;color:#B2BEC3;margin-bottom:6px;font-family:'Nunito',sans-serif;">ğŸ” åµæ¸¬ä¸­...</div>

  <div class="nav-tabs">
    <button class="nav-tab active" data-tab="learn">ğŸ“– Learn</button>
    <button class="nav-tab" data-tab="match">ğŸ¯ Match</button>
    <button class="nav-tab" data-tab="quiz">ğŸ§  Quiz</button>
    <button class="nav-tab" data-tab="sight">ğŸ‘€ Sight Words</button>
    <button class="nav-tab" data-tab="mine">â›ï¸ Mine</button>
    <button class="nav-tab" data-tab="collection">ğŸ“– Collection</button>
  </div>

  <div id="learn" class="section active">
    <div class="feelings-grid" id="feelingsGrid"></div>
    <div class="sentence-practice">
      <h3>ğŸ—£ï¸ Practice Sentences é€ å¥ç·´ç¿’</h3>
      <div class="sentence-display" id="sentenceDisplay">I feel <span class="hl">happy</span>. ğŸ˜Š</div>
      <div class="btn-row">
        <button class="speak-btn primary" id="speakSentenceBtn">ğŸ”Š Listen è½ç™¼éŸ³</button>
        <button class="speak-btn secondary" id="randomSentenceBtn">ğŸ² Random éš¨æ©Ÿ</button>
      </div>
      <div class="feeling-chips" id="feelingChips"></div>
    </div>
  </div>

  <div id="match" class="section">
    <div class="match-feedback" id="matchFeedback">é»ä¸€å€‹å–®å­—ï¼Œå†é»é…å°çš„è¡¨æƒ…ï¼ ğŸ¯</div>
    <div class="match-game" id="matchGame">
      <div class="match-column" id="matchWords"><h3>Words å–®å­—</h3></div>
      <div class="match-column" id="matchEmojis"><h3>Emoji è¡¨æƒ…</h3></div>
    </div>
    <button class="reset-btn" id="resetMatch">ğŸ”„ New Round å†ä¾†ä¸€æ¬¡</button>
  </div>

  <div id="quiz" class="section">
    <div class="quiz-container" id="quizContainer"></div>
  </div>

  <div id="sight" class="section">
    <div class="sight-words-area" id="sightWordsArea"></div>
  </div>

  <div id="mine" class="section">
    <div id="mineArea"></div>
  </div>

  <div id="collection" class="section">
    <div id="collectionArea"></div>
  </div>
</div>

<div class="confetti-box" id="confettiBox"></div>

<script>
// ===== DATA =====
const feelings = [
  { word: 'happy',   zh: 'é–‹å¿ƒçš„', emoji: 'ğŸ˜Š', color: '#FFD93D' },
  { word: 'sad',     zh: 'é›£éçš„', emoji: 'ğŸ˜¢', color: '#74B9FF' },
  { word: 'angry',   zh: 'ç”Ÿæ°£çš„', emoji: 'ğŸ˜ ', color: '#FF6B6B' },
  { word: 'excited', zh: 'èˆˆå¥®çš„', emoji: 'ğŸ¤©', color: '#FF85CA' },
  { word: 'silly',   zh: 'å‚»å‚»çš„', emoji: 'ğŸ¤ª', color: '#A29BFE' },
  { word: 'tired',   zh: 'ç´¯çš„',   emoji: 'ğŸ˜´', color: '#B2BEC3' },
  { word: 'scared',  zh: 'å®³æ€•çš„', emoji: 'ğŸ˜¨', color: '#81ECEC' },
  { word: 'bored',   zh: 'ç„¡èŠçš„', emoji: 'ğŸ˜‘', color: '#FFEAA7' },
  { word: 'sick',    zh: 'ä¸èˆ’æœçš„', emoji: 'ğŸ¤’', color: '#55EFC4' },
  { word: 'proud',   zh: 'é©•å‚²çš„', emoji: 'ğŸ˜', color: '#FD79A8' },
  { word: 'brave',   zh: 'å‹‡æ•¢çš„', emoji: 'ğŸ’ª', color: '#E17055' },
  { word: 'mad',     zh: 'å¾ˆç”Ÿæ°£', emoji: 'ğŸ˜¤', color: '#D63031' },
];

const sightWords = [
  { word: 'door',  zh: 'é–€', sentence: 'Open the door.' },
  { word: 'down',  zh: 'ä¸‹é¢', sentence: 'Sit down please.' },
  { word: 'dress', zh: 'æ´‹è£', sentence: 'I like your dress.' },
  { word: 'duck',  zh: 'é´¨å­', sentence: 'Look at the duck!' },
  { word: 'each',  zh: 'æ¯ä¸€å€‹', sentence: 'Give one to each child.' },
  { word: 'egg',   zh: 'è›‹', sentence: 'I eat an egg.' },
  { word: 'every', zh: 'æ¯å€‹', sentence: 'Every day is special.' },
];
const sightColors = ['#FF6B6B','#A29BFE','#FFD93D','#00B894','#FF85CA','#74B9FF','#E17055'];

// ===== MINING DATA =====
const blocks = [
  { id: 'dirt',     name: 'æ³¥åœŸ',   emoji: 'ğŸŸ«', tier: 1, weight: 40 },
  { id: 'wood',     name: 'æœ¨é ­',   emoji: 'ğŸªµ', tier: 1, weight: 35 },
  { id: 'stone',    name: 'çŸ³é ­',   emoji: 'ğŸª¨', tier: 2, weight: 30 },
  { id: 'coal',     name: 'ç…¤ç‚­',   emoji: 'â¬›', tier: 2, weight: 25 },
  { id: 'iron',     name: 'éµç¤¦',   emoji: 'â¬œ', tier: 3, weight: 18 },
  { id: 'copper',   name: 'éŠ…ç¤¦',   emoji: 'ğŸŸ§', tier: 3, weight: 15 },
  { id: 'gold',     name: 'é‡‘ç¤¦',   emoji: 'ğŸŸ¡', tier: 4, weight: 8 },
  { id: 'emerald',  name: 'ç¶ å¯¶çŸ³', emoji: 'ğŸ’š', tier: 4, weight: 5 },
  { id: 'diamond',  name: 'é‘½çŸ³',   emoji: 'ğŸ’', tier: 5, weight: 3 },
  { id: 'amethyst', name: 'ç´«æ°´æ™¶', emoji: 'ğŸŸ£', tier: 5, weight: 2 },
];

const pickaxes = [
  { id: 'wood_pick',  name: 'æœ¨é¬',  emoji: 'ğŸª“', maxTier: 2, recipe: null, pattern: null },
  { id: 'stone_pick', name: 'çŸ³é¬',  emoji: 'â›ï¸', maxTier: 3,
    recipe: { wood: 2, stone: 3 },
    pattern: ['stone','stone','stone', null,'wood',null, null,'wood',null] },
  { id: 'iron_pick',  name: 'éµé¬',  emoji: 'â›ï¸', maxTier: 4,
    recipe: { wood: 2, iron: 3 },
    pattern: ['iron','iron','iron', null,'wood',null, null,'wood',null] },
  { id: 'gold_pick',  name: 'é‡‘é¬',  emoji: 'ğŸ”±', maxTier: 5,
    recipe: { iron: 2, gold: 3 },
    pattern: ['gold','gold','gold', null,'iron',null, null,'iron',null] },
];

const houseStages = [
  { name: 'åœ°åŸº',  needs: { stone: 6 },             emoji: 'ğŸ§±' },
  { name: 'ç‰†å£',  needs: { wood: 8 },              emoji: 'ğŸ—ï¸' },
  { name: 'å±‹é ‚',  needs: { wood: 4, iron: 2 },     emoji: 'ğŸ ' },
  { name: 'è£é£¾',  needs: { gold: 1, emerald: 1 },  emoji: 'ğŸ¡' },
];

const tierColors = ['#8B7355', '#A0A0A0', '#C0C0C0', '#FFD700', '#B9F2FF'];

// ===== STATE =====
let stars = 0, streak = 0, currentFeeling = 'happy';
let matchSelected = null, matchedPairs = new Set();
let quizQuestions = [], quizIndex = 0, quizScore = 0, quizAnswered = false;
let speechSpeed = 'normal'; // 'slow' or 'normal'

// ===== MINING STATE =====
let gems = 0;
let inventory = {};
let pickaxeLevel = 0;
let houseProgress = 0;

function saveGame() {
  localStorage.setItem('mineGame', JSON.stringify({ gems, inventory, pickaxeLevel, houseProgress, stars, streak }));
}

function loadGame() {
  try {
    const d = JSON.parse(localStorage.getItem('mineGame'));
    if (!d) return;
    gems = d.gems || 0;
    inventory = d.inventory || {};
    pickaxeLevel = d.pickaxeLevel || 0;
    houseProgress = d.houseProgress || 0;
    stars = d.stars || 0;
    streak = d.streak || 0;
    document.getElementById('stars').textContent = Math.floor(stars);
    document.getElementById('streak').textContent = streak;
    updateGemDisplay();
  } catch (e) { console.warn('Failed to load save', e); }
}

function addGems(n) {
  gems += n;
  updateGemDisplay();
  saveGame();
}

function updateGemDisplay() {
  const el = document.getElementById('gems');
  if (el) el.textContent = gems;
  const bar = document.getElementById('gemBar');
  if (bar) { bar.classList.remove('pop'); void bar.offsetWidth; bar.classList.add('pop'); }
}

function getBlockCount(id) { return inventory[id] || 0; }

function addBlock(id, n) {
  inventory[id] = (inventory[id] || 0) + (n || 1);
  saveGame();
}

function removeBlocks(recipe) {
  for (const [id, count] of Object.entries(recipe)) {
    inventory[id] = (inventory[id] || 0) - count;
    if (inventory[id] <= 0) delete inventory[id];
  }
  saveGame();
}

function hasBlocks(recipe) {
  return Object.entries(recipe).every(([id, count]) => getBlockCount(id) >= count);
}

// ===== TTS ENGINE =====
// Primary: SpeechSynthesis with smart voice selection
// macOS has many novelty voices (Albert, Bad News, Bells, etc.) â€” filter those out
let lastEngine = 'none';
let cachedVoice = null;

const noveltyVoices = new Set([
  'Albert','Bad News','Bahh','Bells','Boing','Bubbles','Cellos','Good News',
  'Jester','Organ','Superstar','Trinoids','Whisper','Wobble','Zarvox',
  'Ralph','Fred','Kathy','Junior','Princess'
]);

function pickBestVoice(voices) {
  if (cachedVoice) return cachedVoice;
  const preferred = ['Samantha','Alex','Karen','Daniel','Moira','Tessa','Ava','Tom','Allison'];
  for (const name of preferred) {
    const v = voices.find(v => v.name.includes(name) && v.lang.startsWith('en'));
    if (v) { cachedVoice = v; return v; }
  }
  const enUS = voices.filter(v => v.lang === 'en-US' && !noveltyVoices.has(v.name));
  if (enUS.length) { cachedVoice = enUS[0]; return enUS[0]; }
  const en = voices.filter(v => v.lang.startsWith('en') && !noveltyVoices.has(v.name));
  if (en.length) { cachedVoice = en[0]; return en[0]; }
  cachedVoice = voices.find(v => v.lang.startsWith('en')) || voices[0];
  return cachedVoice;
}

// Unlock SpeechSynthesis on first user interaction (iOS requirement)
function unlockAudio() {
  if (window.speechSynthesis) {
    const u = new SpeechSynthesisUtterance('');
    u.volume = 0;
    speechSynthesis.speak(u);
  }
}
document.addEventListener('touchstart', unlockAudio, { once: true });
document.addEventListener('click', unlockAudio, { once: true });

function updateEngineDisplay(engine, detail) {
  lastEngine = engine;
  const el = document.getElementById('engineStatus');
  if (engine === 'speech-synthesis') {
    el.textContent = `ğŸŸ¢ SpeechSynthesis${detail ? ' â€” ' + detail : ''}`;
    el.style.color = '#00B894';
  } else if (engine === 'error') {
    el.textContent = `ğŸ”´ ç„¡æ³•ç™¼éŸ³${detail ? ' â€” ' + detail : ''}`;
    el.style.color = '#FF6B6B';
  } else {
    el.textContent = 'ğŸ” åµæ¸¬ä¸­...';
    el.style.color = '#B2BEC3';
  }
}

function speak(text, forceSpeed) {
  const synth = window.speechSynthesis;
  if (!synth) {
    updateEngineDisplay('error', 'SpeechSynthesis not available');
    return null;
  }
  synth.cancel();

  const speed = forceSpeed || speechSpeed;
  const slow = speed === 'slow';
  const u = new SpeechSynthesisUtterance(text);
  u.lang = 'en-US';
  u.rate = slow ? 0.6 : 0.85;
  u.pitch = 1.05;
  const pick = pickBestVoice(synth.getVoices());
  if (pick) u.voice = pick;
  u.onstart = () => updateEngineDisplay('speech-synthesis', pick ? pick.name : 'default voice');
  u.onerror = (e) => updateEngineDisplay('error', e.error);
  synth.speak(u);
  return u;
}

// Speak word first, then sentence after a pause
function speakWordThenSentence(word, sentence) {
  const synth = window.speechSynthesis;
  if (!synth) return;
  synth.cancel();

  const speed = speechSpeed;
  const slow = speed === 'slow';
  const u = new SpeechSynthesisUtterance(word);
  u.lang = 'en-US';
  u.rate = slow ? 0.6 : 0.85;
  u.pitch = 1.05;
  const pick = pickBestVoice(synth.getVoices());
  if (pick) u.voice = pick;
  u.onstart = () => updateEngineDisplay('speech-synthesis', pick ? pick.name : 'default voice');
  u.onend = () => {
    setTimeout(() => speak(sentence), 400);
  };
  u.onerror = (e) => updateEngineDisplay('error', e.error);
  synth.speak(u);
}

// ===== SPEED TOGGLE =====
document.querySelectorAll('.speed-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    speechSpeed = btn.dataset.speed;
  });
});

// ===== SFX (Web Audio API) =====
let audioCtx = null;
function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

function playMineSfx(tier) {
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();

  // Noise burst â€” sounds like stone breaking
  const bufferSize = ctx.sampleRate * 0.08;
  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize); // decaying noise
  }
  const noise = ctx.createBufferSource();
  noise.buffer = buffer;

  // Filter â€” higher tier = higher pitch
  const filter = ctx.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.value = 400 + tier * 200;
  filter.Q.value = 1.5;

  const gain = ctx.createGain();
  gain.gain.value = 0.3;
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);

  noise.connect(filter).connect(gain).connect(ctx.destination);
  noise.start();
  noise.stop(ctx.currentTime + 0.08);

  // Extra "ding" for rare blocks (tier 4+)
  if (tier >= 4) {
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = tier >= 5 ? 1200 : 900;
    const oscGain = ctx.createGain();
    oscGain.gain.value = 0.15;
    oscGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);
    osc.connect(oscGain).connect(ctx.destination);
    osc.start(ctx.currentTime + 0.05);
    osc.stop(ctx.currentTime + 0.3);
  }
}

function playLockedSfx() {
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();
  const osc = ctx.createOscillator();
  osc.type = 'square';
  osc.frequency.value = 120;
  const gain = ctx.createGain();
  gain.gain.value = 0.1;
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
  osc.connect(gain).connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.15);
}

function playCraftSfx() {
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();
  // Ascending arpeggio
  [0, 1, 2].forEach((i) => {
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = 600 + i * 200;
    const gain = ctx.createGain();
    gain.gain.value = 0.12;
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15 + i * 0.1);
    osc.connect(gain).connect(ctx.destination);
    osc.start(ctx.currentTime + i * 0.1);
    osc.stop(ctx.currentTime + 0.15 + i * 0.1);
  });
}

function playPlaceSfx() {
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();
  const osc = ctx.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = 500;
  const gain = ctx.createGain();
  gain.gain.value = 0.08;
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.06);
  osc.connect(gain).connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.06);
}

// ===== UTILS =====
function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function addStars(n) {
  stars += n;
  document.getElementById('stars').textContent = Math.floor(stars);
  const el = document.getElementById('starBar');
  el.classList.remove('pop');
  void el.offsetWidth;
  el.classList.add('pop');
  saveGame();
}

function bumpStreak() {
  streak++;
  document.getElementById('streak').textContent = streak;
  const el = document.getElementById('streakBar');
  el.classList.remove('pop');
  void el.offsetWidth;
  el.classList.add('pop');
}

function resetStreak() { streak = 0; document.getElementById('streak').textContent = 0; }

function doConfetti() {
  const box = document.getElementById('confettiBox');
  const colors = ['#FFD93D','#FF6B6B','#A29BFE','#FF85CA','#00B894','#74B9FF'];
  for (let i = 0; i < 35; i++) {
    const p = document.createElement('div');
    p.className = 'confetti-piece';
    p.style.left = Math.random() * 100 + '%';
    p.style.background = colors[Math.floor(Math.random() * colors.length)];
    p.style.animationDelay = Math.random() * 0.5 + 's';
    p.style.animationDuration = (1.5 + Math.random()) + 's';
    const size = 6 + Math.random() * 8;
    p.style.width = size + 'px';
    p.style.height = size + 'px';
    box.appendChild(p);
  }
  setTimeout(() => box.innerHTML = '', 3000);
}

// ===== NAV =====
document.querySelectorAll('.nav-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById(tab.dataset.tab).classList.add('active');
    if (tab.dataset.tab === 'match') initMatch();
    if (tab.dataset.tab === 'quiz') initQuiz();
    if (tab.dataset.tab === 'sight') initSightWords();
    if (tab.dataset.tab === 'mine') initMine();
    if (tab.dataset.tab === 'collection') initCollection();
  });
});

// ===== LEARN =====
function initLearn() {
  const grid = document.getElementById('feelingsGrid');
  grid.innerHTML = '';
  feelings.forEach(f => {
    const card = document.createElement('div');
    card.className = 'feeling-card';
    card.innerHTML = `
      <span class="speaker-hint">ğŸ”Š</span>
      <span class="emoji">${f.emoji}</span>
      <div class="word">${f.word}</div>
      <div class="chinese">${f.zh}</div>
    `;
    card.style.borderBottom = `4px solid ${f.color}`;
    card.addEventListener('click', () => {
      card.classList.add('speaking');
      setTimeout(() => card.classList.remove('speaking'), 800);
      speak(f.word);
      selectFeeling(f.word);
    });
    grid.appendChild(card);
  });

  const chips = document.getElementById('feelingChips');
  chips.innerHTML = '';
  feelings.forEach(f => {
    const chip = document.createElement('button');
    chip.className = 'feeling-chip' + (f.word === currentFeeling ? ' selected' : '');
    chip.textContent = `${f.emoji} ${f.word}`;
    chip.addEventListener('click', () => {
      selectFeeling(f.word);
      speak(`I feel ${f.word}.`);
    });
    chips.appendChild(chip);
  });
}

function selectFeeling(word) {
  currentFeeling = word;
  const f = feelings.find(x => x.word === word);
  document.getElementById('sentenceDisplay').innerHTML =
    `I feel <span class="hl">${word}</span>. ${f?.emoji || ''}`;
  document.querySelectorAll('.feeling-chip').forEach(c => {
    c.classList.toggle('selected', c.textContent.includes(word));
  });
}

document.getElementById('speakSentenceBtn').addEventListener('click', () => speak(`I feel ${currentFeeling}.`));
document.getElementById('randomSentenceBtn').addEventListener('click', () => {
  const r = feelings[Math.floor(Math.random() * feelings.length)];
  selectFeeling(r.word);
  speak(`I feel ${r.word}.`);
});

// ===== MATCH =====
function initMatch() {
  const pool = shuffle(feelings).slice(0, 6);
  const wCol = document.getElementById('matchWords');
  const eCol = document.getElementById('matchEmojis');
  wCol.innerHTML = '<h3>Words å–®å­—</h3>';
  eCol.innerHTML = '<h3>Emoji è¡¨æƒ…</h3>';
  matchSelected = null;
  matchedPairs = new Set();
  document.getElementById('matchFeedback').textContent = 'é»ä¸€å€‹å–®å­—ï¼Œå†é»é…å°çš„è¡¨æƒ…ï¼ ğŸ¯';

  shuffle(pool).forEach(f => {
    const item = document.createElement('div');
    item.className = 'match-item';
    item.textContent = f.word;
    item.dataset.word = f.word;
    item.dataset.type = 'word';
    item.addEventListener('click', () => matchClick(item));
    wCol.appendChild(item);
  });
  shuffle(pool).forEach(f => {
    const item = document.createElement('div');
    item.className = 'match-item emoji-item';
    item.textContent = f.emoji;
    item.dataset.word = f.word;
    item.dataset.type = 'emoji';
    item.addEventListener('click', () => matchClick(item));
    eCol.appendChild(item);
  });
}

function matchClick(item) {
  if (item.classList.contains('matched')) return;

  if (!matchSelected) {
    matchSelected = item;
    item.classList.add('selected');
    if (item.dataset.type === 'word') speak(item.dataset.word);
    return;
  }
  if (matchSelected === item) {
    item.classList.remove('selected');
    matchSelected = null;
    return;
  }
  if (matchSelected.dataset.type === item.dataset.type) {
    matchSelected.classList.remove('selected');
    matchSelected = item;
    item.classList.add('selected');
    if (item.dataset.type === 'word') speak(item.dataset.word);
    return;
  }

  if (matchSelected.dataset.word === item.dataset.word) {
    const prev = matchSelected;
    prev.classList.remove('selected');
    prev.classList.add('correct');
    item.classList.add('correct');
    const f = feelings.find(x => x.word === item.dataset.word);
    speak(item.dataset.word);
    document.getElementById('matchFeedback').textContent = `âœ… ${f?.emoji} ${f?.word} = ${f?.zh}ï¼`;
    addStars(1); bumpStreak(); addGems(1);
    setTimeout(() => {
      prev.classList.add('matched'); prev.classList.remove('correct');
      item.classList.add('matched'); item.classList.remove('correct');
    }, 600);
    matchedPairs.add(item.dataset.word);
    if (matchedPairs.size >= 6) {
      setTimeout(() => {
        document.getElementById('matchFeedback').textContent = 'ğŸ‰ å…¨éƒ¨é…å°å®Œæˆï¼å¤ªæ£’äº†ï¼';
        addStars(3); doConfetti(); addGems(2);
      }, 700);
    }
  } else {
    const prev = matchSelected;
    prev.classList.add('wrong'); item.classList.add('wrong');
    resetStreak();
    document.getElementById('matchFeedback').textContent = 'âŒ å†è©¦ä¸€æ¬¡ï¼';
    setTimeout(() => {
      prev.classList.remove('wrong', 'selected');
      item.classList.remove('wrong');
    }, 500);
  }
  matchSelected = null;
}

document.getElementById('resetMatch').addEventListener('click', initMatch);

// ===== QUIZ =====
function initQuiz() {
  quizQuestions = shuffle(feelings).slice(0, 8).map(f => {
    const others = shuffle(feelings.filter(x => x.word !== f.word)).slice(0, 3);
    return { feeling: f, options: shuffle([f, ...others]), type: Math.random() > 0.5 ? 'e2w' : 'w2e' };
  });
  quizIndex = 0; quizScore = 0;
  renderQuiz();
}

function renderQuiz() {
  const c = document.getElementById('quizContainer');
  if (quizIndex >= quizQuestions.length) {
    const pct = Math.round(quizScore / quizQuestions.length * 100);
    const msg = pct === 100 ? 'ğŸ† Perfect! å®Œç¾ï¼' : pct >= 75 ? 'ğŸŒŸ Great! å¾ˆæ£’ï¼' : 'ğŸ’ª Keep going! åŠ æ²¹ï¼';
    c.innerHTML = `<div class="quiz-result">
      <div class="big-emoji">${pct === 100 ? 'ğŸ‰' : pct >= 75 ? 'ğŸŒŸ' : 'ğŸ’ª'}</div>
      <div class="result-text">${msg}</div>
      <div class="result-detail">${quizScore} / ${quizQuestions.length} ç­”å°</div>
      <button class="speak-btn primary" onclick="initQuiz()">ğŸ”„ å†ä¾†ä¸€æ¬¡</button>
    </div>`;
    if (pct >= 75) { addStars(5); doConfetti(); addGems(3); }
    return;
  }

  const q = quizQuestions[quizIndex];
  quizAnswered = false;
  const dots = quizQuestions.map((_, i) => `<div class="quiz-dot${i < quizIndex ? ' done' : ''}${i === quizIndex ? ' current' : ''}"></div>`).join('');

  if (q.type === 'e2w') {
    c.innerHTML = `
      <div class="quiz-progress">${dots}</div>
      <div class="quiz-prompt">${q.feeling.emoji}</div>
      <div class="quiz-question">é€™æ˜¯ä»€éº¼æ„Ÿè¦ºï¼Ÿ</div>
      <button class="speak-btn small primary" style="margin-bottom:16px" id="quizHint">ğŸ”Š è½æç¤º</button>
      <div class="quiz-options">
        ${q.options.map(o => `<button class="quiz-option" data-word="${o.word}">${o.word}</button>`).join('')}
      </div>`;
  } else {
    c.innerHTML = `
      <div class="quiz-progress">${dots}</div>
      <div class="quiz-prompt" style="font-size:2.2rem;font-family:'Fredoka',sans-serif;font-weight:700">${q.feeling.word}</div>
      <div class="quiz-question">å“ªå€‹è¡¨æƒ…ç¬¦åˆï¼Ÿ</div>
      <button class="speak-btn small primary" style="margin-bottom:16px" id="quizHint">ğŸ”Š è½ç™¼éŸ³</button>
      <div class="quiz-options">
        ${q.options.map(o => `<button class="quiz-option" data-word="${o.word}">${o.emoji} ${o.zh}</button>`).join('')}
      </div>`;
  }

  // Don't auto-speak â€” iOS blocks audio without a direct user gesture.
  // The hint button below lets the user trigger it.

  // Hint button
  c.querySelector('#quizHint')?.addEventListener('click', () => speak(q.feeling.word));

  c.querySelectorAll('.quiz-option').forEach(btn => {
    btn.addEventListener('click', () => {
      if (quizAnswered) return;
      quizAnswered = true;
      const correct = btn.dataset.word === q.feeling.word;
      if (correct) {
        btn.classList.add('correct-answer');
        quizScore++; addStars(1); bumpStreak(); addGems(1);
        speak('Great job!');
      } else {
        btn.classList.add('wrong-answer');
        resetStreak();
        c.querySelector(`[data-word="${q.feeling.word}"]`)?.classList.add('correct-answer');
        speak(q.feeling.word);
      }
      setTimeout(() => { quizIndex++; renderQuiz(); }, 1300);
    });
  });
}

// ===== SIGHT WORDS =====
function initSightWords() {
  const area = document.getElementById('sightWordsArea');
  area.innerHTML = '';

  sightWords.forEach((sw, i) => {
    const card = document.createElement('div');
    card.className = 'sight-word-card';
    card.style.borderLeft = `5px solid ${sightColors[i]}`;
    card.innerHTML = `
      <div>
        <div class="sight-word-text">${sw.word}</div>
        <div class="sight-word-chinese">${sw.zh} â€” "${sw.sentence}"</div>
      </div>
      <div class="play-icon">ğŸ”Š</div>`;
    card.addEventListener('click', () => {
      card.classList.add('speaking');
      setTimeout(() => card.classList.remove('speaking'), 1500);
      speakWordThenSentence(sw.word, sw.sentence);
    });
    area.appendChild(card);
  });

  const extra = document.createElement('div');
  extra.className = 'sentence-practice';
  extra.style.marginTop = '8px';
  extra.innerHTML = `
    <h3>ğŸ“Œ Weekly Quote æ¯é€±ä½³å¥</h3>
    <div class="sentence-display" style="font-size:1.3rem">"Life is better when you are happy." ğŸ˜Š</div>
    <button class="speak-btn primary small" onclick="speak('Life is better when you are happy.')">ğŸ”Š Listen</button>
    <div style="margin-top:18px">
      <h3>ğŸµ Song & Rhyme</h3>
      <div class="sentence-display" style="font-size:1.4rem;margin-top:8px">âœ¨ Hakuna Matata âœ¨</div>
      <button class="speak-btn secondary small" onclick="speak('Hakuna Matata! It means no worries!')">ğŸ”Š Listen</button>
    </div>`;
  area.appendChild(extra);
}

// ===== MINE =====
// Mountain shape: each row = { width, tier } â€” triangle from peak to base
const mountainShape = [
  { width: 2, tier: 0 },  // tree tops (decorative)
  { width: 4, tier: 1 },  // dirt/wood
  { width: 6, tier: 1 },
  { width: 8, tier: 2 },  // stone/coal
  { width: 8, tier: 2 },
  { width: 8, tier: 3 },  // iron/copper
  { width: 8, tier: 3 },
  { width: 8, tier: 4 },  // gold/emerald
  { width: 8, tier: 4 },
  { width: 8, tier: 5 },  // diamond/amethyst
];

let mineData = []; // 2D array: each cell = { block, mined, tier, el } or null

function rollBlockForTier(tier) {
  const pool = blocks.filter(b => b.tier === tier);
  const totalWeight = pool.reduce((s, b) => s + b.weight, 0);
  let r = Math.random() * totalWeight;
  for (const b of pool) {
    r -= b.weight;
    if (r <= 0) return b;
  }
  return pool[pool.length - 1];
}

function isExposed(row, col) {
  if (mineData[row][col] === null || mineData[row][col].mined) return false;
  // Check 4 neighbors â€” if any is outside mountain or mined, this cell is exposed
  const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
  for (const [dr, dc] of dirs) {
    const nr = row + dr, nc = col + dc;
    if (nr < 0 || nr >= mineData.length) return true; // top/bottom edge
    if (nc < 0 || nc >= mineData[nr].length) return true; // side edge
    if (mineData[nr][nc] === null) return true; // outside mountain shape
    if (mineData[nr][nc].mined) return true; // adjacent to mined cell
  }
  return false;
}

function updateExposure() {
  const maxTier = pickaxes[pickaxeLevel].maxTier;
  for (let r = 0; r < mineData.length; r++) {
    for (let c = 0; c < mineData[r].length; c++) {
      const cell = mineData[r][c];
      if (!cell || cell.mined || cell.tier === 0) continue;
      const exposed = isExposed(r, c);
      const locked = cell.tier > maxTier;
      cell.el.classList.toggle('unexposed', !exposed);
      cell.el.classList.toggle('locked', exposed && locked);
    }
  }
}

function initMine() {
  const area = document.getElementById('mineArea');
  const pick = pickaxes[pickaxeLevel];
  area.textContent = '';
  mineData = [];

  // Header
  const header = document.createElement('div');
  header.className = 'mine-header';
  const h3 = document.createElement('h3');
  h3.textContent = 'â›ï¸ æŒ–ç¤¦ Mine';
  const pickInfo = document.createElement('div');
  pickInfo.className = 'mine-pickaxe';
  pickInfo.textContent = `å·¥å…·ï¼š${pick.emoji} ${pick.name}ï¼ˆå¯æŒ–åˆ°ç¬¬ ${pick.maxTier} å±¤ï¼‰`;
  const costInfo = document.createElement('div');
  costInfo.className = 'mine-cost';
  costInfo.textContent = 'æ¯æ ¼èŠ±è²» 1 ğŸ’';
  header.appendChild(h3);
  header.appendChild(pickInfo);
  header.appendChild(costInfo);
  area.appendChild(header);

  // Mountain
  const mountain = document.createElement('div');
  mountain.className = 'mountain';
  const maxWidth = 8;

  mountainShape.forEach((rowDef, r) => {
    const rowEl = document.createElement('div');
    rowEl.className = 'mountain-row';
    const rowData = [];

    // Pad to maxWidth with nulls for consistent indexing
    const offset = Math.floor((maxWidth - rowDef.width) / 2);
    for (let c = 0; c < maxWidth; c++) {
      if (c < offset || c >= offset + rowDef.width) {
        rowData.push(null);
        continue;
      }

      const cellEl = document.createElement('div');
      cellEl.className = 'mine-cell';

      if (rowDef.tier === 0) {
        // Decorative tree row
        cellEl.classList.add('tree');
        cellEl.textContent = Math.random() > 0.5 ? 'ğŸŒ³' : 'ğŸŒ²';
        rowData.push({ tier: 0, mined: false, block: null, el: cellEl });
      } else {
        const block = rollBlockForTier(rowDef.tier);
        cellEl.classList.add('tier' + rowDef.tier);
        const cellData = { tier: rowDef.tier, mined: false, block, el: cellEl };
        cellEl.addEventListener('click', () => mineMountainCell(r, c, cellData));
        rowData.push(cellData);
      }

      rowEl.appendChild(cellEl);
    }

    mineData.push(rowData);
    mountain.appendChild(rowEl);
  });

  area.appendChild(mountain);

  // Result
  const result = document.createElement('div');
  result.className = 'mine-result';
  result.id = 'mineResult';
  area.appendChild(result);

  // Refresh button
  const refreshBtn = document.createElement('button');
  refreshBtn.className = 'mine-refresh';
  refreshBtn.id = 'mineRefresh';
  refreshBtn.textContent = 'ğŸ”„ æ–°å±±é«” New Mountain';
  refreshBtn.addEventListener('click', initMine);
  area.appendChild(refreshBtn);

  updateExposure();
  updateMineRefreshBtn();
}

function mineMountainCell(row, col, cellData) {
  if (cellData.mined || cellData.tier === 0) return;

  const maxTier = pickaxes[pickaxeLevel].maxTier;
  if (cellData.tier > maxTier) {
    playLockedSfx();
    document.getElementById('mineResult').textContent = `ğŸ”’ éœ€è¦æ›´å¥½çš„é¬æ‰èƒ½æŒ–ç¬¬ ${cellData.tier} å±¤ï¼`;
    return;
  }

  if (!isExposed(row, col)) return;

  if (gems < 1) {
    playLockedSfx();
    document.getElementById('mineResult').textContent = 'ğŸ’ é‘‘çŸ³ä¸å¤ ï¼å»ç­”é¡Œè³ºæ›´å¤šå§ï¼';
    return;
  }

  playMineSfx(cellData.tier);
  gems--;
  updateGemDisplay();
  cellData.mined = true;
  cellData.el.classList.add('mined');
  cellData.el.textContent = '';
  const reveal = document.createElement('span');
  reveal.className = 'block-reveal';
  reveal.textContent = cellData.block.emoji;
  cellData.el.appendChild(reveal);
  // Fade out emoji after animation
  setTimeout(() => { cellData.el.textContent = ''; }, 800);

  addBlock(cellData.block.id);

  const b = cellData.block;
  const rarity = b.tier >= 4 ? ' âœ¨ ç¨€æœ‰ï¼' : b.tier >= 3 ? ' ä¸éŒ¯ï¼' : '';
  document.getElementById('mineResult').textContent =
    `${b.emoji} æŒ–åˆ° ${b.name}ï¼${rarity}ï¼ˆæ“æœ‰ ${getBlockCount(b.id)} å€‹ï¼‰`;

  if (b.tier >= 4) doConfetti();
  updateExposure();
  updateMineRefreshBtn();
  saveGame();
}

function updateMineRefreshBtn() {
  const btn = document.getElementById('mineRefresh');
  if (btn) btn.disabled = gems < 1;
}

// ===== COLLECTION =====
let collectionView = 'encyclopedia';

function initCollection() {
  const area = document.getElementById('collectionArea');
  area.textContent = '';

  // Sub-tabs
  const tabs = document.createElement('div');
  tabs.className = 'collection-tabs';
  ['encyclopedia', 'craft', 'house'].forEach(view => {
    const labels = { encyclopedia: 'ğŸ“– åœ–é‘‘', craft: 'ğŸ”¨ åˆæˆ', house: 'ğŸ  è“‹æˆ¿å­' };
    const btn = document.createElement('button');
    btn.className = 'collection-tab' + (collectionView === view ? ' active' : '');
    btn.textContent = labels[view];
    btn.addEventListener('click', () => { collectionView = view; initCollection(); });
    tabs.appendChild(btn);
  });
  area.appendChild(tabs);

  const content = document.createElement('div');
  content.id = 'collectionContent';
  area.appendChild(content);

  if (collectionView === 'encyclopedia') renderEncyclopedia(content);
  else if (collectionView === 'craft') renderCraft(content);
  else renderHouse(content);
}

function renderEncyclopedia(c) {
  const discovered = Object.keys(inventory).length;
  const counter = document.createElement('div');
  counter.style.cssText = 'text-align:center;margin-bottom:12px;font-family:Fredoka,sans-serif;color:#636E72';
  counter.textContent = `å·²ç™¼ç¾ ${discovered} / ${blocks.length} ç¨®æ–¹å¡Š`;
  c.appendChild(counter);

  const grid = document.createElement('div');
  grid.className = 'encyclopedia-grid';
  blocks.forEach(b => {
    const count = getBlockCount(b.id);
    const owned = count > 0;
    const card = document.createElement('div');
    card.className = 'block-card ' + (owned ? 'owned' : 'undiscovered');
    card.style.borderBottomColor = tierColors[b.tier - 1];

    const emoji = document.createElement('div');
    emoji.className = 'block-emoji';
    emoji.textContent = owned ? b.emoji : 'â“';
    const name = document.createElement('div');
    name.className = 'block-name';
    name.textContent = owned ? b.name : '???';
    const cnt = document.createElement('div');
    cnt.className = 'block-count';
    cnt.textContent = owned ? `x${count}` : 'æœªç™¼ç¾';
    const tier = document.createElement('div');
    tier.className = 'block-tier';
    tier.textContent = 'â­'.repeat(b.tier);

    card.appendChild(emoji);
    card.appendChild(name);
    card.appendChild(cnt);
    card.appendChild(tier);
    grid.appendChild(card);
  });
  c.appendChild(grid);
}

// ===== CRAFTING TABLE =====
let craftGrid = [null,null,null, null,null,null, null,null,null]; // 9 slots, block id or null
let craftSelected = null; // selected block id from inventory

function renderCraft(c) {
  craftGrid = [null,null,null, null,null,null, null,null,null];
  craftSelected = null;

  const currentPick = pickaxes[pickaxeLevel];
  const current = document.createElement('div');
  current.className = 'craft-current';
  current.textContent = `ç›®å‰å·¥å…·ï¼š${currentPick.emoji} ${currentPick.name}`;
  c.appendChild(current);

  const area = document.createElement('div');
  area.className = 'craft-area';

  // Craft table: grid + arrow + result
  const table = document.createElement('div');
  table.className = 'craft-table';

  const grid = document.createElement('div');
  grid.className = 'craft-grid';
  grid.id = 'craftGrid';
  for (let i = 0; i < 9; i++) {
    const slot = document.createElement('div');
    slot.className = 'craft-slot';
    slot.dataset.idx = i;
    slot.addEventListener('click', () => craftSlotClick(i));
    grid.appendChild(slot);
  }
  table.appendChild(grid);

  const arrow = document.createElement('div');
  arrow.className = 'craft-arrow';
  arrow.textContent = 'â¡ï¸';
  table.appendChild(arrow);

  const resultSlot = document.createElement('div');
  resultSlot.className = 'craft-result-slot';
  resultSlot.id = 'craftResultSlot';
  table.appendChild(resultSlot);

  area.appendChild(table);

  // Action buttons
  const actions = document.createElement('div');
  actions.className = 'craft-actions';
  const craftBtn = document.createElement('button');
  craftBtn.className = 'craft-btn primary';
  craftBtn.id = 'craftBtn';
  craftBtn.textContent = 'ğŸ”¨ åˆæˆ';
  craftBtn.disabled = true;
  craftBtn.addEventListener('click', doCraft);
  const clearBtn = document.createElement('button');
  clearBtn.className = 'craft-btn secondary';
  clearBtn.textContent = 'ğŸ”„ æ¸…ç©º';
  clearBtn.addEventListener('click', () => {
    // Return all placed blocks to inventory
    craftGrid.forEach(id => { if (id) addBlock(id); });
    craftGrid = [null,null,null, null,null,null, null,null,null];
    updateCraftUI();
  });
  actions.appendChild(craftBtn);
  actions.appendChild(clearBtn);
  area.appendChild(actions);

  // Inventory panel
  const inv = document.createElement('div');
  inv.className = 'craft-inventory';
  const invTitle = document.createElement('div');
  invTitle.className = 'craft-inv-title';
  invTitle.textContent = 'ğŸ’ èƒŒåŒ…ï¼ˆé»é¸æ–¹å¡Šå†æ”¾åˆ°æ ¼å­ä¸Šï¼‰';
  inv.appendChild(invTitle);
  const invGrid = document.createElement('div');
  invGrid.className = 'craft-inv-grid';
  invGrid.id = 'craftInvGrid';
  inv.appendChild(invGrid);
  area.appendChild(inv);

  c.appendChild(area);
  updateCraftUI();
}

function craftSlotClick(idx) {
  if (craftGrid[idx]) {
    // Remove block from grid, return to inventory
    playPlaceSfx();
    addBlock(craftGrid[idx]);
    craftGrid[idx] = null;
    updateCraftUI();
  } else if (craftSelected && getBlockCount(craftSelected) > 0) {
    // Place selected block
    playPlaceSfx();
    craftGrid[idx] = craftSelected;
    // Deduct from inventory (temporarily)
    inventory[craftSelected] = (inventory[craftSelected] || 0) - 1;
    if (inventory[craftSelected] <= 0) delete inventory[craftSelected];
    saveGame();
    updateCraftUI();
  }
}

function checkCraftMatch() {
  for (const pick of pickaxes) {
    if (!pick.pattern) continue;
    if (pickaxeLevel >= pickaxes.indexOf(pick)) continue; // already have
    const match = pick.pattern.every((need, i) => {
      if (need === null) return craftGrid[i] === null;
      return craftGrid[i] === need;
    });
    if (match) return pick;
  }
  return null;
}

function updateCraftUI() {
  // Update grid slots
  const gridEl = document.getElementById('craftGrid');
  if (!gridEl) return;
  const slots = gridEl.children;
  for (let i = 0; i < 9; i++) {
    const slot = slots[i];
    slot.textContent = '';
    slot.classList.toggle('filled', craftGrid[i] !== null);
    if (craftGrid[i]) {
      const b = blocks.find(x => x.id === craftGrid[i]);
      if (b) slot.textContent = b.emoji;
    }
  }

  // Check for recipe match
  const match = checkCraftMatch();
  const resultSlot = document.getElementById('craftResultSlot');
  const craftBtn = document.getElementById('craftBtn');
  if (resultSlot) {
    resultSlot.textContent = match ? match.emoji : '';
    resultSlot.classList.toggle('matched', !!match);
  }
  if (craftBtn) craftBtn.disabled = !match;

  // Update inventory panel
  const invGrid = document.getElementById('craftInvGrid');
  if (!invGrid) return;
  invGrid.textContent = '';
  blocks.forEach(b => {
    const count = getBlockCount(b.id);
    if (count <= 0) return;
    const item = document.createElement('div');
    item.className = 'craft-inv-item' + (craftSelected === b.id ? ' selected' : '');
    item.textContent = b.emoji;
    const countEl = document.createElement('span');
    countEl.className = 'inv-count';
    countEl.textContent = count;
    item.appendChild(countEl);
    item.addEventListener('click', (e) => {
      e.stopPropagation();
      craftSelected = (craftSelected === b.id) ? null : b.id;
      updateCraftUI();
    });
    invGrid.appendChild(item);
  });
}

function doCraft() {
  const match = checkCraftMatch();
  if (!match) return;
  playCraftSfx();
  // Clear the grid (blocks already deducted when placed)
  craftGrid = [null,null,null, null,null,null, null,null,null];
  pickaxeLevel = pickaxes.indexOf(match);
  saveGame();
  doConfetti();
  initCollection();
}

function getHouseArt() {
  const arts = [
    'ğŸŒ³  ğŸŒ¿  ğŸŒ³\n\n   ç©ºåœ°\n\nğŸŒ¿  ğŸŒ³  ğŸŒ¿',
    'ğŸŒ³       ğŸŒ³\n\nğŸ§±ğŸ§±ğŸ§±ğŸ§±\nğŸ§±           ğŸ§±\nğŸ§±ğŸ§±ğŸ§±ğŸ§±',
    'ğŸŒ³       ğŸŒ³\n\nğŸ§±ğŸªµğŸªµğŸ§±\nğŸªµ           ğŸªµ\nğŸ§±ğŸªµğŸªµğŸ§±',
    '     ğŸ”º\n   / ğŸªµ \\\n  / ğŸªµğŸªµ \\\nğŸ§±ğŸªµğŸªµğŸ§±\nğŸªµ  ğŸšª  ğŸªµ\nğŸ§±ğŸªµğŸªµğŸ§±',
    '    â­\n     ğŸ”º\n   / ğŸªµ \\\n  / ğŸªµğŸªµ \\\nğŸ§±ğŸªµğŸªµğŸ§±\nğŸªµ  ğŸšª  ğŸªµ\nğŸ§±ğŸ’šğŸŸ¡ğŸ§±',
  ];
  return arts[houseProgress] || arts[arts.length - 1];
}

function renderHouse(c) {
  const houseArea = document.createElement('div');
  houseArea.className = 'house-area';

  const visual = document.createElement('div');
  visual.className = 'house-visual';
  visual.textContent = getHouseArt();
  houseArea.appendChild(visual);

  const stagesEl = document.createElement('div');
  houseStages.forEach((stage, i) => {
    const done = i < houseProgress;
    const isCurrent = i === houseProgress;
    const canBuild = isCurrent && hasBlocks(stage.needs);

    const el = document.createElement('div');
    el.className = 'house-stage ' + (done ? 'done' : isCurrent ? 'current' : 'locked');

    const info = document.createElement('div');
    info.className = 'house-stage-info';
    const nameEl = document.createElement('div');
    nameEl.className = 'house-stage-name';
    nameEl.textContent = `${stage.emoji} ${stage.name} ${done ? 'âœ…' : ''}`;
    info.appendChild(nameEl);

    const needsEl = document.createElement('div');
    needsEl.className = 'house-stage-needs';
    if (done) {
      needsEl.textContent = 'å®Œæˆ';
    } else {
      Object.entries(stage.needs).forEach(([id, count], idx) => {
        const b = blocks.find(x => x.id === id);
        const have = getBlockCount(id);
        const span = document.createElement('span');
        span.className = have >= count ? 'has' : 'need';
        span.textContent = `${b.emoji} ${have}/${count}`;
        if (idx > 0) needsEl.appendChild(document.createTextNode('  '));
        needsEl.appendChild(span);
      });
    }
    info.appendChild(needsEl);
    el.appendChild(info);

    if (isCurrent) {
      const btn = document.createElement('button');
      btn.className = 'house-build-btn';
      btn.textContent = 'å»ºé€ ';
      btn.disabled = !canBuild;
      btn.addEventListener('click', () => {
        removeBlocks(stage.needs);
        houseProgress++;
        saveGame();
        doConfetti();
        initCollection();
      });
      el.appendChild(btn);
    }

    stagesEl.appendChild(el);
  });
  houseArea.appendChild(stagesEl);
  c.appendChild(houseArea);
}

// ===== INIT =====
loadGame();
initLearn();

// Pre-warm: load voices so pickBestVoice works on first click
if (window.speechSynthesis) {
  speechSynthesis.getVoices();
  speechSynthesis.onvoiceschanged = () => {
    cachedVoice = null; // re-pick on voice list change
    speechSynthesis.getVoices();
  };
}
</script>
</body>
</html>
