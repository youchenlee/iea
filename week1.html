<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Feelings Fun! ğŸ­</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&family=Nunito:wght@400;600;700;800&display=swap');

:root {
  --bg: #FFF8E7;
  --text: #2D3436;
  --card-bg: #FFFFFF;
  --shadow: rgba(45, 52, 54, 0.1);
  --radius: 20px;
  --accent: #A29BFE;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Nunito', sans-serif;
  background: var(--bg);
  min-height: 100vh;
  overflow-x: hidden;
}

body::before {
  content: '';
  position: fixed;
  inset: 0;
  background:
    radial-gradient(circle at 10% 20%, rgba(255,217,61,0.15) 0%, transparent 50%),
    radial-gradient(circle at 90% 80%, rgba(162,155,254,0.12) 0%, transparent 50%),
    radial-gradient(circle at 50% 50%, rgba(255,133,202,0.08) 0%, transparent 60%);
  pointer-events: none;
  z-index: 0;
}

.app { position: relative; z-index: 1; max-width: 900px; margin: 0 auto; padding: 16px; padding-top: 40px; }

.header {
  position: fixed; top: 0; left: 0; right: 0; z-index: 50;
  display: flex; align-items: center; justify-content: space-between;
  padding: 8px 14px;
  background: rgba(255,248,231,0.9);
  backdrop-filter: blur(8px);
}
.header h1 {
  font-family: 'Fredoka', sans-serif;
  font-size: 1.2rem;
  font-weight: 700;
  background: linear-gradient(135deg, #FF6B6B, #A29BFE, #FFD93D);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  line-height: 1;
  flex-shrink: 0;
}
.header .subtitle { display: none; }

.score-bar {
  display: flex; gap: 6px; flex-wrap: nowrap;
}
.score-item {
  background: rgba(255,255,255,0.9);
  backdrop-filter: blur(8px);
  padding: 4px 10px;
  border-radius: 50px;
  font-weight: 700;
  font-size: 0.75rem;
  box-shadow: 0 1px 6px var(--shadow);
  display: flex;
  align-items: center;
  gap: 4px;
  transition: transform 0.3s;
}
.score-item.pop { animation: pop 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
@keyframes pop {
  0% { transform: scale(1); }
  30% { transform: scale(1.4); background: #FFD93D; color: #2D3436; }
  60% { transform: scale(0.95); }
  100% { transform: scale(1); }
}

.nav-groups { display: flex; gap: 6px; justify-content: center; margin: 16px 0; flex-wrap: wrap; }
.nav-group {
  display: flex; align-items: center; gap: 4px;
  background: #F0F0F5; border-radius: 50px; padding: 4px;
}
.nav-group-label {
  font-size: 0.8rem; color: #999; font-family: 'Fredoka', sans-serif;
  font-weight: 600; padding: 0 6px; white-space: nowrap;
}
.nav-tab {
  padding: 8px 14px;
  border-radius: 50px;
  border: none;
  background: transparent;
  font-family: 'Fredoka', sans-serif;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s;
  color: #636E72;
  white-space: nowrap;
}
.nav-tab:hover { background: rgba(255,255,255,0.7); }
.nav-tab.active {
  background: white;
  color: var(--text);
  box-shadow: 0 2px 8px var(--shadow);
}
.nav-tab .stamina-hint { font-size: 0.65rem; opacity: 0.6; }

.section { display: none; animation: fadeIn 0.4s ease; }
.section.active { display: block; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: none; } }

/* ===== LEARN ===== */
.feelings-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 14px;
  margin-top: 10px;
}
.feeling-card {
  background: var(--card-bg);
  border-radius: var(--radius);
  padding: 18px 12px;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  box-shadow: 0 3px 15px var(--shadow);
  border: 3px solid transparent;
  position: relative;
}
.feeling-card:hover { transform: translateY(-6px) scale(1.03); box-shadow: 0 8px 25px var(--shadow); }
.feeling-card:active { transform: scale(0.95); }
.feeling-card .emoji { font-size: 2.8rem; margin-bottom: 8px; display: block; }
.feeling-card .word { font-family: 'Fredoka', sans-serif; font-size: 1.15rem; font-weight: 600; color: var(--text); }
.feeling-card .chinese { font-size: 0.85rem; color: #636E72; margin-top: 2px; }
.feeling-card .speaker-hint {
  position: absolute; top: 8px; right: 8px;
  font-size: 1rem; opacity: 0.3; transition: opacity 0.2s;
}
.feeling-card:hover .speaker-hint { opacity: 0.7; }
.feeling-card.speaking {
  border-color: var(--accent);
  animation: speakRing 0.6s ease;
}
@keyframes speakRing {
  0%, 100% { box-shadow: 0 3px 15px var(--shadow); }
  50% { box-shadow: 0 0 0 6px rgba(162,155,254,0.3), 0 3px 15px var(--shadow); }
}

.sentence-practice {
  background: white;
  border-radius: var(--radius);
  padding: 24px;
  margin-top: 20px;
  box-shadow: 0 3px 15px var(--shadow);
  text-align: center;
}
.sentence-practice h3 { font-family: 'Fredoka', sans-serif; font-size: 1.2rem; color: var(--text); margin-bottom: 14px; }
.sentence-display {
  font-size: 1.6rem;
  font-family: 'Fredoka', sans-serif;
  font-weight: 600;
  color: #2D3436;
  padding: 14px;
  background: #F8F9FA;
  border-radius: 14px;
  margin-bottom: 14px;
  min-height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  flex-wrap: wrap;
  line-height: 1.4;
}
.sentence-display .hl { color: var(--accent); font-weight: 700; }

.learn-section-title {
  font-family: 'Fredoka', sans-serif; font-size: 1.1rem; color: var(--text);
  margin: 10px 0 4px 4px;
}
.sight-learn-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 14px;
}
.sight-learn-card {
  background: var(--card-bg);
  border-radius: var(--radius);
  padding: 16px 12px;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  box-shadow: 0 3px 15px var(--shadow);
  position: relative;
}
.sight-learn-card:hover { transform: translateY(-6px) scale(1.03); box-shadow: 0 8px 25px var(--shadow); }
.sight-learn-card:active { transform: scale(0.95); }
.sight-learn-card .speaker-hint {
  position: absolute; top: 8px; right: 8px;
  font-size: 1rem; opacity: 0.3; transition: opacity 0.2s;
}
.sight-learn-card:hover .speaker-hint { opacity: 0.7; }
.sight-learn-card.speaking {
  border-color: var(--accent);
  animation: speakRing 0.6s ease;
}
.sight-learn-card .sl-word {
  font-family: 'Fredoka', sans-serif; font-size: 1.3rem; font-weight: 700; color: var(--text);
}
.sight-learn-card .sl-zh {
  font-size: 0.85rem; color: #636E72; margin-top: 2px;
}
.sight-learn-card .sl-sentence {
  font-size: 0.75rem; color: #999; margin-top: 6px; font-style: italic;
}

.btn-row { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
.speak-btn {
  padding: 12px 28px;
  border-radius: 50px;
  border: none;
  font-family: 'Fredoka', sans-serif;
  font-size: 1.1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s;
  display: inline-flex;
  align-items: center;
  gap: 8px;
}
.speak-btn:hover { transform: translateY(-2px); }
.speak-btn:active { transform: scale(0.95); }
.speak-btn.primary {
  background: linear-gradient(135deg, #A29BFE, #6C5CE7);
  color: white;
  box-shadow: 0 4px 15px rgba(108,92,231,0.3);
}
.speak-btn.secondary {
  background: linear-gradient(135deg, #FFD93D, #FDCB6E);
  color: #2D3436;
  box-shadow: 0 4px 15px rgba(253,203,110,0.3);
}
.speak-btn.small { padding: 8px 18px; font-size: 0.95rem; }
.speak-btn.playing { opacity: 0.7; pointer-events: none; }

.feeling-chips { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-top: 14px; }
.feeling-chip {
  padding: 8px 16px;
  border-radius: 50px;
  border: 2px solid #DFE6E9;
  background: white;
  font-family: 'Fredoka', sans-serif;
  font-size: 0.95rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}
.feeling-chip:hover { background: #F8F9FA; transform: scale(1.05); }
.feeling-chip.selected { border-color: var(--accent); background: #F0EDFF; }

/* ===== MATCH ===== */
.match-feedback {
  text-align: center; padding: 16px;
  font-family: 'Fredoka', sans-serif; font-size: 1.3rem; font-weight: 600;
  min-height: 56px; display: flex; align-items: center; justify-content: center;
}
.match-game { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start; }
.match-column h3 { font-family: 'Fredoka', sans-serif; text-align: center; margin-bottom: 12px; color: #636E72; font-size: 1rem; }
.match-item {
  padding: 14px 18px; border-radius: 14px; margin-bottom: 10px;
  cursor: pointer; transition: all 0.3s;
  font-family: 'Fredoka', sans-serif; font-size: 1.1rem; font-weight: 600;
  text-align: center; user-select: none;
  background: white; border: 3px solid #DFE6E9; box-shadow: 0 2px 10px var(--shadow);
}
.match-item.emoji-item { font-size: 2rem; }
.match-item:hover { transform: scale(1.05); }
.match-item.selected { border-color: var(--accent); background: #F0EDFF; box-shadow: 0 4px 16px rgba(162,155,254,0.3); }
.match-item.correct { border-color: #00B894; background: #E8FFF5; animation: correctBounce 0.5s ease; }
.match-item.wrong { border-color: #FF6B6B; background: #FFE8E8; animation: shake 0.4s ease; }
.match-item.matched { opacity: 0.35; pointer-events: none; transform: scale(0.95); }
@keyframes correctBounce { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.12); } }
@keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-8px); } 75% { transform: translateX(8px); } }

.reset-btn {
  display: block; margin: 16px auto 0;
  padding: 12px 32px; border-radius: 50px; border: none;
  background: linear-gradient(135deg, #FFD93D, #FDCB6E);
  color: #2D3436;
  font-family: 'Fredoka', sans-serif; font-size: 1.05rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
  box-shadow: 0 4px 15px rgba(253,203,110,0.3);
}
.reset-btn:hover { transform: translateY(-2px); }

/* ===== QUIZ ===== */
.quiz-container {
  background: white; border-radius: var(--radius); padding: 30px;
  box-shadow: 0 3px 15px var(--shadow); text-align: center;
}
.quiz-progress { display: flex; gap: 6px; justify-content: center; margin-bottom: 20px; }
.quiz-dot { width: 12px; height: 12px; border-radius: 50%; background: #DFE6E9; transition: all 0.3s; }
.quiz-dot.done { background: #00B894; }
.quiz-dot.current { background: var(--accent); transform: scale(1.3); }
.quiz-dot.wrong-dot { background: #FF6B6B; }
.quiz-prompt { font-size: 3.5rem; margin: 20px 0; }
.quiz-question { font-family: 'Fredoka', sans-serif; font-size: 1.3rem; color: #636E72; margin-bottom: 20px; }
.quiz-options { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; max-width: 500px; margin: 0 auto; }
.quiz-option {
  padding: 16px; border-radius: 14px; border: 3px solid #DFE6E9;
  background: white; font-family: 'Fredoka', sans-serif; font-size: 1.15rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
}
.quiz-option:hover { border-color: var(--accent); transform: translateY(-2px); }
.quiz-option.correct-answer { border-color: #00B894; background: #E8FFF5; }
.quiz-option.wrong-answer { border-color: #FF6B6B; background: #FFE8E8; }

.quiz-result { padding: 30px; text-align: center; }
.quiz-result .big-emoji { font-size: 4rem; margin-bottom: 16px; }
.quiz-result .result-text { font-family: 'Fredoka', sans-serif; font-size: 1.6rem; font-weight: 700; margin-bottom: 8px; }
.quiz-result .result-detail { font-size: 1.1rem; color: #636E72; margin-bottom: 20px; }

/* ===== SIGHT WORDS ===== */
.sight-words-area { display: flex; flex-direction: column; gap: 14px; }
.sight-word-card {
  background: white; border-radius: var(--radius); padding: 20px 24px;
  display: flex; align-items: center; justify-content: space-between;
  box-shadow: 0 3px 15px var(--shadow); cursor: pointer; transition: all 0.3s;
}
.sight-word-card:hover { transform: translateY(-3px); box-shadow: 0 6px 20px var(--shadow); }
.sight-word-card:active { transform: scale(0.97); }
.sight-word-text { font-family: 'Fredoka', sans-serif; font-size: 2rem; font-weight: 700; color: var(--text); }
.sight-word-chinese { font-size: 1rem; color: #636E72; margin-top: 2px; }
.sight-word-card .play-icon {
  width: 48px; height: 48px; border-radius: 50%;
  background: linear-gradient(135deg, #A29BFE, #6C5CE7);
  display: flex; align-items: center; justify-content: center;
  color: white; font-size: 1.3rem; flex-shrink: 0;
}
.sight-word-card.speaking { border-left: 5px solid var(--accent); }
.sight-word-card.earned { opacity: 0.6; }
.sight-word-card.earned .play-icon { background: #00B894; }
.sight-confirm {
  padding: 6px 14px; border-radius: 50px; border: none;
  background: linear-gradient(135deg, #FFD93D, #FDCB6E); color: #2D3436;
  font-family: 'Fredoka', sans-serif; font-size: 0.85rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s; animation: fadeIn 0.3s ease;
  margin-top: 6px;
}
.sight-confirm:hover { transform: scale(1.05); }
.sight-confirm:disabled { cursor: not-allowed; }

/* Speed toggle */
.speed-toggle {
  display: flex; gap: 6px; justify-content: center; margin: 10px 0;
}
.speed-btn {
  padding: 6px 14px; border-radius: 50px;
  border: 2px solid #DFE6E9; background: white;
  font-family: 'Fredoka', sans-serif; font-size: 0.85rem; font-weight: 600;
  cursor: pointer; color: #636E72; transition: all 0.2s;
}
.speed-btn.active { border-color: var(--accent); background: #F0EDFF; color: var(--accent); }

.settings-section { margin-bottom: 16px; }
.settings-label {
  font-family: 'Fredoka', sans-serif; font-size: 0.9rem;
  font-weight: 600; color: var(--text); margin-bottom: 6px;
}
.confetti-box { position: fixed; inset: 0; pointer-events: none; z-index: 100; }
.confetti-piece {
  position: absolute; width: 10px; height: 10px; border-radius: 2px;
  animation: confDrop 2s ease-out forwards;
}
@keyframes confDrop {
  0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
  100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
}

/* ===== MINE ===== */
.mine-header { text-align: center; margin-bottom: 12px; }
.mine-header h3 { font-family: 'Fredoka', sans-serif; font-size: 1.3rem; color: var(--text); }
.mine-pickaxe { font-size: 1rem; color: #636E72; margin-top: 4px; }
.mine-cost { font-size: 0.9rem; color: var(--accent); margin-top: 2px; }
.mine-hold-hint {
  font-size: 0.85rem; color: #A29BFE; margin-top: 4px;
  font-family: 'Fredoka', sans-serif; font-weight: 600;
  animation: holdHintPulse 2s ease-in-out infinite;
}
@keyframes holdHintPulse {
  0%, 100% { opacity: 0.7; }
  50% { opacity: 1; }
}

.mountain-scroll {
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  border-radius: var(--radius);
  margin: 0 auto;
  position: relative;
}
.mountain-scroll-hint {
  display: none;
  position: absolute; right: 0; top: 0; bottom: 0; width: 28px;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6));
  pointer-events: none; z-index: 1;
  animation: scrollHintPulse 2s ease-in-out infinite;
}
.mountain-scroll-hint::after {
  content: 'â†’'; position: absolute; right: 4px; top: 50%;
  transform: translateY(-50%); font-size: 1rem; opacity: 0.5;
}
@keyframes scrollHintPulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }
.mountain {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
  min-width: fit-content;
  padding: 10px 0;
  background: linear-gradient(180deg, #87CEEB 0%, #87CEEB 20%, #E8D5B7 100%);
  border-radius: var(--radius);
  overflow: hidden;
}
.mountain-row {
  display: flex;
  gap: 2px;
}
.mine-cell {
  width: 38px; height: 38px;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.3rem;
  cursor: pointer;
  transition: all 0.15s;
  border: 1px solid rgba(0,0,0,0.15);
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.2);
  position: relative;
  user-select: none;
}
.mine-cell:hover:not(.mined):not(.locked) { transform: scale(1.12); z-index: 2; box-shadow: 0 0 8px rgba(255,255,255,0.5); }

.mine-cell.unexposed { opacity: 0.85; cursor: default; }
.mine-cell.unexposed:hover { transform: none; box-shadow: inset 0 -2px 4px rgba(0,0,0,0.2); }
.mine-cell.mined {
  background: rgba(135,206,235,0.25) !important;
  border-color: transparent;
  box-shadow: none;
  pointer-events: none;
}
.mine-cell.locked {
  cursor: not-allowed;
  position: relative;
}
.mine-cell.locked::after {
  content: 'ğŸ”’';
  position: absolute;
  font-size: 0.8rem;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.4);
  border-radius: 4px;
}
.mine-cell .block-reveal {
  animation: blockPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
@keyframes blockPop {
  0% { transform: scale(0) rotate(-20deg); opacity: 0; }
  60% { transform: scale(1.3) rotate(5deg); opacity: 1; }
  100% { transform: scale(1) rotate(0); }
}
.mine-cell.tier1 { background: linear-gradient(180deg, #8B6F47, #6B4F37); }
.mine-cell.tier2 { background: linear-gradient(180deg, #7F8C8D, #616A6B); }
.mine-cell.tier3 { background: linear-gradient(180deg, #5D6D7E, #4A5568); }
.mine-cell.tier4 { background: linear-gradient(180deg, #6B4C3B, #4A3728); }
.mine-cell.tier5 { background: linear-gradient(180deg, #2C3E6D, #1A2547); }
.mine-cell.tree { background: none; border: none; box-shadow: none; font-size: 1.5rem; cursor: pointer; }
.mine-cell.tree:hover { transform: scale(1.15); }
.mine-cell.tree.mined { background: none !important; border: none; box-shadow: none; opacity: 0; pointer-events: none; }
.mine-cell.animal { background: none; border: none; box-shadow: none; font-size: 1.5rem; cursor: pointer; }
.mine-cell.animal:hover { transform: scale(1.15); }
.mine-cell.animal.mined { background: none !important; border: none; box-shadow: none; opacity: 0; pointer-events: none; }

.mine-result {
  text-align: center; margin-top: 12px; padding: 10px;
  font-family: 'Fredoka', sans-serif; font-size: 1.05rem; font-weight: 600;
  min-height: 44px; transition: background 0.3s;
}
.mine-result.tool-broke {
  background: #FFEAA7; border-radius: 12px;
  animation: toolBrokeFlash 1.5s ease-out;
}
@keyframes toolBrokeFlash {
  0%, 20% { background: #FF6B6B; color: white; transform: scale(1.05); }
  100% { background: #FFEAA7; color: inherit; transform: scale(1); }
}
.tool-slots { display: flex; gap: 8px; justify-content: center; margin: 8px 0; }
.tool-slot {
  display: flex; flex-direction: column; align-items: center; gap: 2px;
  padding: 6px 10px; border-radius: 10px; border: 2px solid #DFE6E9;
  background: white; cursor: pointer; transition: all 0.15s;
  font-family: 'Fredoka', sans-serif; position: relative; user-select: none;
  min-width: 64px;
}
.tool-slot:hover { border-color: #6C5CE7; background: #F8F7FF; }
.tool-slot:active { transform: scale(0.96); }
.tool-slot-label { font-size: 0.65rem; color: #B2BEC3; }
.tool-slot-emoji { font-size: 1.4rem; line-height: 1.2; }
.tool-slot-name { font-size: 0.75rem; font-weight: 600; color: #2D3436; white-space: nowrap; }
.tool-slot-dur { font-size: 0.6rem; color: #B2BEC3; }
.tool-picker {
  background: white; border-radius: 12px; box-shadow: 0 8px 30px rgba(0,0,0,0.18);
  border: 1px solid #DFE6E9; z-index: 20; min-width: 150px;
  padding: 6px 0; animation: pickerIn 0.15s ease-out;
}
@keyframes pickerIn { from { opacity: 0; transform: translateX(-50%) translateY(-4px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
.tool-picker-option {
  display: flex; align-items: center; gap: 8px;
  padding: 8px 14px; cursor: pointer; font-family: 'Fredoka', sans-serif; font-size: 0.85rem;
  transition: background 0.1s;
}
.tool-picker-option:hover { background: #F0EFFF; }
.tool-picker-option.selected { background: #E8E6FF; font-weight: 600; }
.tool-picker-option .opt-emoji { font-size: 1.1rem; }
.tool-picker-option .opt-info { font-size: 0.7rem; color: #B2BEC3; margin-left: auto; }
.tool-picker-backdrop { position: fixed; inset: 0; z-index: 19; }
.mine-refresh {
  display: block; margin: 10px auto 0;
  padding: 10px 28px; border-radius: 50px; border: none;
  background: linear-gradient(135deg, #A29BFE, #6C5CE7);
  color: white;
  font-family: 'Fredoka', sans-serif; font-size: 1rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
  box-shadow: 0 4px 15px rgba(108,92,231,0.3);
}
.mine-refresh:hover { transform: translateY(-2px); }
.mine-refresh:disabled { opacity: 0.4; pointer-events: none; }

/* ===== COLLECTION ===== */
.collection-tabs { display: flex; gap: 8px; justify-content: center; margin-bottom: 16px; }
.collection-tab {
  padding: 8px 16px; border-radius: 50px; border: 2px solid #DFE6E9;
  background: white; font-family: 'Fredoka', sans-serif; font-size: 0.9rem;
  font-weight: 600; cursor: pointer; color: #636E72; transition: all 0.2s;
}
.collection-tab.active { border-color: var(--accent); background: #F0EDFF; color: var(--accent); }

.encyclopedia-grid {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
  gap: 12px;
}
.block-card {
  background: white; border-radius: var(--radius); padding: 14px;
  text-align: center; box-shadow: 0 2px 10px var(--shadow);
  border: 3px solid #DFE6E9; transition: all 0.3s;
}
.block-card.owned { border-color: #00B894; }
.block-card.undiscovered { opacity: 0.4; }
.block-card .block-emoji { font-size: 2.2rem; margin-bottom: 6px; }
.block-card .block-name { font-family: 'Fredoka', sans-serif; font-size: 1rem; font-weight: 600; }
.block-card .block-count { font-size: 0.85rem; color: #636E72; margin-top: 2px; }
.block-card .block-tier { font-size: 0.7rem; color: var(--accent); margin-top: 2px; }

.craft-area { max-width: 500px; margin: 0 auto; }
.craft-current { text-align: center; font-family: 'Fredoka', sans-serif; color: #636E72; margin-bottom: 12px; font-size: 1rem; }
.craft-guide {
  text-align: center; font-family: 'Fredoka', sans-serif;
  font-size: 0.85rem; color: #636E72; margin-bottom: 12px;
  background: #F0FFF8; padding: 8px 16px; border-radius: 50px;
  border: 1px dashed #00B894;
}

.craft-table {
  display: flex; align-items: center; justify-content: center;
  gap: 16px; flex-wrap: wrap; margin-bottom: 16px;
}
.craft-grid {
  display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px;
  background: #8B6F47; padding: 8px; border-radius: 12px;
  box-shadow: inset 0 2px 6px rgba(0,0,0,0.3), 0 3px 10px var(--shadow);
}
.craft-slot {
  width: 52px; height: 52px; border-radius: 6px;
  background: #A0855C; border: 2px solid #6B4F37;
  display: flex; align-items: center; justify-content: center;
  font-size: 1.6rem; cursor: pointer; transition: all 0.15s;
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.15);
}
.craft-slot:hover { background: #B8976A; transform: scale(1.05); }
.craft-slot.filled { background: #C4A97D; border-color: #8B6F47; }

.craft-arrow { font-size: 1.8rem; color: #636E72; }

.craft-result-slot {
  width: 64px; height: 64px; border-radius: 8px;
  background: #A0855C; border: 3px solid #6B4F37;
  display: flex; align-items: center; justify-content: center;
  font-size: 2rem; position: relative;
  box-shadow: inset 0 -2px 4px rgba(0,0,0,0.15);
}
.craft-result-slot.matched {
  border-color: #00B894; background: #C4A97D;
  animation: correctBounce 0.5s ease;
}

.craft-actions { display: flex; gap: 8px; justify-content: center; margin-bottom: 16px; }
.craft-btn {
  padding: 10px 24px; border-radius: 50px; border: none;
  font-family: 'Fredoka', sans-serif; font-size: 1rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
}
.craft-btn:hover { transform: translateY(-2px); }
.craft-btn:disabled { opacity: 0.4; pointer-events: none; }
.craft-btn.primary { background: linear-gradient(135deg, #00B894, #00CEC9); color: white; box-shadow: 0 4px 15px rgba(0,184,148,0.3); }
.craft-btn.secondary { background: linear-gradient(135deg, #DFE6E9, #BDC3C7); color: #2D3436; }

.craft-inventory {
  background: #8B6F47; border-radius: 12px; padding: 10px;
  box-shadow: inset 0 2px 6px rgba(0,0,0,0.3), 0 3px 10px var(--shadow);
}
.craft-inv-title {
  font-family: 'Fredoka', sans-serif; font-size: 0.9rem;
  color: #FFFFFF; margin-bottom: 8px; text-align: center;
}
.craft-inv-grid {
  display: flex; flex-wrap: wrap; gap: 4px; justify-content: center;
}
.craft-inv-item {
  width: 48px; height: 48px; border-radius: 6px;
  background: #A0855C; border: 2px solid #6B4F37;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  font-size: 1.2rem; cursor: pointer; transition: all 0.15s;
  position: relative;
}
.craft-inv-item:hover { background: #B8976A; transform: scale(1.08); }
.craft-inv-item.selected { border-color: #FFD93D; background: #C4A97D; box-shadow: 0 0 8px rgba(255,217,61,0.5); }
.craft-inv-item .inv-count {
  font-size: 0.55rem; font-weight: 700; color: #FFF;
  background: rgba(0,0,0,0.5); border-radius: 4px; padding: 0 3px;
  position: absolute; bottom: 2px; right: 2px;
}

.recipe-book { margin-top: 20px; }
.recipe-book-title {
  font-family: 'Fredoka', sans-serif; font-size: 1.1rem; font-weight: 600;
  color: var(--text); text-align: center; margin-bottom: 12px;
}
.recipe-list { display: flex; flex-direction: column; gap: 10px; }
.recipe-card {
  background: white; border-radius: 14px; padding: 12px 16px;
  box-shadow: 0 2px 10px var(--shadow); display: flex; align-items: center; gap: 12px;
  border: 2px solid #DFE6E9; transition: all 0.2s;
}
.recipe-card.craftable { border-color: #00B894; background: #F0FFF8; }
.recipe-card.crafted { border-color: #B2BEC3; opacity: 0.5; }
.recipe-mini-grid {
  display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px;
  background: #8B6F47; padding: 4px; border-radius: 6px; flex-shrink: 0;
}
.recipe-mini-slot {
  width: 28px; height: 28px; border-radius: 3px;
  background: #A0855C; display: flex; align-items: center; justify-content: center;
  font-size: 0.9rem;
}
.recipe-arrow { color: #636E72; font-size: 1.2rem; flex-shrink: 0; }
.recipe-result { font-size: 1.4rem; flex-shrink: 0; }
.recipe-info { flex: 1; }
.recipe-name { font-family: 'Fredoka', sans-serif; font-weight: 600; font-size: 0.95rem; }
.recipe-needs { font-size: 0.8rem; color: #636E72; margin-top: 2px; }
.recipe-needs .has { color: #00B894; }
.recipe-needs .need { color: #FF6B6B; }
.recipe-category { margin-bottom: 12px; }
.recipe-category-header {
  font-family: 'Fredoka', sans-serif; font-size: 1rem; font-weight: 600;
  color: var(--text); padding: 8px 12px; cursor: pointer;
  background: #F0F0F5; border-radius: 10px; margin-bottom: 8px;
  transition: all 0.2s; user-select: none;
}
.recipe-category-header:hover { background: #E0E0E8; }
.recipe-category-header.collapsed::after { content: ' â–¸'; }
.recipe-category-header:not(.collapsed)::after { content: ' â–¾'; }

.house-area { text-align: center; max-width: 400px; margin: 0 auto; }
.house-visual {
  font-size: 1.2rem; line-height: 1.8;
  background: white; border-radius: var(--radius); padding: 24px;
  box-shadow: 0 2px 10px var(--shadow); margin-bottom: 16px;
  min-height: 180px; display: flex; align-items: center; justify-content: center;
  white-space: pre; font-family: 'Fredoka', sans-serif;
}
.house-stage {
  background: white; border-radius: 14px; padding: 14px 18px;
  margin-bottom: 10px; box-shadow: 0 2px 10px var(--shadow);
  display: flex; align-items: center; justify-content: space-between;
}
.house-stage.done { border-left: 4px solid #00B894; }
.house-stage.current { border-left: 4px solid var(--accent); }
.house-stage.locked { opacity: 0.5; }
.house-stage-info { text-align: left; }
.house-stage-name { font-family: 'Fredoka', sans-serif; font-weight: 600; }
.house-stage-needs { font-size: 0.85rem; color: #636E72; margin-top: 2px; }
.house-build-btn {
  padding: 8px 18px; border-radius: 50px; border: none;
  background: linear-gradient(135deg, #FFD93D, #FDCB6E); color: #2D3436;
  font-family: 'Fredoka', sans-serif; font-size: 0.9rem; font-weight: 600;
  cursor: pointer; transition: all 0.3s;
}
.house-build-btn:disabled { opacity: 0.4; pointer-events: none; }

/* ===== SETTINGS MODAL ===== */
.modal-overlay {
  display: none;
  position: fixed; inset: 0;
  background: rgba(45, 52, 54, 0.5);
  z-index: 200;
  justify-content: center;
  align-items: center;
}
.modal-overlay.active {
  display: flex;
}
.modal-content {
  background: white;
  border-radius: var(--radius);
  padding: 24px;
  width: 90%;
  max-width: 360px;
  box-shadow: 0 8px 32px rgba(45, 52, 54, 0.2);
  animation: fadeIn 0.3s ease;
}
.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-family: 'Fredoka', sans-serif;
  font-size: 1.2rem;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 16px;
}
.modal-close {
  background: none; border: none;
  font-size: 1.3rem; cursor: pointer;
  color: #B2BEC3; transition: color 0.2s;
  padding: 4px 8px; line-height: 1;
}
.modal-close:hover { color: var(--text); }
.settings-btn {
  cursor: pointer; border: none;
  background: rgba(255,255,255,0.9);
  min-width: 36px; min-height: 36px;
  display: flex; align-items: center; justify-content: center;
}
.settings-btn:hover { transform: scale(1.15); }

@media (max-width: 600px) {
  .header { padding: 6px 10px; }
  .header h1 { font-size: 1rem; }
  .score-item { padding: 3px 8px; font-size: 0.7rem; }
  .feelings-grid { grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap: 10px; }
  .feeling-card { padding: 14px 8px; }
  .feeling-card .emoji { font-size: 2.2rem; }
  .sight-learn-grid { grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap: 10px; }
  .sight-learn-card { padding: 12px 8px; }
  .sight-learn-card .sl-word { font-size: 1.1rem; }
  .match-game { grid-template-columns: 1fr; }
  .quiz-options { grid-template-columns: 1fr; }
  .nav-groups { gap: 4px; }
  .nav-group { padding: 3px; }
  .nav-group-label { font-size: 0; width: 0; padding: 0; overflow: hidden; }
  .stamina-hint { display: none; }
  .nav-tab { padding: 8px 12px; font-size: 0.85rem; }
  .sentence-display { font-size: 1.2rem; }
  .mountain-scroll-hint { display: block; }
  .mine-cell { width: 38px; height: 38px; font-size: 1.2rem; }
  .mine-cell.tree { font-size: 1.4rem; }
  .mine-cell.animal { font-size: 1.4rem; }
  .encyclopedia-grid { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); }
  .craft-slot { width: 44px; height: 44px; font-size: 1.3rem; }
  .craft-result-slot { width: 52px; height: 52px; font-size: 1.6rem; }
  .craft-inv-item { width: 44px; height: 44px; font-size: 1.1rem; }
  .collection-tab { padding: 6px 12px; font-size: 0.8rem; }
  .character-display.small { display: none !important; }
  .equip-slot { min-width: 160px; padding: 6px 10px; }
  .equip-inv-item { width: 40px; height: 40px; font-size: 1.2rem; }
  .modal-content { min-width: auto; width: 90vw; }
}
.mine-cell.mining {
  transform: scale(1.9) translateY(-20px);
  z-index: 10;
  box-shadow: 0 8px 24px rgba(0,0,0,0.35);
  transition: transform 0.15s ease-out, box-shadow 0.15s ease-out;
}
.mine-cell.tree.mining, .mine-cell.animal.mining {
  background: rgba(255,255,255,0.85);
  border-radius: 8px;
  border: 1px solid rgba(0,0,0,0.1);
}
.mine-progress {
  position: absolute; bottom: 0; left: 0; right: 0; height: 7px;
  background: rgba(0,0,0,0.2); border-radius: 0 0 4px 4px;
  overflow: hidden;
}
.mine-progress-fill {
  height: 100%; width: 0%; background: #00B894;
  transition: none;
}
.character-display {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 2px;
  justify-items: center; align-items: center;
  margin: 12px auto; width: fit-content;
}
.char-cell { font-size: 2.8rem; line-height: 1.2; text-align: center; min-width: 2.4em; padding: 4px 2px; border-radius: 10px; }
.char-cell.clickable { cursor: pointer; transition: background 0.15s; }
.char-cell.clickable:hover { background: rgba(108,92,231,0.08); }
.char-cell.clickable:active { background: rgba(108,92,231,0.15); transform: scale(0.95); }
.char-cell.empty-slot { border: 2px dashed #DFE6E9; border-radius: 8px; min-height: 1.2em; }
.char-cell-label { font-size: 0.7rem; color: #636E72; font-family: 'Fredoka', sans-serif; }
.character-display.small { margin: 0; }
.character-display.small .char-cell { font-size: 1.2rem; min-width: 1.6em; padding: 1px; }
.character-display.small .char-cell { font-size: 1.1rem; line-height: 1.2; min-width: 1.5em; }
.character-display.small .char-cell-label { display: none; }
.character-display.small .character-row { font-size: 1.2rem; }

.equip-area { text-align: center; }
.equip-slots {
  display: flex; flex-direction: column; align-items: center;
  gap: 8px; margin: 16px 0;
}
.equip-slot {
  display: flex; align-items: center; gap: 12px;
  background: white; padding: 8px 16px; border-radius: 12px;
  box-shadow: 0 2px 8px rgba(45, 52, 54, 0.1); min-width: 200px;
  cursor: pointer; transition: all 0.2s;
}
.equip-slot:hover { transform: scale(1.02); box-shadow: 0 4px 12px rgba(45, 52, 54, 0.1); }
.equip-slot-label { font-size: 0.8rem; color: #636E72; font-family: 'Fredoka', sans-serif; min-width: 50px; }
.equip-slot-item { font-size: 1.3rem; }
.equip-slot-name { font-family: 'Fredoka', sans-serif; font-size: 0.9rem; }
.equip-slot-empty { color: #B2BEC3; font-style: italic; }

.equip-inventory {
  display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;
  margin-top: 16px; padding: 12px;
  background: #F0F0F5; border-radius: 12px;
}
.equip-inv-item {
  width: 48px; height: 48px;
  display: flex; align-items: center; justify-content: center;
  font-size: 1.5rem; background: white; border-radius: 8px;
  cursor: pointer; transition: all 0.2s; position: relative;
  box-shadow: 0 1px 4px rgba(45, 52, 54, 0.1);
}
.equip-inv-item:hover { transform: scale(1.1); }
</style>
</head>
<body>

<div class="app">
  <div class="header">
    <h1>Feelings Fun! ğŸ­</h1>
    <div class="subtitle">å­¸ç¿’è¡¨é”æƒ…ç·’çš„è‹±æ–‡ Â· Learn to express feelings</div>
    <div class="score-bar">
      <div class="score-item" id="starBar"><span>â­</span> <span id="stars">0</span></div>
      <div class="score-item" id="streakBar"><span>ğŸ”¥</span> <span id="streak">0</span></div>
      <div class="score-item" id="gemBar"><span>âš¡</span> <span id="gems">0</span></div>
      <button class="score-item settings-btn" id="settingsBtn">âš™ï¸</button>
    </div>
  </div>

  <div class="nav-groups">
    <div class="nav-group">
      <div class="nav-group-label">ğŸ“š å­¸ç¿’</div>
      <div class="nav-group-tabs">
        <button class="nav-tab active" data-tab="learn">ğŸ“– Learn</button>
      </div>
    </div>
    <div class="nav-group">
      <div class="nav-group-label">ğŸ† æŒ‘æˆ°</div>
      <div class="nav-group-tabs">
        <button class="nav-tab" data-tab="sight">ğŸ‘€ Sight <span class="stamina-hint">+âš¡</span></button>
        <button class="nav-tab" data-tab="match">ğŸ¯ Match <span class="stamina-hint">+âš¡</span></button>
        <button class="nav-tab" data-tab="quiz">ğŸ§  Quiz <span class="stamina-hint">+âš¡</span></button>
      </div>
    </div>
    <div class="nav-group">
      <div class="nav-group-label">â›ï¸ éŠæˆ²</div>
      <div class="nav-group-tabs">
        <button class="nav-tab" data-tab="mine">â›ï¸ Mine</button>
        <button class="nav-tab" data-tab="collection">ğŸ“¦ æ”¶è—</button>
      </div>
    </div>
  </div>

  <div id="learn" class="section active">
    <h3 class="learn-section-title">ğŸ˜Š Feelings æƒ…ç·’</h3>
    <div class="feelings-grid" id="feelingsGrid"></div>
    <div class="sentence-practice">
      <h3>ğŸ—£ï¸ Practice Sentences é€ å¥ç·´ç¿’</h3>
      <div class="sentence-display" id="sentenceDisplay">I feel <span class="hl">happy</span>. ğŸ˜Š</div>
      <div class="btn-row">
        <button class="speak-btn primary" id="speakSentenceBtn">ğŸ”Š Listen è½ç™¼éŸ³</button>
        <button class="speak-btn secondary" id="randomSentenceBtn">ğŸ² Random éš¨æ©Ÿ</button>
      </div>
      <div class="feeling-chips" id="feelingChips"></div>
    </div>
    <h3 class="learn-section-title" style="margin-top:24px;">ğŸ“– Sight Words å¸¸è¦‹å­—</h3>
    <div class="sight-learn-grid" id="sightLearnGrid"></div>
  </div>

  <div id="match" class="section">
    <div class="match-feedback" id="matchFeedback">é»ä¸€å€‹å–®å­—ï¼Œå†é»é…å°çš„è¡¨æƒ…ï¼ ğŸ¯</div>
    <div class="match-game" id="matchGame">
      <div class="match-column" id="matchWords"><h3>Words å–®å­—</h3></div>
      <div class="match-column" id="matchEmojis"><h3>Emoji è¡¨æƒ…</h3></div>
    </div>
    <button class="reset-btn" id="resetMatch">ğŸ”„ New Round å†ä¾†ä¸€æ¬¡</button>
  </div>

  <div id="quiz" class="section">
    <div class="quiz-container" id="quizContainer"></div>
  </div>

  <div id="sight" class="section">
    <div class="sight-words-area" id="sightWordsArea"></div>
  </div>

  <div id="mine" class="section">
    <div id="mineArea"></div>
  </div>

  <div id="collection" class="section">
    <div id="collectionArea"></div>
  </div>
</div>

<div class="confetti-box" id="confettiBox"></div>

<div class="modal-overlay" id="settingsModal">
  <div class="modal-content">
    <div class="modal-header">
      <span>âš™ï¸ è¨­å®š</span>
      <button class="modal-close" id="settingsClose">âœ•</button>
    </div>
    <div class="settings-section">
      <div class="settings-label">ğŸ”Š èªé€Ÿ Speed</div>
      <div class="speed-toggle">
        <button class="speed-btn" data-speed="slow" id="speedSlow">ğŸ¢ Slow</button>
        <button class="speed-btn active" data-speed="normal" id="speedNormal">ğŸ‡ Normal</button>
      </div>
    </div>
    <div class="settings-section">
      <div class="settings-label">ğŸ”‡ éœéŸ³ Mute</div>
      <div class="speed-toggle">
        <button class="speed-btn" id="muteOff">ğŸ”Š é–‹</button>
        <button class="speed-btn active" id="muteOn">ğŸ”‡ é—œ</button>
      </div>
    </div>
    <div id="engineStatus" style="text-align:center;font-size:0.8rem;color:#B2BEC3;margin-top:12px;font-family:'Nunito',sans-serif;">ğŸ” åµæ¸¬ä¸­...</div>
    <div style="text-align:center;font-size:0.7rem;color:#B2BEC3;margin-top:8px;font-family:'Nunito',sans-serif;">v2.8.0</div>
  </div>
</div>

<script>
// ===== DATA =====
const feelings = [
  { word: 'happy',   zh: 'é–‹å¿ƒçš„', emoji: 'ğŸ˜Š', color: '#FFD93D' },
  { word: 'sad',     zh: 'é›£éçš„', emoji: 'ğŸ˜¢', color: '#74B9FF' },
  { word: 'angry',   zh: 'ç”Ÿæ°£çš„', emoji: 'ğŸ˜ ', color: '#FF6B6B' },
  { word: 'excited', zh: 'èˆˆå¥®çš„', emoji: 'ğŸ¤©', color: '#FF85CA' },
  { word: 'silly',   zh: 'å¯ç¬‘çš„', emoji: 'ğŸ¤ª', color: '#A29BFE' },
  { word: 'tired',   zh: 'ç´¯çš„',   emoji: 'ğŸ˜´', color: '#B2BEC3' },
  { word: 'scared',  zh: 'å®³æ€•çš„', emoji: 'ğŸ˜¨', color: '#81ECEC' },
  { word: 'bored',   zh: 'ç„¡èŠçš„', emoji: 'ğŸ˜‘', color: '#FFEAA7' },
  { word: 'sick',    zh: 'ä¸èˆ’æœçš„', emoji: 'ğŸ¤’', color: '#55EFC4' },
  { word: 'proud',   zh: 'é©•å‚²çš„', emoji: 'ğŸ˜', color: '#FD79A8' },
  { word: 'brave',   zh: 'å‹‡æ•¢çš„', emoji: 'ğŸ’ª', color: '#E17055' },
  { word: 'mad',     zh: 'ç”Ÿæ°£çš„', emoji: 'ğŸ˜¤', color: '#D63031' },
];

const sightWords = [
  { word: 'door',  zh: 'é–€', sentence: 'Open the door.' },
  { word: 'down',  zh: 'ä¸‹é¢', sentence: 'Sit down please.' },
  { word: 'dress', zh: 'æ´‹è£', sentence: 'I like your dress.' },
  { word: 'duck',  zh: 'é´¨å­', sentence: 'Look at the duck!' },
  { word: 'each',  zh: 'æ¯ä¸€å€‹', sentence: 'Give one to each child.' },
  { word: 'egg',   zh: 'è›‹', sentence: 'I eat an egg.' },
  { word: 'every',  zh: 'æ¯å€‹', sentence: 'Every day is special.' },
  { word: 'over',   zh: 'åœ¨â€¦ä¸Šæ–¹', sentence: 'The bird flew over the house.' },
  { word: 'new',    zh: 'æ–°çš„', sentence: 'I got a new book.' },
  { word: 'sound',  zh: 'è²éŸ³', sentence: 'What is that sound?' },
  { word: 'take',   zh: 'æ‹¿', sentence: 'Please take one.' },
  { word: 'only',   zh: 'åªæœ‰', sentence: 'I have only one.' },
  { word: 'little', zh: 'å°çš„', sentence: 'The little cat is cute.' },
  { word: 'work',   zh: 'å·¥ä½œ', sentence: 'We work together.' },
  { word: 'know',   zh: 'çŸ¥é“', sentence: 'I know the answer.' },
  { word: 'place',  zh: 'åœ°æ–¹', sentence: 'This is a nice place.' },
  { word: 'years',  zh: 'å¹´', sentence: 'I am six years old.' },
];
const sightColors = ['#FF6B6B','#A29BFE','#FFD93D','#00B894','#FF85CA','#74B9FF','#E17055'];

// ===== MINING DATA =====
const blocks = [
  { id: 'dirt',     name: 'æ³¥åœŸ',   emoji: 'ğŸŸ«', tier: 1, weight: 40 },
  { id: 'wood',     name: 'æœ¨é ­',   emoji: 'ğŸªµ', tier: 1, weight: 35 },
  { id: 'stick',    name: 'æœ¨æ£',   emoji: 'ğŸ¥¢', tier: 1, weight: 10 },
  { id: 'stone',    name: 'çŸ³é ­',   emoji: 'ğŸª¨', tier: 2, weight: 30 },
  { id: 'coal',     name: 'ç…¤ç‚­',   emoji: 'â¬›', tier: 2, weight: 25 },
  { id: 'iron',     name: 'éµç¤¦',   emoji: 'â¬œ', tier: 3, weight: 18 },
  { id: 'copper',   name: 'éŠ…ç¤¦',   emoji: 'ğŸŸ§', tier: 3, weight: 15 },
  { id: 'gold',     name: 'é‡‘ç¤¦',   emoji: 'ğŸŸ¡', tier: 4, weight: 8 },
  { id: 'emerald',  name: 'ç¶ å¯¶çŸ³', emoji: 'ğŸ’š', tier: 4, weight: 5 },
  { id: 'diamond',  name: 'é‘½çŸ³',   emoji: 'ğŸ’', tier: 5, weight: 3 },
  { id: 'amethyst', name: 'ç´«æ°´æ™¶', emoji: 'ğŸŸ£', tier: 5, weight: 2 },
  // Animal drops (tier 0, weight 0 = drop-only)
  { id: 'leather',      name: 'çš®é©',   emoji: 'ğŸŸ¤', tier: 0, weight: 0 },
  { id: 'pork',         name: 'è±¬æ’',   emoji: 'ğŸ–', tier: 0, weight: 0 },
  { id: 'chicken_meat', name: 'é›è‚‰',   emoji: 'ğŸ—', tier: 0, weight: 0 },
  { id: 'feather',      name: 'ç¾½æ¯›',   emoji: 'ğŸª¶', tier: 0, weight: 0 },
  { id: 'wool',         name: 'ç¾Šæ¯›',   emoji: 'ğŸ§¶', tier: 0, weight: 0 },
  // Tools (tier 0, weight 0 = never mined, only crafted)
  { id: 'wood_pick',    name: 'æœ¨é¬',   emoji: 'â›ï¸', tier: 0, weight: 0 },
  { id: 'stone_pick',   name: 'çŸ³é¬',   emoji: 'â›ï¸', tier: 0, weight: 0 },
  { id: 'iron_pick',    name: 'éµé¬',   emoji: 'â›ï¸', tier: 0, weight: 0 },
  { id: 'gold_pick',    name: 'é‡‘é¬',   emoji: 'ğŸ”±', tier: 0, weight: 0 },
  { id: 'diamond_pick', name: 'é‘½çŸ³é¬', emoji: 'â›ï¸', tier: 0, weight: 0 },
  { id: 'wood_axe',     name: 'æœ¨æ–§',   emoji: 'ğŸª“', tier: 0, weight: 0 },
  { id: 'stone_axe',    name: 'çŸ³æ–§',   emoji: 'ğŸª“', tier: 0, weight: 0 },
  { id: 'iron_axe',     name: 'éµæ–§',   emoji: 'ğŸª“', tier: 0, weight: 0 },
  { id: 'gold_axe',     name: 'é‡‘æ–§',   emoji: 'ğŸª“', tier: 0, weight: 0 },
  { id: 'diamond_axe',  name: 'é‘½çŸ³æ–§', emoji: 'ğŸª“', tier: 0, weight: 0 },
  { id: 'wood_sword',    name: 'æœ¨åŠ',   emoji: 'ğŸ—¡ï¸', tier: 0, weight: 0 },
  { id: 'stone_sword',   name: 'çŸ³åŠ',   emoji: 'ğŸ—¡ï¸', tier: 0, weight: 0 },
  { id: 'iron_sword',    name: 'éµåŠ',   emoji: 'ğŸ—¡ï¸', tier: 0, weight: 0 },
  { id: 'gold_sword',    name: 'é‡‘åŠ',   emoji: 'ğŸ—¡ï¸', tier: 0, weight: 0 },
  { id: 'diamond_sword', name: 'é‘½çŸ³åŠ', emoji: 'ğŸ—¡ï¸', tier: 0, weight: 0 },
  // Armor items (tier 0, weight 0)
  { id: 'leather_helmet',  name: 'çš®é©é ­ç›”', emoji: 'ğŸª–', tier: 0, weight: 0 },
  { id: 'leather_chest',   name: 'çš®é©ç›”ç”²', emoji: 'ğŸ¦º', tier: 0, weight: 0 },
  { id: 'leather_legs',    name: 'çš®é©è¤²å­', emoji: 'ğŸ‘–', tier: 0, weight: 0 },
  { id: 'leather_boots',   name: 'çš®é©é‹å­', emoji: 'ğŸ‘¢', tier: 0, weight: 0 },
  { id: 'iron_helmet',     name: 'éµé ­ç›”',   emoji: 'ğŸª–', tier: 0, weight: 0 },
  { id: 'iron_chest',      name: 'éµç›”ç”²',   emoji: 'ğŸ¦º', tier: 0, weight: 0 },
  { id: 'iron_legs',       name: 'éµè¤²å­',   emoji: 'ğŸ‘–', tier: 0, weight: 0 },
  { id: 'iron_boots',      name: 'éµé‹å­',   emoji: 'ğŸ‘¢', tier: 0, weight: 0 },
  { id: 'gold_helmet',     name: 'é‡‘é ­ç›”',   emoji: 'ğŸª–', tier: 0, weight: 0 },
  { id: 'gold_chest',      name: 'é‡‘ç›”ç”²',   emoji: 'ğŸ¦º', tier: 0, weight: 0 },
  { id: 'gold_legs',       name: 'é‡‘è¤²å­',   emoji: 'ğŸ‘–', tier: 0, weight: 0 },
  { id: 'gold_boots',      name: 'é‡‘é‹å­',   emoji: 'ğŸ‘¢', tier: 0, weight: 0 },
  { id: 'diamond_helmet',  name: 'é‘½çŸ³é ­ç›”', emoji: 'ğŸª–', tier: 0, weight: 0 },
  { id: 'diamond_chest',   name: 'é‘½çŸ³ç›”ç”²', emoji: 'ğŸ¦º', tier: 0, weight: 0 },
  { id: 'diamond_legs',    name: 'é‘½çŸ³è¤²å­', emoji: 'ğŸ‘–', tier: 0, weight: 0 },
  { id: 'diamond_boots',   name: 'é‘½çŸ³é‹å­', emoji: 'ğŸ‘¢', tier: 0, weight: 0 },
];

const pickaxes = [
  { id: 'hands',        name: 'æ‰‹',     emoji: 'âœ‹', maxTier: 0, durability: Infinity, recipe: null, pattern: null },
  { id: 'wood_pick',    name: 'æœ¨é¬',   emoji: 'â›ï¸', maxTier: 2, durability: Infinity,
    recipe: { wood: 3, stick: 2 },
    pattern: ['wood','wood','wood', null,'stick',null, null,'stick',null] },
  { id: 'stone_pick',   name: 'çŸ³é¬',   emoji: 'â›ï¸', maxTier: 3, durability: 30,
    recipe: { stick: 2, stone: 3 },
    pattern: ['stone','stone','stone', null,'stick',null, null,'stick',null] },
  { id: 'iron_pick',    name: 'éµé¬',   emoji: 'â›ï¸', maxTier: 5, durability: 60,
    recipe: { stick: 2, iron: 3 },
    pattern: ['iron','iron','iron', null,'stick',null, null,'stick',null] },
  { id: 'gold_pick',    name: 'é‡‘é¬',   emoji: 'ğŸ”±', maxTier: 4, durability: 25,
    recipe: { stick: 2, gold: 3 },
    pattern: ['gold','gold','gold', null,'stick',null, null,'stick',null] },
  { id: 'diamond_pick', name: 'é‘½çŸ³é¬', emoji: 'â›ï¸', maxTier: 5, durability: 150,
    recipe: { stick: 2, diamond: 3 },
    pattern: ['diamond','diamond','diamond', null,'stick',null, null,'stick',null] },
];

// Axe recipes (XX. / XS. / .S.)
const axes = [
  { id: 'wood_axe',    name: 'æœ¨æ–§',   emoji: 'ğŸª“', woodBonus: 2, durability: Infinity,
    recipe: { wood: 3, stick: 2 },
    pattern: ['wood','wood',null, 'wood','stick',null, null,'stick',null] },
  { id: 'stone_axe',   name: 'çŸ³æ–§',   emoji: 'ğŸª“', woodBonus: 2, durability: 30,
    recipe: { stick: 2, stone: 3 },
    pattern: ['stone','stone',null, 'stone','stick',null, null,'stick',null] },
  { id: 'iron_axe',    name: 'éµæ–§',   emoji: 'ğŸª“', woodBonus: 3, durability: 60,
    recipe: { stick: 2, iron: 3 },
    pattern: ['iron','iron',null, 'iron','stick',null, null,'stick',null] },
  { id: 'gold_axe',    name: 'é‡‘æ–§',   emoji: 'ğŸª“', woodBonus: 3, durability: 25,
    recipe: { stick: 2, gold: 3 },
    pattern: ['gold','gold',null, 'gold','stick',null, null,'stick',null] },
  { id: 'diamond_axe', name: 'é‘½çŸ³æ–§', emoji: 'ğŸª“', woodBonus: 4, durability: 150,
    recipe: { stick: 2, diamond: 3 },
    pattern: ['diamond','diamond',null, 'diamond','stick',null, null,'stick',null] },
];

const animals = [
  { id: 'cow',     name: 'ç‰›',  emoji: 'ğŸ„', drops: [{ id: 'leather', min: 1, max: 2 }] },
  { id: 'pig',     name: 'è±¬',  emoji: 'ğŸ·', drops: [{ id: 'pork', min: 1, max: 1 }] },
  { id: 'chicken', name: 'é›',  emoji: 'ğŸ”', drops: [{ id: 'chicken_meat', min: 1, max: 1 }, { id: 'feather', min: 1, max: 1 }] },
  { id: 'sheep',   name: 'ç¾Š',  emoji: 'ğŸ‘', drops: [{ id: 'wool', min: 1, max: 2 }] },
];

const swords = [
  { id: 'hands',          name: 'æ‰‹',     emoji: 'âœ‹', holdTime: 2500, durability: Infinity, recipe: null, pattern: null },
  { id: 'wood_sword',    name: 'æœ¨åŠ',   emoji: 'ğŸ—¡ï¸', holdTime: 1500, durability: Infinity,
    recipe: { wood: 2, stick: 1 },
    pattern: [null,'wood',null, null,'wood',null, null,'stick',null] },
  { id: 'stone_sword',   name: 'çŸ³åŠ',   emoji: 'ğŸ—¡ï¸', holdTime: 1000, durability: 30,
    recipe: { stick: 1, stone: 2 },
    pattern: [null,'stone',null, null,'stone',null, null,'stick',null] },
  { id: 'iron_sword',    name: 'éµåŠ',   emoji: 'ğŸ—¡ï¸', holdTime: 700, durability: 60,
    recipe: { stick: 1, iron: 2 },
    pattern: [null,'iron',null, null,'iron',null, null,'stick',null] },
  { id: 'gold_sword',    name: 'é‡‘åŠ',   emoji: 'ğŸ—¡ï¸', holdTime: 700, durability: 25,
    recipe: { stick: 1, gold: 2 },
    pattern: [null,'gold',null, null,'gold',null, null,'stick',null] },
  { id: 'diamond_sword', name: 'é‘½çŸ³åŠ', emoji: 'ğŸ—¡ï¸', holdTime: 400, durability: 150,
    recipe: { stick: 1, diamond: 2 },
    pattern: [null,'diamond',null, null,'diamond',null, null,'stick',null] },
];

const armorSlots = ['helmet', 'chest', 'legs', 'boots'];
const armorMaterials = [
  { id: 'leather', name: 'çš®é©', emoji: 'ğŸŸ¤' },
  { id: 'iron',    name: 'éµ',   emoji: 'â¬œ' },
  { id: 'gold',    name: 'é‡‘',   emoji: 'ğŸŸ¡' },
  { id: 'diamond', name: 'é‘½çŸ³', emoji: 'ğŸ’' },
];

const armorRecipes = [
  // Helmets: XXX / X_X / ___
  { outputId: 'leather_helmet', material: 'leather', slot: 'helmet', recipe: { leather: 5 },
    pattern: ['leather','leather','leather', 'leather',null,'leather', null,null,null] },
  { outputId: 'iron_helmet', material: 'iron', slot: 'helmet', recipe: { iron: 5 },
    pattern: ['iron','iron','iron', 'iron',null,'iron', null,null,null] },
  { outputId: 'gold_helmet', material: 'gold', slot: 'helmet', recipe: { gold: 5 },
    pattern: ['gold','gold','gold', 'gold',null,'gold', null,null,null] },
  { outputId: 'diamond_helmet', material: 'diamond', slot: 'helmet', recipe: { diamond: 5 },
    pattern: ['diamond','diamond','diamond', 'diamond',null,'diamond', null,null,null] },
  // Chestplates: X_X / XXX / XXX
  { outputId: 'leather_chest', material: 'leather', slot: 'chest', recipe: { leather: 8 },
    pattern: ['leather',null,'leather', 'leather','leather','leather', 'leather','leather','leather'] },
  { outputId: 'iron_chest', material: 'iron', slot: 'chest', recipe: { iron: 8 },
    pattern: ['iron',null,'iron', 'iron','iron','iron', 'iron','iron','iron'] },
  { outputId: 'gold_chest', material: 'gold', slot: 'chest', recipe: { gold: 8 },
    pattern: ['gold',null,'gold', 'gold','gold','gold', 'gold','gold','gold'] },
  { outputId: 'diamond_chest', material: 'diamond', slot: 'chest', recipe: { diamond: 8 },
    pattern: ['diamond',null,'diamond', 'diamond','diamond','diamond', 'diamond','diamond','diamond'] },
  // Leggings: XXX / X_X / X_X
  { outputId: 'leather_legs', material: 'leather', slot: 'legs', recipe: { leather: 7 },
    pattern: ['leather','leather','leather', 'leather',null,'leather', 'leather',null,'leather'] },
  { outputId: 'iron_legs', material: 'iron', slot: 'legs', recipe: { iron: 7 },
    pattern: ['iron','iron','iron', 'iron',null,'iron', 'iron',null,'iron'] },
  { outputId: 'gold_legs', material: 'gold', slot: 'legs', recipe: { gold: 7 },
    pattern: ['gold','gold','gold', 'gold',null,'gold', 'gold',null,'gold'] },
  { outputId: 'diamond_legs', material: 'diamond', slot: 'legs', recipe: { diamond: 7 },
    pattern: ['diamond','diamond','diamond', 'diamond',null,'diamond', 'diamond',null,'diamond'] },
  // Boots: ___ / X_X / X_X
  { outputId: 'leather_boots', material: 'leather', slot: 'boots', recipe: { leather: 4 },
    pattern: [null,null,null, 'leather',null,'leather', 'leather',null,'leather'] },
  { outputId: 'iron_boots', material: 'iron', slot: 'boots', recipe: { iron: 4 },
    pattern: [null,null,null, 'iron',null,'iron', 'iron',null,'iron'] },
  { outputId: 'gold_boots', material: 'gold', slot: 'boots', recipe: { gold: 4 },
    pattern: [null,null,null, 'gold',null,'gold', 'gold',null,'gold'] },
  { outputId: 'diamond_boots', material: 'diamond', slot: 'boots', recipe: { diamond: 4 },
    pattern: [null,null,null, 'diamond',null,'diamond', 'diamond',null,'diamond'] },
];

// General crafting recipes (non-pickaxe)
// shapeless: true means the item can be placed in any slot
const craftRecipes = [
  { id: 'wood_to_sticks', name: 'æœ¨æ£', emoji: 'ğŸ¥¢', outputId: 'stick', outputCount: 4,
    needs: { wood: 1 }, shapeless: true },
];

const houseStages = [
  { name: 'åœ°åŸº',  needs: { stone: 6 },             emoji: 'ğŸ§±' },
  { name: 'ç‰†å£',  needs: { wood: 8 },              emoji: 'ğŸ—ï¸' },
  { name: 'å±‹é ‚',  needs: { wood: 4, iron: 2 },     emoji: 'ğŸ ' },
  { name: 'è£é£¾',  needs: { gold: 1, emerald: 1 },  emoji: 'ğŸ¡' },
];

const tierColors = ['#8B7355', '#A0A0A0', '#C0C0C0', '#FFD700', '#B9F2FF'];

// ===== STATE =====
let stars = 0, streak = 0, currentFeeling = 'happy';
let matchSelected = null, matchedPairs = new Set();
let quizQuestions = [], quizIndex = 0, quizScore = 0, quizAnswered = false;
let speechSpeed = 'normal'; // 'slow' or 'normal'
let isMuted = false;

// ===== MINING STATE =====
let gems = 0;
let inventory = {};
let houseProgress = 0;
let toolDurability = {}; // { 'stone_pick': 28, ... } â€” remaining uses for active tool
let discovered = new Set(); // permanently tracks every item ID ever obtained
let equipped = { helmet: null, chest: null, legs: null, boots: null };
let selectedTools = { tool: null, weapon: null }; // null = bare hands

function getEquippedTool() {
  const id = selectedTools.tool;
  if (!id) return null;
  const lists = [pickaxes, axes];
  for (const list of lists) {
    const t = list.find(x => x.id === id);
    if (t && t.id !== 'hands' && getBlockCount(t.id) > 0) {
      if (t.durability !== Infinity && toolDurability[t.id] === undefined) toolDurability[t.id] = t.durability;
      return t;
    }
  }
  selectedTools.tool = null;
  return null;
}

function getEquippedWeapon() {
  const id = selectedTools.weapon;
  if (!id) return null;
  const t = swords.find(x => x.id === id);
  if (t && t.id !== 'hands' && getBlockCount(t.id) > 0) {
    if (t.durability !== Infinity && toolDurability[t.id] === undefined) toolDurability[t.id] = t.durability;
    return t;
  }
  selectedTools.weapon = null;
  return null;
}

function getEffectivePickaxeLevel() {
  const tool = getEquippedTool();
  if (!tool) return 0;
  const idx = pickaxes.indexOf(tool);
  return idx >= 0 ? idx : 0;
}

function getEffectiveAxeBonus() {
  const tool = getEquippedTool();
  return (tool && tool.woodBonus) ? tool.woodBonus : 1;
}

function getEffectiveSword() {
  return getEquippedWeapon() || swords[0];
}

function getEffectiveSwordHoldTime() {
  const sword = getEffectiveSword();
  return sword ? sword.holdTime : 2000;
}

// Use a tool: decrement durability, return break message or null
function useTool(tool) {
  if (!tool || tool.durability === Infinity) return null;
  if (toolDurability[tool.id] === undefined) toolDurability[tool.id] = tool.durability;
  toolDurability[tool.id]--;
  if (toolDurability[tool.id] <= 0) {
    // Tool broke
    playToolBreakSfx();
    inventory[tool.id] = (inventory[tool.id] || 1) - 1;
    if (inventory[tool.id] <= 0) delete inventory[tool.id];
    delete toolDurability[tool.id];
    // If more of same tool, set durability for next one
    if (getBlockCount(tool.id) > 0) {
      toolDurability[tool.id] = tool.durability;
    }
    saveGame();
    return tool.name;
  }
  saveGame();
  return null;
}

function getToolDurabilityText(tool) {
  if (!tool || tool.durability === Infinity) return '';
  const cur = toolDurability[tool.id] || tool.durability;
  return ` (${cur}/${tool.durability})`;
}

function saveGame() {
  localStorage.setItem('mineGame', JSON.stringify({ gems, inventory, houseProgress, stars, streak, craftGrid, toolDurability, discovered: [...discovered], equipped, selectedTools }));
}

function loadGame() {
  try {
    const d = JSON.parse(localStorage.getItem('mineGame'));
    if (!d) return;
    gems = d.gems || 0;
    inventory = d.inventory || {};
    toolDurability = d.toolDurability || {};
    if (d.discovered) discovered = new Set(d.discovered);
    if (d.equipped) equipped = { helmet: null, chest: null, legs: null, boots: null, ...d.equipped };
    if (d.selectedTools) {
      // Migrate old format { pickaxe, axe, sword } â†’ { tool, weapon }
      if ('pickaxe' in d.selectedTools || 'sword' in d.selectedTools) {
        selectedTools = { tool: d.selectedTools.pickaxe || d.selectedTools.axe || null, weapon: d.selectedTools.sword || null };
      } else {
        selectedTools = { tool: null, weapon: null, ...d.selectedTools };
      }
    }
    // Also mark any current inventory items as discovered
    Object.keys(inventory).forEach(id => discovered.add(id));
    Object.values(equipped).forEach(id => { if (id) discovered.add(id); });
    // Migration: convert old pickaxeLevel to inventory item (index shifted by +1 for hands entry)
    if (d.pickaxeLevel > 0 && (d.pickaxeLevel + 1) < pickaxes.length) {
      const oldPick = pickaxes[d.pickaxeLevel + 1];
      if (!inventory[oldPick.id]) inventory[oldPick.id] = 1;
    }
    houseProgress = d.houseProgress || 0;
    if (d.craftGrid) craftGrid = d.craftGrid;
    stars = d.stars || 0;
    streak = d.streak || 0;
    document.getElementById('stars').textContent = Math.floor(stars);
    document.getElementById('streak').textContent = streak;
    updateGemDisplay();
  } catch (e) { console.warn('Failed to load save', e); }
}

function addGems(n) {
  gems += n;
  updateGemDisplay();
  saveGame();
}

function updateGemDisplay() {
  const el = document.getElementById('gems');
  if (el) el.textContent = gems;
  const bar = document.getElementById('gemBar');
  if (bar) { bar.classList.remove('pop'); void bar.offsetWidth; bar.classList.add('pop'); }
}

function getBlockCount(id) { return inventory[id] || 0; }

function addBlock(id, n) {
  inventory[id] = (inventory[id] || 0) + (n || 1);
  discovered.add(id);
  saveGame();
}

function removeBlocks(recipe) {
  for (const [id, count] of Object.entries(recipe)) {
    inventory[id] = (inventory[id] || 0) - count;
    if (inventory[id] <= 0) delete inventory[id];
  }
  saveGame();
}

function hasBlocks(recipe) {
  return Object.entries(recipe).every(([id, count]) => getBlockCount(id) >= count);
}

// ===== TTS ENGINE =====
// Primary: SpeechSynthesis with smart voice selection
// macOS has many novelty voices (Albert, Bad News, Bells, etc.) â€” filter those out
let lastEngine = 'none';
let cachedVoice = null;

const noveltyVoices = new Set([
  'Albert','Bad News','Bahh','Bells','Boing','Bubbles','Cellos','Good News',
  'Jester','Organ','Superstar','Trinoids','Whisper','Wobble','Zarvox',
  'Ralph','Fred','Kathy','Junior','Princess'
]);

function pickBestVoice(voices) {
  if (cachedVoice) return cachedVoice;
  const preferred = ['Samantha','Alex','Karen','Daniel','Moira','Tessa','Ava','Tom','Allison'];
  for (const name of preferred) {
    const v = voices.find(v => v.name.includes(name) && v.lang.startsWith('en'));
    if (v) { cachedVoice = v; return v; }
  }
  const enUS = voices.filter(v => v.lang === 'en-US' && !noveltyVoices.has(v.name));
  if (enUS.length) { cachedVoice = enUS[0]; return enUS[0]; }
  const en = voices.filter(v => v.lang.startsWith('en') && !noveltyVoices.has(v.name));
  if (en.length) { cachedVoice = en[0]; return en[0]; }
  cachedVoice = voices.find(v => v.lang.startsWith('en')) || voices[0];
  return cachedVoice;
}

// Unlock SpeechSynthesis on first user interaction (iOS requirement)
function unlockAudio() {
  if (window.speechSynthesis) {
    const u = new SpeechSynthesisUtterance('');
    u.volume = 0;
    speechSynthesis.speak(u);
  }
}
document.addEventListener('touchstart', unlockAudio, { once: true });
document.addEventListener('click', unlockAudio, { once: true });

function updateEngineDisplay(engine, detail) {
  lastEngine = engine;
  const el = document.getElementById('engineStatus');
  if (engine === 'speech-synthesis') {
    el.textContent = `ğŸŸ¢ SpeechSynthesis${detail ? ' â€” ' + detail : ''}`;
    el.style.color = '#00B894';
  } else if (engine === 'error') {
    el.textContent = `ğŸ”´ ç„¡æ³•ç™¼éŸ³${detail ? ' â€” ' + detail : ''}`;
    el.style.color = '#FF6B6B';
  } else {
    el.textContent = 'ğŸ” åµæ¸¬ä¸­...';
    el.style.color = '#B2BEC3';
  }
}

function speak(text, forceSpeed) {
  const synth = window.speechSynthesis;
  if (!synth) {
    updateEngineDisplay('error', 'SpeechSynthesis not available');
    return null;
  }
  synth.cancel();

  const speed = forceSpeed || speechSpeed;
  const slow = speed === 'slow';
  const u = new SpeechSynthesisUtterance(text);
  u.lang = 'en-US';
  u.rate = slow ? 0.6 : 0.85;
  u.pitch = 1.05;
  const pick = pickBestVoice(synth.getVoices());
  if (pick) u.voice = pick;
  u.onstart = () => updateEngineDisplay('speech-synthesis', pick ? pick.name : 'default voice');
  u.onerror = (e) => updateEngineDisplay('error', e.error);
  synth.speak(u);
  return u;
}

// Speak word first, then sentence after a pause
function speakWordThenSentence(word, sentence) {
  const synth = window.speechSynthesis;
  if (!synth) return;
  synth.cancel();

  const speed = speechSpeed;
  const slow = speed === 'slow';
  const u = new SpeechSynthesisUtterance(word);
  u.lang = 'en-US';
  u.rate = slow ? 0.6 : 0.85;
  u.pitch = 1.05;
  const pick = pickBestVoice(synth.getVoices());
  if (pick) u.voice = pick;
  u.onstart = () => updateEngineDisplay('speech-synthesis', pick ? pick.name : 'default voice');
  u.onend = () => {
    setTimeout(() => speak(sentence), 400);
  };
  u.onerror = (e) => updateEngineDisplay('error', e.error);
  synth.speak(u);
}

// ===== SPEED TOGGLE =====
document.querySelectorAll('.speed-btn[data-speed]').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.speed-btn[data-speed]').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    speechSpeed = btn.dataset.speed;
  });
});

// ===== SFX (Web Audio API) =====
let audioCtx = null;
function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

function playMineSfx(tier) {
  if (isMuted) return;
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();

  // Noise burst â€” sounds like stone breaking
  const bufferSize = ctx.sampleRate * 0.08;
  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) {
    data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize); // decaying noise
  }
  const noise = ctx.createBufferSource();
  noise.buffer = buffer;

  // Filter â€” higher tier = higher pitch
  const filter = ctx.createBiquadFilter();
  filter.type = 'bandpass';
  filter.frequency.value = 400 + tier * 200;
  filter.Q.value = 1.5;

  const gain = ctx.createGain();
  gain.gain.value = 0.3;
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.08);

  noise.connect(filter).connect(gain).connect(ctx.destination);
  noise.start();
  noise.stop(ctx.currentTime + 0.08);

  // Extra "ding" for rare blocks (tier 4+)
  if (tier >= 4) {
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = tier >= 5 ? 1200 : 900;
    const oscGain = ctx.createGain();
    oscGain.gain.value = 0.15;
    oscGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);
    osc.connect(oscGain).connect(ctx.destination);
    osc.start(ctx.currentTime + 0.05);
    osc.stop(ctx.currentTime + 0.3);
  }
}

function playLockedSfx() {
  if (isMuted) return;
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();
  const osc = ctx.createOscillator();
  osc.type = 'square';
  osc.frequency.value = 120;
  const gain = ctx.createGain();
  gain.gain.value = 0.1;
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
  osc.connect(gain).connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.15);
}

function playCraftSfx() {
  if (isMuted) return;
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();
  // Ascending arpeggio
  [0, 1, 2].forEach((i) => {
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = 600 + i * 200;
    const gain = ctx.createGain();
    gain.gain.value = 0.12;
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15 + i * 0.1);
    osc.connect(gain).connect(ctx.destination);
    osc.start(ctx.currentTime + i * 0.1);
    osc.stop(ctx.currentTime + 0.15 + i * 0.1);
  });
}

function playToolBreakSfx() {
  if (isMuted) return;
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();
  // Descending crack â€” falling pitch + noise burst
  const osc = ctx.createOscillator();
  osc.type = 'sawtooth';
  osc.frequency.setValueAtTime(800, ctx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(120, ctx.currentTime + 0.25);
  const oscGain = ctx.createGain();
  oscGain.gain.setValueAtTime(0.2, ctx.currentTime);
  oscGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.25);
  osc.connect(oscGain).connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.25);
  // Noise burst â€” shatter texture
  const bufferSize = ctx.sampleRate * 0.15;
  const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
  const noise = ctx.createBufferSource();
  noise.buffer = buffer;
  const nGain = ctx.createGain();
  nGain.gain.value = 0.25;
  nGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
  noise.connect(nGain).connect(ctx.destination);
  noise.start(ctx.currentTime + 0.03);
  noise.stop(ctx.currentTime + 0.18);
}

function playPlaceSfx() {
  if (isMuted) return;
  const ctx = getAudioCtx();
  if (ctx.state === 'suspended') ctx.resume();
  const osc = ctx.createOscillator();
  osc.type = 'sine';
  osc.frequency.value = 500;
  const gain = ctx.createGain();
  gain.gain.value = 0.08;
  gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.06);
  osc.connect(gain).connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + 0.06);
}

// ===== UTILS =====
function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function addStars(n) {
  stars += n;
  document.getElementById('stars').textContent = Math.floor(stars);
  const el = document.getElementById('starBar');
  el.classList.remove('pop');
  void el.offsetWidth;
  el.classList.add('pop');
  saveGame();
}

function bumpStreak() {
  streak++;
  document.getElementById('streak').textContent = streak;
  const el = document.getElementById('streakBar');
  el.classList.remove('pop');
  void el.offsetWidth;
  el.classList.add('pop');
}

function resetStreak() { streak = 0; document.getElementById('streak').textContent = 0; saveGame(); }

function doConfetti() {
  const box = document.getElementById('confettiBox');
  const colors = ['#FFD93D','#FF6B6B','#A29BFE','#FF85CA','#00B894','#74B9FF'];
  for (let i = 0; i < 35; i++) {
    const p = document.createElement('div');
    p.className = 'confetti-piece';
    p.style.left = Math.random() * 100 + '%';
    p.style.background = colors[Math.floor(Math.random() * colors.length)];
    p.style.animationDelay = Math.random() * 0.5 + 's';
    p.style.animationDuration = (1.5 + Math.random()) + 's';
    const size = 6 + Math.random() * 8;
    p.style.width = size + 'px';
    p.style.height = size + 'px';
    box.appendChild(p);
  }
  setTimeout(() => box.innerHTML = '', 3000);
}

// ===== NAV =====
document.querySelectorAll('.nav-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById(tab.dataset.tab).classList.add('active');
    if (tab.dataset.tab === 'match') { if (matchedPairs.size >= 6) initMatch(); }
    if (tab.dataset.tab === 'quiz') { if (quizIndex === 0 || quizIndex >= quizQuestions.length) initQuiz(); }
    if (tab.dataset.tab === 'sight') { if (!document.getElementById('sightWordsArea').children.length) initSightWords(); }
    if (tab.dataset.tab === 'mine') { if (!mineData.length) initMine(); else refreshMineHeader(); }
    if (tab.dataset.tab === 'collection') initCollection();
  });
});

// ===== LEARN =====
function initLearn() {
  const grid = document.getElementById('feelingsGrid');
  grid.innerHTML = '';
  feelings.forEach(f => {
    const card = document.createElement('div');
    card.className = 'feeling-card';
    card.innerHTML = `
      <span class="speaker-hint">ğŸ”Š</span>
      <span class="emoji">${f.emoji}</span>
      <div class="word">${f.word}</div>
      <div class="chinese">${f.zh}</div>
    `;
    card.style.borderBottom = `4px solid ${f.color}`;
    card.addEventListener('click', () => {
      card.classList.add('speaking');
      setTimeout(() => card.classList.remove('speaking'), 800);
      speak(f.word);
      selectFeeling(f.word);
    });
    grid.appendChild(card);
  });

  const chips = document.getElementById('feelingChips');
  chips.innerHTML = '';
  feelings.forEach(f => {
    const chip = document.createElement('button');
    chip.className = 'feeling-chip' + (f.word === currentFeeling ? ' selected' : '');
    chip.textContent = `${f.emoji} ${f.word}`;
    chip.addEventListener('click', () => {
      selectFeeling(f.word);
      speak(`I feel ${f.word}.`);
    });
    chips.appendChild(chip);
  });

  // Sight words section
  const slGrid = document.getElementById('sightLearnGrid');
  slGrid.innerHTML = '';
  sightWords.forEach((sw, i) => {
    const card = document.createElement('div');
    card.className = 'sight-learn-card';
    card.style.borderBottom = `4px solid ${sightColors[i % sightColors.length]}`;
    card.innerHTML = `
      <span class="speaker-hint">ğŸ”Š</span>
      <div class="sl-word">${sw.word}</div>
      <div class="sl-zh">${sw.zh}</div>
      <div class="sl-sentence">${sw.sentence}</div>
    `;
    card.addEventListener('click', () => {
      card.classList.add('speaking');
      setTimeout(() => card.classList.remove('speaking'), 800);
      speakWordThenSentence(sw.word, sw.sentence);
    });
    slGrid.appendChild(card);
  });
}

function selectFeeling(word) {
  currentFeeling = word;
  const f = feelings.find(x => x.word === word);
  document.getElementById('sentenceDisplay').innerHTML =
    `I feel <span class="hl">${word}</span>. ${f?.emoji || ''}`;
  document.querySelectorAll('.feeling-chip').forEach(c => {
    c.classList.toggle('selected', c.textContent.includes(word));
  });
}

document.getElementById('speakSentenceBtn').addEventListener('click', () => speak(`I feel ${currentFeeling}.`));
document.getElementById('randomSentenceBtn').addEventListener('click', () => {
  const r = feelings[Math.floor(Math.random() * feelings.length)];
  selectFeeling(r.word);
  speak(`I feel ${r.word}.`);
});

// ===== MATCH =====
function initMatch() {
  const pool = shuffle(feelings).slice(0, 6);
  const wCol = document.getElementById('matchWords');
  const eCol = document.getElementById('matchEmojis');
  wCol.innerHTML = '<h3>Words å–®å­—</h3>';
  eCol.innerHTML = '<h3>Emoji è¡¨æƒ…</h3>';
  matchSelected = null;
  matchedPairs = new Set();
  document.getElementById('matchFeedback').textContent = 'é»ä¸€å€‹å–®å­—ï¼Œå†é»é…å°çš„è¡¨æƒ…ï¼ ğŸ¯';

  shuffle(pool).forEach(f => {
    const item = document.createElement('div');
    item.className = 'match-item';
    item.textContent = f.word;
    item.dataset.word = f.word;
    item.dataset.type = 'word';
    item.addEventListener('click', () => matchClick(item));
    wCol.appendChild(item);
  });
  shuffle(pool).forEach(f => {
    const item = document.createElement('div');
    item.className = 'match-item emoji-item';
    item.textContent = f.emoji;
    item.dataset.word = f.word;
    item.dataset.type = 'emoji';
    item.addEventListener('click', () => matchClick(item));
    eCol.appendChild(item);
  });
}

function matchClick(item) {
  if (item.classList.contains('matched')) return;

  if (!matchSelected) {
    matchSelected = item;
    item.classList.add('selected');
    if (item.dataset.type === 'word') speak(item.dataset.word);
    return;
  }
  if (matchSelected === item) {
    item.classList.remove('selected');
    matchSelected = null;
    return;
  }
  if (matchSelected.dataset.type === item.dataset.type) {
    matchSelected.classList.remove('selected');
    matchSelected = item;
    item.classList.add('selected');
    if (item.dataset.type === 'word') speak(item.dataset.word);
    return;
  }

  if (matchSelected.dataset.word === item.dataset.word) {
    const prev = matchSelected;
    prev.classList.remove('selected');
    prev.classList.add('correct');
    item.classList.add('correct');
    const f = feelings.find(x => x.word === item.dataset.word);
    speak(item.dataset.word);
    document.getElementById('matchFeedback').textContent = `âœ… ${f?.emoji} ${f?.word} = ${f?.zh}ï¼`;
    addStars(1); bumpStreak(); addGems(1);
    setTimeout(() => {
      prev.classList.add('matched'); prev.classList.remove('correct');
      item.classList.add('matched'); item.classList.remove('correct');
    }, 600);
    matchedPairs.add(item.dataset.word);
    if (matchedPairs.size >= 6) {
      setTimeout(() => {
        document.getElementById('matchFeedback').textContent = 'ğŸ‰ å…¨éƒ¨é…å°å®Œæˆï¼å¤ªæ£’äº†ï¼';
        addStars(3); doConfetti(); addGems(2);
      }, 700);
    }
  } else {
    const prev = matchSelected;
    prev.classList.add('wrong'); item.classList.add('wrong');
    resetStreak();
    document.getElementById('matchFeedback').textContent = 'âŒ å†è©¦ä¸€æ¬¡ï¼';
    setTimeout(() => {
      prev.classList.remove('wrong', 'selected');
      item.classList.remove('wrong');
    }, 500);
  }
  matchSelected = null;
}

document.getElementById('resetMatch').addEventListener('click', initMatch);

// ===== QUIZ =====
function initQuiz() {
  quizQuestions = shuffle(feelings).slice(0, 8).map(f => {
    const others = shuffle(feelings.filter(x => x.word !== f.word)).slice(0, 3);
    return { feeling: f, options: shuffle([f, ...others]), type: Math.random() > 0.5 ? 'e2w' : 'w2e' };
  });
  quizIndex = 0; quizScore = 0;
  renderQuiz();
}

function renderQuiz() {
  const c = document.getElementById('quizContainer');
  if (quizIndex >= quizQuestions.length) {
    const pct = Math.round(quizScore / quizQuestions.length * 100);
    const msg = pct === 100 ? 'ğŸ† Perfect! å®Œç¾ï¼' : pct >= 75 ? 'ğŸŒŸ Great! å¾ˆæ£’ï¼' : 'ğŸ’ª Keep going! åŠ æ²¹ï¼';
    c.innerHTML = `<div class="quiz-result">
      <div class="big-emoji">${pct === 100 ? 'ğŸ‰' : pct >= 75 ? 'ğŸŒŸ' : 'ğŸ’ª'}</div>
      <div class="result-text">${msg}</div>
      <div class="result-detail">${quizScore} / ${quizQuestions.length} ç­”å°</div>
      <button class="speak-btn primary" onclick="initQuiz()">ğŸ”„ å†ä¾†ä¸€æ¬¡</button>
    </div>`;
    if (pct >= 75) { addStars(5); doConfetti(); addGems(3); }
    return;
  }

  const q = quizQuestions[quizIndex];
  quizAnswered = false;
  const dots = quizQuestions.map((_, i) => `<div class="quiz-dot${i < quizIndex ? ' done' : ''}${i === quizIndex ? ' current' : ''}"></div>`).join('');

  if (q.type === 'e2w') {
    c.innerHTML = `
      <div class="quiz-progress">${dots}</div>
      <div class="quiz-prompt">${q.feeling.emoji}</div>
      <div class="quiz-question">é€™æ˜¯ä»€éº¼æ„Ÿè¦ºï¼Ÿ</div>
      <button class="speak-btn small primary" style="margin-bottom:16px" id="quizHint">ğŸ”Š è½æç¤º</button>
      <div class="quiz-options">
        ${q.options.map(o => `<button class="quiz-option" data-word="${o.word}">${o.word}</button>`).join('')}
      </div>`;
  } else {
    c.innerHTML = `
      <div class="quiz-progress">${dots}</div>
      <div class="quiz-prompt" style="font-size:2.2rem;font-family:'Fredoka',sans-serif;font-weight:700">${q.feeling.word}</div>
      <div class="quiz-question">å“ªå€‹è¡¨æƒ…ç¬¦åˆï¼Ÿ</div>
      <button class="speak-btn small primary" style="margin-bottom:16px" id="quizHint">ğŸ”Š è½ç™¼éŸ³</button>
      <div class="quiz-options">
        ${q.options.map(o => `<button class="quiz-option" data-word="${o.word}">${o.emoji} ${o.zh}</button>`).join('')}
      </div>`;
  }

  // Don't auto-speak â€” iOS blocks audio without a direct user gesture.
  // The hint button below lets the user trigger it.

  // Hint button
  c.querySelector('#quizHint')?.addEventListener('click', () => speak(q.feeling.word));

  c.querySelectorAll('.quiz-option').forEach(btn => {
    btn.addEventListener('click', () => {
      if (quizAnswered) return;
      quizAnswered = true;
      const correct = btn.dataset.word === q.feeling.word;
      if (correct) {
        btn.classList.add('correct-answer');
        quizScore++; addStars(1); bumpStreak(); addGems(1);
        speak('Great job!');
      } else {
        btn.classList.add('wrong-answer');
        resetStreak();
        c.querySelector(`[data-word="${q.feeling.word}"]`)?.classList.add('correct-answer');
        speak(q.feeling.word);
      }
      setTimeout(() => { quizIndex++; renderQuiz(); }, 1300);
    });
  });
}

// ===== SIGHT WORDS =====
let sightEarned = new Set();

function initSightWords() {
  const area = document.getElementById('sightWordsArea');
  area.textContent = '';

  sightWords.forEach((sw, i) => {
    const card = document.createElement('div');
    card.className = 'sight-word-card';
    card.style.borderLeft = `5px solid ${sightColors[i]}`;

    const info = document.createElement('div');
    const wordEl = document.createElement('div');
    wordEl.className = 'sight-word-text';
    wordEl.textContent = sw.word;
    const zhEl = document.createElement('div');
    zhEl.className = 'sight-word-chinese';
    zhEl.textContent = `${sw.zh} â€” "${sw.sentence}"`;
    info.appendChild(wordEl);
    info.appendChild(zhEl);

    const playIcon = document.createElement('div');
    playIcon.className = 'play-icon';
    playIcon.textContent = 'ğŸ”Š';

    // Create confirm button immediately (disabled)
    const btn = document.createElement('button');
    btn.className = 'sight-confirm';
    btn.textContent = 'ğŸ¤ æˆ‘è·Ÿè‘—å”¸äº†ï¼+âš¡';
    btn.disabled = true;
    btn.style.opacity = '0.4';

    if (sightEarned.has(sw.word)) {
      playIcon.textContent = 'âœ…';
      card.classList.add('earned');
    } else {
      info.appendChild(btn);
    }

    card.appendChild(info);
    card.appendChild(playIcon);

    card.addEventListener('click', () => {
      if (sightEarned.has(sw.word)) {
        speakWordThenSentence(sw.word, sw.sentence);
        return;
      }
      card.classList.add('speaking');
      speakWordThenSentence(sw.word, sw.sentence);
      // Enable button after audio plays
      setTimeout(() => {
        card.classList.remove('speaking');
        if (sightEarned.has(sw.word)) return;
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.animation = 'fadeIn 0.3s ease';
      }, 2500);
    });

    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      sightEarned.add(sw.word);
      addGems(1);
      btn.remove();
      card.classList.add('earned');
      playIcon.textContent = 'âœ…';
    });
    area.appendChild(card);
  });

  const extra = document.createElement('div');
  extra.className = 'sentence-practice';
  extra.style.marginTop = '8px';
  extra.innerHTML = `
    <h3>ğŸ“Œ Weekly Quote æ¯é€±ä½³å¥</h3>
    <div class="sentence-display" style="font-size:1.3rem">"Life is better when you are happy." ğŸ˜Š</div>
    <button class="speak-btn primary small" onclick="speak('Life is better when you are happy.')">ğŸ”Š Listen</button>
    <div style="margin-top:18px">
      <h3>ğŸµ Song & Rhyme</h3>
      <div class="sentence-display" style="font-size:1.4rem;margin-top:8px">âœ¨ Hakuna Matata âœ¨</div>
      <button class="speak-btn secondary small" onclick="speak('Hakuna Matata! It means no worries!')">ğŸ”Š Listen</button>
    </div>`;
  area.appendChild(extra);
}

// ===== MINE =====
// Mountain shape: each row = { width, tier } â€” triangle from peak to base
const mountainShape = [
  { width: 2, tier: 0 },   // tree tops
  { width: 4, tier: 0 },   // more trees
  { width: 6, tier: 1 },   // dirt/wood
  { width: 8, tier: 1 },
  { width: 10, tier: 1 },
  { width: 12, tier: 2 },  // stone/coal
  { width: 12, tier: 2 },
  { width: 12, tier: 2 },
  { width: 12, tier: 3 },  // iron/copper
  { width: 12, tier: 3 },
  { width: 12, tier: 3 },
  { width: 12, tier: 4 },  // gold/emerald
  { width: 12, tier: 4 },
  { width: 12, tier: 5 },  // diamond/amethyst
  { width: 12, tier: 5 },
];

let mineData = []; // 2D array: each cell = { block, mined, tier, el } or null

function rollBlockForTier(tier) {
  const pool = blocks.filter(b => b.tier === tier);
  const totalWeight = pool.reduce((s, b) => s + b.weight, 0);
  let r = Math.random() * totalWeight;
  for (const b of pool) {
    r -= b.weight;
    if (r <= 0) return b;
  }
  return pool[pool.length - 1];
}

function isExposed(row, col) {
  if (mineData[row][col] === null || mineData[row][col].mined) return false;
  // Check 4 neighbors â€” if any is outside mountain or mined, this cell is exposed
  const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
  for (const [dr, dc] of dirs) {
    const nr = row + dr, nc = col + dc;
    if (nr < 0 || nr >= mineData.length) return true; // top/bottom edge
    if (nc < 0 || nc >= mineData[nr].length) return true; // side edge
    if (mineData[nr][nc] === null) return true; // outside mountain shape
    if (mineData[nr][nc].mined) return true; // adjacent to mined cell
    if (mineData[nr][nc].tier === 0) return true; // tree row counts as open
  }
  return false;
}

function updateExposure() {
  const maxTier = pickaxes[getEffectivePickaxeLevel()].maxTier;
  for (let r = 0; r < mineData.length; r++) {
    for (let c = 0; c < mineData[r].length; c++) {
      const cell = mineData[r][c];
      if (!cell || cell.mined || cell.tier === 0) continue;
      const exposed = isExposed(r, c);
      const locked = cell.tier > maxTier;
      cell.el.classList.toggle('unexposed', !exposed);
      cell.el.classList.toggle('locked', exposed && locked);
    }
  }
}

function resetCellProgress(el) {
  const fill = el.querySelector('.mine-progress-fill');
  if (fill) fill.style.width = '0%';
}

function showMineResult(msg, toolBroke) {
  const el = document.getElementById('mineResult');
  el.textContent = msg;
  el.classList.remove('tool-broke');
  if (toolBroke) {
    // Force reflow to restart animation
    void el.offsetWidth;
    el.classList.add('tool-broke');
  }
}

let mineHoldRAF = null;
let mineHoldTarget = null;
let mineHoldStart = 0;

function getMineHoldDuration(cellData) {
  if (cellData.animal) {
    const sword = getEffectiveSword();
    return sword ? sword.holdTime : 2000;
  }
  if (cellData.tier === 0) {
    const tool = getEquippedTool();
    if (!tool || !tool.woodBonus) return 2000; // bare hands or non-axe tool
    return tool.woodBonus >= 3 ? 600 : 1000; // iron+ axe : wood/stone axe
  }
  const pickLevel = getEffectivePickaxeLevel();
  const pick = pickaxes[pickLevel];
  if (cellData.tier > pick.maxTier) return Infinity;
  const tierDiff = cellData.tier - pickLevel;
  if (tierDiff <= 0) return 800;
  return 800 + tierDiff * 600;
}

function startMineHold(cellData) {
  if (cellData.mined) return;
  const duration = getMineHoldDuration(cellData);
  if (duration === Infinity) {
    playLockedSfx();
    const needed = pickaxes.find(p => p.maxTier >= cellData.tier && p.id !== 'hands');
    const neededName = needed ? needed.name : 'æ›´å¥½çš„å·¥å…·';
    showMineResult('ğŸ”’ éœ€è¦ ' + neededName + ' ä»¥ä¸Šæ‰èƒ½æŒ–ç¬¬ ' + cellData.tier + ' å±¤ï¼', false);
    return;
  }

  let bar = cellData.el.querySelector('.mine-progress');
  if (!bar) {
    bar = document.createElement('div');
    bar.className = 'mine-progress';
    const fill = document.createElement('div');
    fill.className = 'mine-progress-fill';
    bar.appendChild(fill);
    cellData.el.appendChild(bar);
  }
  const fill = bar.querySelector('.mine-progress-fill');
  fill.style.width = '0%';

  cellData.el.classList.add('mining');
  mineHoldStart = Date.now();
  mineHoldTarget = { cellData, duration, fill };

  function updateProgress() {
    if (!mineHoldTarget) return;
    const elapsed = Date.now() - mineHoldStart;
    const pct = Math.min(100, (elapsed / duration) * 100);
    fill.style.width = pct + '%';
    if (elapsed >= duration) {
      completeMineHold();
      return;
    }
    mineHoldRAF = requestAnimationFrame(updateProgress);
  }
  mineHoldRAF = requestAnimationFrame(updateProgress);
}

function completeMineHold() {
  if (!mineHoldTarget) return;
  const { cellData } = mineHoldTarget;
  cancelMineHold(false);

  if (cellData.animal) {
    attackAnimal(cellData);
  } else if (cellData.tier === 0) {
    chopTree(cellData);
  } else {
    for (let r = 0; r < mineData.length; r++) {
      for (let c = 0; c < mineData[r].length; c++) {
        if (mineData[r][c] === cellData) {
          mineMountainCell(r, c, cellData);
          return;
        }
      }
    }
  }
}

function cancelMineHold(resetBar) {
  if (resetBar === undefined) resetBar = true;
  if (mineHoldRAF) cancelAnimationFrame(mineHoldRAF);
  mineHoldRAF = null;
  if (mineHoldTarget) {
    mineHoldTarget.cellData.el.classList.remove('mining');
    if (resetBar) mineHoldTarget.fill.style.width = '0%';
  }
  mineHoldTarget = null;
}

function initMine() {
  const area = document.getElementById('mineArea');
  const pick = pickaxes[getEffectivePickaxeLevel()];
  area.textContent = '';
  mineData = [];

  // Header
  const header = document.createElement('div');
  header.className = 'mine-header';
  const h3 = document.createElement('h3');
  h3.textContent = 'â›ï¸ æŒ–ç¤¦ Mine';
  const toolChips = document.createElement('div');
  toolChips.className = 'tool-slots';
  toolChips.id = 'toolChips';
  renderToolChips(toolChips);
  const costInfo = document.createElement('div');
  costInfo.className = 'mine-cost';
  costInfo.textContent = 'æ¯æ ¼èŠ±è²» 1 âš¡ é«”åŠ›';
  const holdHint = document.createElement('div');
  holdHint.className = 'mine-hold-hint';
  holdHint.textContent = 'ğŸ‘† æŒ‰ä½ä¸æ”¾ä¾†æŒ–ç¤¦ï¼Hold to mine!';
  header.appendChild(h3);
  header.appendChild(toolChips);
  header.appendChild(costInfo);
  header.appendChild(holdHint);
  area.appendChild(header);

  // Result (above mountain so it's visible on short screens)
  const result = document.createElement('div');
  result.className = 'mine-result';
  result.id = 'mineResult';
  area.appendChild(result);

  // Mountain
  const mountain = document.createElement('div');
  mountain.className = 'mountain';
  const maxWidth = 12;

  mountainShape.forEach((rowDef, r) => {
    const rowEl = document.createElement('div');
    rowEl.className = 'mountain-row';
    const rowData = [];

    // Pad to maxWidth with nulls for consistent indexing
    const offset = Math.floor((maxWidth - rowDef.width) / 2);
    for (let c = 0; c < maxWidth; c++) {
      if (c < offset || c >= offset + rowDef.width) {
        rowData.push(null);
        continue;
      }

      const cellEl = document.createElement('div');
      cellEl.className = 'mine-cell';

      if (rowDef.tier === 0) {
        if (Math.random() < 0.35) {
          // Animal
          const animal = animals[Math.floor(Math.random() * animals.length)];
          cellEl.classList.add('animal');
          cellEl.textContent = animal.emoji;
          const animalData = { tier: 0, mined: false, block: null, animal: animal, el: cellEl };
          rowData.push(animalData);
        } else {
          // Choppable trees â€” gives wood
          cellEl.classList.add('tree');
          cellEl.textContent = Math.random() > 0.5 ? 'ğŸŒ³' : 'ğŸŒ²';
          const woodBlock = blocks.find(b => b.id === 'wood');
          const treeData = { tier: 0, mined: false, block: woodBlock, el: cellEl };
          rowData.push(treeData);
        }
      } else {
        const block = rollBlockForTier(rowDef.tier);
        cellEl.classList.add('tier' + rowDef.tier);
        const cellData = { tier: rowDef.tier, mined: false, block, el: cellEl };
        rowData.push(cellData);
      }

      // Hold-to-mine events (touch + mouse)
      const holdData = rowData[rowData.length - 1];
      if (holdData) {
        const startHold = (e) => { e.preventDefault(); startMineHold(holdData); };
        const endHold = () => cancelMineHold();
        cellEl.addEventListener('mousedown', startHold);
        cellEl.addEventListener('mouseup', endHold);
        cellEl.addEventListener('mouseleave', endHold);
        cellEl.addEventListener('touchstart', startHold, { passive: false });
        cellEl.addEventListener('touchend', endHold);
        cellEl.addEventListener('touchcancel', endHold);
      }

      rowEl.appendChild(cellEl);
    }

    mineData.push(rowData);
    mountain.appendChild(rowEl);
  });

  const mountainScroll = document.createElement('div');
  mountainScroll.className = 'mountain-scroll';
  mountainScroll.appendChild(mountain);
  const scrollHint = document.createElement('div');
  scrollHint.className = 'mountain-scroll-hint';
  mountainScroll.appendChild(scrollHint);
  mountainScroll.addEventListener('scroll', () => {
    if (mountainScroll.scrollLeft > 10) scrollHint.style.display = 'none';
  }, { passive: true });
  area.appendChild(mountainScroll);

  // Refresh button
  const refreshBtn = document.createElement('button');
  refreshBtn.className = 'mine-refresh';
  refreshBtn.id = 'mineRefresh';
  refreshBtn.textContent = 'ğŸ”„ æ–°å±±é«” New Mountain';
  refreshBtn.addEventListener('click', initMine);
  area.appendChild(refreshBtn);

  updateExposure();
  updateMineRefreshBtn();
}

function attackAnimal(cellData) {
  if (cellData.mined) return;
  if (gems < 1) {
    playLockedSfx();
    resetCellProgress(cellData.el);
    document.getElementById('mineResult').textContent = 'âš¡ é«”åŠ›ä¸è¶³ï¼å»ç­”é¡Œè£œå……å§ï¼';
    return;
  }
  playMineSfx(1);
  gems--;
  updateGemDisplay();
  cellData.mined = true;
  cellData.el.classList.add('mined');

  const animal = cellData.animal;
  const activeSword = getEffectiveSword();
  const brokeName = useTool(activeSword);

  let msg = animal.emoji + ' æ“Šæ•—' + animal.name + 'ï¼ç²å¾—ï¼š';
  animal.drops.forEach(drop => {
    const count = drop.min + Math.floor(Math.random() * (drop.max - drop.min + 1));
    addBlock(drop.id, count);
    const b = blocks.find(x => x.id === drop.id);
    msg += ' ' + b.emoji + b.name + ' x' + count;
  });
  if (brokeName) msg += '\nğŸ’¥ ' + brokeName + ' å£æ‰äº†ï¼';

  showMineResult(msg, !!brokeName);
  if (brokeName) refreshToolChips();
  updateExposure();
  updateMineRefreshBtn();
  saveGame();
}

function chopTree(cellData) {
  if (cellData.mined) return;
  if (gems < 1) {
    playLockedSfx();
    resetCellProgress(cellData.el);
    document.getElementById('mineResult').textContent = 'âš¡ é«”åŠ›ä¸è¶³ï¼å»ç­”é¡Œè£œå……å§ï¼';
    return;
  }
  playMineSfx(1);
  gems--;
  updateGemDisplay();
  cellData.mined = true;
  cellData.el.classList.add('mined');
  const activeTool = getEquippedTool();
  const isAxe = activeTool && activeTool.woodBonus;
  const woodCount = isAxe ? activeTool.woodBonus : 1;
  addBlock('wood', woodCount);
  const stickDrop = Math.random() < 0.5 ? 1 : 0;
  if (stickDrop) addBlock('stick', stickDrop);
  const brokeName = isAxe ? useTool(activeTool) : null;
  const axeMsg = woodCount > 1 ? ` (ğŸª“ æ–§é ­åŠ æˆ x${woodCount})` : '';
  const stickMsg = stickDrop ? ` + ğŸ¥¢ æœ¨æ£ x${stickDrop}` : '';
  const breakMsg = brokeName ? `\nğŸ’¥ ${brokeName} å£æ‰äº†ï¼` : '';
  showMineResult(`ğŸªµ æœ¨é ­ x${woodCount}${stickMsg}${axeMsg}${breakMsg}`, !!brokeName);
  if (brokeName) refreshToolChips();
  updateExposure();
  updateMineRefreshBtn();
  saveGame();
}

function mineMountainCell(row, col, cellData) {
  if (cellData.mined) return;

  const maxTier = pickaxes[getEffectivePickaxeLevel()].maxTier;
  if (cellData.tier > maxTier) {
    playLockedSfx();
    document.getElementById('mineResult').textContent = `ğŸ”’ éœ€è¦æ›´å¥½çš„å·¥å…·æ‰èƒ½æŒ–ç¬¬ ${cellData.tier} å±¤ï¼`;
    return;
  }

  if (!isExposed(row, col)) return;

  if (gems < 1) {
    playLockedSfx();
    resetCellProgress(cellData.el);
    document.getElementById('mineResult').textContent = 'âš¡ é«”åŠ›ä¸è¶³ï¼å»ç­”é¡Œè£œå……å§ï¼';
    return;
  }

  playMineSfx(cellData.tier);
  gems--;
  updateGemDisplay();
  cellData.mined = true;
  cellData.el.classList.add('mined');
  cellData.el.textContent = '';
  const reveal = document.createElement('span');
  reveal.className = 'block-reveal';
  reveal.textContent = cellData.block.emoji;
  cellData.el.appendChild(reveal);
  // Fade out emoji after animation
  setTimeout(() => { cellData.el.textContent = ''; }, 800);

  addBlock(cellData.block.id);

  const activePick = getEquippedTool();
  const brokeName = useTool(activePick);

  const b = cellData.block;
  const rarity = b.tier >= 4 ? ' âœ¨ ç¨€æœ‰ï¼' : b.tier >= 3 ? ' ä¸éŒ¯ï¼' : '';
  const breakMsg = brokeName ? `\nğŸ’¥ ${brokeName} å£æ‰äº†ï¼` : '';
  showMineResult(`${b.emoji} æŒ–åˆ° ${b.name}ï¼${rarity}${breakMsg}ï¼ˆæ“æœ‰ ${getBlockCount(b.id)} å€‹ï¼‰`, !!brokeName);

  if (brokeName) refreshToolChips();
  if (b.tier >= 4) doConfetti();
  updateExposure();
  updateMineRefreshBtn();
  saveGame();
}

function updateMineRefreshBtn() {
  const btn = document.getElementById('mineRefresh');
  if (btn) btn.disabled = gems < 1;
}

function renderToolChips(container) {
  container.textContent = '';
  const tool = getEquippedTool();
  const weapon = getEquippedWeapon();

  const slots = [
    { category: 'å·¥å…·', equip: tool, fallbackEmoji: 'âœ‹', fallbackName: 'æ‰‹', type: 'tool' },
    { category: 'æ­¦å™¨', equip: weapon, fallbackEmoji: 'âœ‹', fallbackName: 'æ‰‹', type: 'weapon' },
  ];

  slots.forEach(s => {
    const slot = document.createElement('div');
    slot.className = 'tool-slot';
    const label = document.createElement('div');
    label.className = 'tool-slot-label';
    label.textContent = s.category;
    const emoji = document.createElement('div');
    emoji.className = 'tool-slot-emoji';
    emoji.textContent = s.equip ? s.equip.emoji : s.fallbackEmoji;
    const name = document.createElement('div');
    name.className = 'tool-slot-name';
    name.textContent = s.equip ? s.equip.name : s.fallbackName;
    slot.appendChild(label);
    slot.appendChild(emoji);
    slot.appendChild(name);
    if (s.equip && s.equip.durability !== Infinity) {
      const dur = document.createElement('div');
      dur.className = 'tool-slot-dur';
      dur.textContent = getToolDurabilityText(s.equip);
      slot.appendChild(dur);
    }
    slot.addEventListener('click', (e) => { e.stopPropagation(); openToolPicker(slot, s.type); });
    container.appendChild(slot);
  });
}

function openToolPicker(chipEl, type) {
  // type: 'tool' or 'weapon'
  closeToolPicker();

  const selKey = type;
  const currentId = selectedTools[selKey]; // null = bare hands

  // Build available items: always start with bare hands
  const options = [{ id: 'hands', name: 'æ‰‹', emoji: 'âœ‹', _isHands: true }];

  if (type === 'tool') {
    pickaxes.forEach(t => { if (t.id !== 'hands' && getBlockCount(t.id) > 0) options.push(t); });
    axes.forEach(t => { if (getBlockCount(t.id) > 0) options.push(t); });
  } else {
    swords.forEach(t => { if (t.id !== 'hands' && getBlockCount(t.id) > 0) options.push(t); });
  }

  // Backdrop
  const backdrop = document.createElement('div');
  backdrop.className = 'tool-picker-backdrop';
  backdrop.addEventListener('click', closeToolPicker);
  (document.querySelector('.app') || document.body).appendChild(backdrop);

  // Picker
  const picker = document.createElement('div');
  picker.className = 'tool-picker';
  picker.id = 'activeToolPicker';

  options.forEach(t => {
    const opt = document.createElement('div');
    opt.className = 'tool-picker-option';
    const isHands = t._isHands || t.id === 'hands';
    const dur = isHands ? '' : getToolDurabilityText(t);
    const info = t.maxTier ? 'å¯æŒ–ç¬¬ ' + t.maxTier + ' å±¤' :
                 t.woodBonus ? 'ç æ¨¹ x' + t.woodBonus : '';
    // Build option content with safe DOM methods
    const emojiSpan = document.createElement('span');
    emojiSpan.className = 'opt-emoji';
    emojiSpan.textContent = t.emoji;
    opt.appendChild(emojiSpan);
    opt.appendChild(document.createTextNode(' ' + t.name));
    if (info) { const s = document.createElement('span'); s.className = 'opt-info'; s.textContent = info; opt.appendChild(s); }
    if (dur) { const s = document.createElement('span'); s.className = 'opt-info'; s.textContent = dur; opt.appendChild(s); }
    if ((isHands && !currentId) || t.id === currentId) opt.classList.add('selected');
    opt.addEventListener('click', (e) => {
      e.stopPropagation();
      selectedTools[selKey] = isHands ? null : t.id;
      saveGame(); closeToolPicker(); refreshToolChips(); updateExposure();
      if (collectionView === 'equip') initCollection();
    });
    picker.appendChild(opt);
  });

  // Append picker to .app (same stacking context as backdrop) and position near chip
  const appEl = document.querySelector('.app') || document.body;
  const rect = chipEl.getBoundingClientRect();
  picker.style.position = 'fixed';
  picker.style.left = rect.left + rect.width / 2 + 'px';
  picker.style.top = rect.bottom + 6 + 'px';
  picker.style.transform = 'translateX(-50%)';
  appEl.appendChild(picker);
}

function closeToolPicker() {
  const picker = document.getElementById('activeToolPicker');
  if (picker) picker.remove();
  const backdrop = document.querySelector('.tool-picker-backdrop');
  if (backdrop) backdrop.remove();
}

function refreshToolChips() {
  const el = document.getElementById('toolChips');
  if (el) renderToolChips(el);
}

function openArmorPicker(cellEl, slot) {
  closeToolPicker();
  const slotNames = { helmet: 'é ­ç›”', chest: 'ç›”ç”²', legs: 'è¤²å­', boots: 'é‹å­' };

  // Build options: unequip + available armor for this slot
  const options = [];
  if (equipped[slot]) options.push({ id: '__unequip__', emoji: 'âŒ', name: 'è„«ä¸‹' });
  blocks.forEach(b => {
    if (!b.id.includes('_' + slot)) return;
    const count = getBlockCount(b.id);
    if (count <= 0 && b.id !== equipped[slot]) return;
    options.push({ id: b.id, emoji: b.emoji, name: b.name, count, wearing: b.id === equipped[slot] });
  });

  if (options.length === 0) return; // nothing to do

  const backdrop = document.createElement('div');
  backdrop.className = 'tool-picker-backdrop';
  backdrop.addEventListener('click', closeToolPicker);
  (document.querySelector('.app') || document.body).appendChild(backdrop);

  const picker = document.createElement('div');
  picker.className = 'tool-picker';
  picker.id = 'activeToolPicker';

  // Title
  const title = document.createElement('div');
  title.style.cssText = 'padding:8px 14px 4px;font-family:Fredoka,sans-serif;font-size:0.75rem;color:#B2BEC3;';
  title.textContent = slotNames[slot];
  picker.appendChild(title);

  options.forEach(o => {
    const opt = document.createElement('div');
    opt.className = 'tool-picker-option';
    if (o.wearing) opt.classList.add('selected');
    const countText = o.count ? ' x' + o.count : '';
    const emojiSpan = document.createElement('span');
    emojiSpan.className = 'opt-emoji';
    emojiSpan.textContent = o.emoji;
    opt.appendChild(emojiSpan);
    opt.appendChild(document.createTextNode(' ' + o.name + countText));
    opt.addEventListener('click', (e) => {
      e.stopPropagation(); // prevent bubble to parent cell re-opening picker
      if (o.id === '__unequip__') {
        addBlock(equipped[slot]);
        equipped[slot] = null;
      } else if (o.wearing) {
        // Already wearing, unequip
        addBlock(equipped[slot]);
        equipped[slot] = null;
      } else {
        // Equip: return current to inventory, take new from inventory
        if (equipped[slot]) addBlock(equipped[slot]);
        inventory[o.id] = (inventory[o.id] || 1) - 1;
        if (inventory[o.id] <= 0) delete inventory[o.id];
        equipped[slot] = o.id;
      }
      saveGame(); closeToolPicker(); initCollection();
    });
    picker.appendChild(opt);
  });

  // Append picker to .app (same stacking context as backdrop)
  const appEl = document.querySelector('.app') || document.body;
  const rect = cellEl.getBoundingClientRect();
  picker.style.position = 'fixed';
  picker.style.left = rect.left + rect.width / 2 + 'px';
  picker.style.top = rect.bottom + 6 + 'px';
  picker.style.transform = 'translateX(-50%)';
  appEl.appendChild(picker);
}

function refreshMineHeader() {
  refreshToolChips();
  updateExposure();
  updateMineRefreshBtn();
}

// ===== COLLECTION =====
let collectionView = 'encyclopedia';

function renderCharacter(container, size) {
  container.textContent = '';
  const display = document.createElement('div');
  display.className = 'character-display' + (size === 'small' ? ' small' : '');

  const getEquip = (slot, fallback) => {
    if (!equipped[slot]) return { emoji: fallback, name: null, empty: true };
    const b = blocks.find(x => x.id === equipped[slot]);
    return b ? { emoji: b.emoji, name: b.name, empty: false } : { emoji: fallback, name: null, empty: true };
  };

  const tool = getEquippedTool();
  const weapon = getEquippedWeapon();
  const small = size === 'small';
  const helmet = getEquip('helmet', small ? 'ğŸ˜Š' : 'ğŸ§¢');
  const chest = getEquip('chest', small ? 'Â·' : 'ğŸ‘•');
  const legs = getEquip('legs', small ? 'Â·' : 'ğŸ‘–');
  const boots = getEquip('boots', small ? 'Â·' : 'ğŸ‘Ÿ');

  // Grid: 3 columns Ã— 4 rows
  //    _   é ­    _
  //  æ­¦å™¨  è¡£  å·¥å…·
  //    _   è¤²    _
  //    _   é‹    _
  const grid = [
    { emoji: '',           label: '',                              action: null },
    { emoji: helmet.emoji, label: helmet.name || 'é ­', empty: helmet.empty, action: { type: 'armor', slot: 'helmet' } },
    { emoji: '',           label: '',                              action: null },
    { emoji: weapon ? weapon.emoji : 'âœ‹', label: weapon ? weapon.name : 'æ­¦å™¨', empty: !weapon, action: { type: 'tool', toolType: 'weapon' } },
    { emoji: chest.emoji,  label: chest.name || 'è¡£', empty: chest.empty,  action: { type: 'armor', slot: 'chest' } },
    { emoji: tool ? tool.emoji : 'âœ‹',    label: tool ? tool.name : 'å·¥å…·', empty: !tool, action: { type: 'tool', toolType: 'tool' } },
    { emoji: '',           label: '',                              action: null },
    { emoji: legs.emoji,   label: legs.name || 'è¤²', empty: legs.empty,   action: { type: 'armor', slot: 'legs' } },
    { emoji: '',           label: '',                              action: null },
    { emoji: '',           label: '',                              action: null },
    { emoji: boots.emoji,  label: boots.name || 'é‹', empty: boots.empty, action: { type: 'armor', slot: 'boots' } },
    { emoji: '',           label: '',                              action: null },
  ];

  grid.forEach(cell => {
    const el = document.createElement('div');
    el.className = 'char-cell';
    const hasContent = cell.emoji || cell.action;
    if (hasContent) {
      if (cell.emoji) {
        el.textContent = cell.emoji;
        if (cell.empty) el.style.opacity = '0.3';
      } else if (cell.action) {
        el.classList.add('empty-slot');
      }
      if (cell.label) {
        const lbl = document.createElement('div');
        lbl.className = 'char-cell-label';
        lbl.textContent = cell.label;
        el.appendChild(lbl);
      }
      if (cell.action && size !== 'small') {
        el.classList.add('clickable');
        el.style.position = 'relative';
        el.addEventListener('click', (e) => {
          e.stopPropagation();
          if (cell.action.type === 'tool') {
            openToolPicker(el, cell.action.toolType);
          } else {
            openArmorPicker(el, cell.action.slot);
          }
        });
      }
    }
    display.appendChild(el);
  });

  container.appendChild(display);
}

function initCollection() {
  const area = document.getElementById('collectionArea');
  area.textContent = '';

  // Sub-tabs
  const tabs = document.createElement('div');
  tabs.className = 'collection-tabs';
  ['encyclopedia', 'craft', 'house', 'equip'].forEach(view => {
    const labels = { encyclopedia: 'ğŸ“– åœ–é‘‘', craft: 'ğŸ”¨ åˆæˆ', house: 'ğŸ  è“‹æˆ¿å­', equip: 'ğŸ‘¤ è£å‚™' };
    const btn = document.createElement('button');
    btn.className = 'collection-tab' + (collectionView === view ? ' active' : '');
    btn.textContent = labels[view];
    btn.addEventListener('click', () => { collectionView = view; initCollection(); });
    tabs.appendChild(btn);
  });
  area.appendChild(tabs);

  const content = document.createElement('div');
  content.id = 'collectionContent';
  area.appendChild(content);

  if (collectionView === 'encyclopedia') renderEncyclopedia(content);
  else if (collectionView === 'craft') renderCraft(content);
  else if (collectionView === 'house') renderHouse(content);
  else if (collectionView === 'equip') renderEquipment(content);
}

function renderEncyclopedia(c) {
  const discoveredCount = discovered.size;
  const counter = document.createElement('div');
  counter.style.cssText = 'text-align:center;margin-bottom:12px;font-family:Fredoka,sans-serif;color:#636E72';
  counter.textContent = `å·²ç™¼ç¾ ${discoveredCount} / ${blocks.length} ç¨®ç‰©å“`;
  c.appendChild(counter);

  const grid = document.createElement('div');
  grid.className = 'encyclopedia-grid';
  blocks.forEach(b => {
    const count = getBlockCount(b.id);
    const owned = discovered.has(b.id);
    const card = document.createElement('div');
    card.className = 'block-card ' + (owned ? 'owned' : 'undiscovered');
    if (b.tier > 0) card.style.borderBottomColor = tierColors[b.tier - 1];
    else card.style.borderBottomColor = '#A29BFE'; // tools

    const emoji = document.createElement('div');
    emoji.className = 'block-emoji';
    emoji.textContent = owned ? b.emoji : 'â“';
    const name = document.createElement('div');
    name.className = 'block-name';
    name.textContent = owned ? b.name : '???';
    const cnt = document.createElement('div');
    cnt.className = 'block-count';
    cnt.textContent = owned ? `x${count}` : 'æœªç™¼ç¾';
    const tier = document.createElement('div');
    tier.className = 'block-tier';
    tier.textContent = b.tier > 0 ? 'â­'.repeat(b.tier) : 'ğŸ”§';

    card.appendChild(emoji);
    card.appendChild(name);
    card.appendChild(cnt);
    card.appendChild(tier);
    grid.appendChild(card);
  });
  c.appendChild(grid);
}

// ===== CRAFTING TABLE =====
let craftGrid = [null,null,null, null,null,null, null,null,null]; // 9 slots, block id or null
let craftSelected = null; // selected block id from inventory

function renderCraft(c) {
  // craftGrid persists across tab switches (items are already deducted from inventory)

  const currentPick = pickaxes[getEffectivePickaxeLevel()];
  const current = document.createElement('div');
  current.className = 'craft-current';
  const axeB = getEffectiveAxeBonus();
  const axeStr = axeB > 1 ? `  |  ğŸª“ æ–§é ­ï¼ˆç æ¨¹ x${axeB}ï¼‰` : '';
  current.textContent = `â›ï¸ ${currentPick.name}${axeStr}`;
  c.appendChild(current);

  const area = document.createElement('div');
  area.className = 'craft-area';

  // Onboarding guide
  const guide = document.createElement('div');
  guide.className = 'craft-guide';
  guide.textContent = 'â‘  èƒŒåŒ…é¸ææ–™ â†’ â‘¡ é»æ ¼å­æ”¾å…¥ â†’ â‘¢ æŒ‰åˆæˆï¼';
  area.appendChild(guide);

  // Craft table: grid + arrow + result
  const table = document.createElement('div');
  table.className = 'craft-table';

  const grid = document.createElement('div');
  grid.className = 'craft-grid';
  grid.id = 'craftGrid';
  for (let i = 0; i < 9; i++) {
    const slot = document.createElement('div');
    slot.className = 'craft-slot';
    slot.dataset.idx = i;
    slot.addEventListener('click', () => craftSlotClick(i));
    grid.appendChild(slot);
  }
  table.appendChild(grid);

  const arrow = document.createElement('div');
  arrow.className = 'craft-arrow';
  arrow.textContent = 'â¡ï¸';
  table.appendChild(arrow);

  const resultSlot = document.createElement('div');
  resultSlot.className = 'craft-result-slot';
  resultSlot.id = 'craftResultSlot';
  resultSlot.style.cursor = 'pointer';
  resultSlot.addEventListener('click', () => {
    if (checkCraftMatch()) doCraft();
  });
  table.appendChild(resultSlot);

  area.appendChild(table);

  // Action buttons
  const actions = document.createElement('div');
  actions.className = 'craft-actions';
  const craftBtn = document.createElement('button');
  craftBtn.className = 'craft-btn primary';
  craftBtn.id = 'craftBtn';
  craftBtn.textContent = 'ğŸ”¨ åˆæˆ';
  craftBtn.disabled = true;
  craftBtn.addEventListener('click', doCraft);
  const clearBtn = document.createElement('button');
  clearBtn.className = 'craft-btn secondary';
  clearBtn.textContent = 'ğŸ”„ æ¸…ç©º';
  clearBtn.addEventListener('click', () => {
    // Return all placed blocks to inventory
    craftGrid.forEach(id => { if (id) addBlock(id); });
    craftGrid = [null,null,null, null,null,null, null,null,null];
    updateCraftUI();
  });
  actions.appendChild(craftBtn);
  actions.appendChild(clearBtn);
  area.appendChild(actions);

  // Inventory panel
  const inv = document.createElement('div');
  inv.className = 'craft-inventory';
  const invTitle = document.createElement('div');
  invTitle.className = 'craft-inv-title';
  invTitle.textContent = 'ğŸ’ èƒŒåŒ…ï¼ˆé»é¸æ–¹å¡Šå†æ”¾åˆ°æ ¼å­ä¸Šï¼‰';
  inv.appendChild(invTitle);
  const invGrid = document.createElement('div');
  invGrid.className = 'craft-inv-grid';
  invGrid.id = 'craftInvGrid';
  inv.appendChild(invGrid);
  area.appendChild(inv);

  c.appendChild(area);

  // Recipe book
  renderRecipeBook(c);

  updateCraftUI();
}

function renderRecipeBook(c) {
  const book = document.createElement('div');
  book.className = 'recipe-book';
  const title = document.createElement('div');
  title.className = 'recipe-book-title';
  title.textContent = 'ğŸ“œ åˆæˆè¡¨ Recipes';
  book.appendChild(title);

  // Collect recipes by category
  const categories = [
    { name: 'â›ï¸ å·¥å…· Tools', recipes: [] },
    { name: 'ğŸª“ æ–§ Axes', recipes: [] },
    { name: 'ğŸ—¡ï¸ æ­¦å™¨ Weapons', recipes: [] },
    { name: 'ğŸ›¡ï¸ ç›”ç”² Armor', recipes: [] },
    { name: 'ğŸ”§ å…¶ä»– Other', recipes: [] },
  ];

  pickaxes.forEach((pick) => {
    if (!pick.pattern) return;
    categories[0].recipes.push({
      pattern: pick.pattern, emoji: pick.emoji, name: pick.name,
      needs: pick.recipe, itemId: pick.id, type: 'pickaxe'
    });
  });
  axes.forEach((axe) => {
    categories[1].recipes.push({
      pattern: axe.pattern, emoji: axe.emoji, name: axe.name,
      needs: axe.recipe, itemId: axe.id, type: 'axe'
    });
  });
  swords.forEach((sword) => {
    if (!sword.pattern) return;
    categories[2].recipes.push({
      pattern: sword.pattern, emoji: sword.emoji, name: sword.name,
      needs: sword.recipe, itemId: sword.id, type: 'sword'
    });
  });
  armorRecipes.forEach((armor) => {
    const b = blocks.find(x => x.id === armor.outputId);
    categories[3].recipes.push({
      pattern: armor.pattern, emoji: b ? b.emoji : '?', name: b ? b.name : armor.outputId,
      needs: armor.recipe, itemId: armor.outputId, type: 'armor'
    });
  });
  craftRecipes.forEach(recipe => {
    const needs = recipe.needs || {};
    const pattern = recipe.pattern || (recipe.shapeless ?
      (() => {
        const p = [null,null,null, null,null,null, null,null,null];
        const ids = Object.entries(needs);
        if (ids.length === 1) { p[4] = ids[0][0]; }
        return p;
      })() : [null,null,null, null,null,null, null,null,null]);
    categories[4].recipes.push({
      pattern, emoji: recipe.emoji,
      name: recipe.name + ' x' + recipe.outputCount,
      needs, itemId: recipe.outputId, type: 'item',
      shapeless: recipe.shapeless
    });
  });

  categories.forEach((cat, catIdx) => {
    if (cat.recipes.length === 0) return;

    const section = document.createElement('div');
    section.className = 'recipe-category';

    const header = document.createElement('div');
    header.className = 'recipe-category-header';
    header.textContent = cat.name + ' (' + cat.recipes.length + ')';
    let expanded = catIdx < 3;
    header.addEventListener('click', () => {
      expanded = !expanded;
      list.style.display = expanded ? 'flex' : 'none';
      header.classList.toggle('collapsed', !expanded);
    });
    if (!expanded) header.classList.add('collapsed');
    section.appendChild(header);

    const list = document.createElement('div');
    list.className = 'recipe-list';
    list.style.display = expanded ? 'flex' : 'none';

    cat.recipes.forEach(r => {
      const canCraft = hasBlocks(r.needs);
      const owned = r.itemId ? getBlockCount(r.itemId) : 0;
      const card = document.createElement('div');
      card.className = 'recipe-card' + (canCraft ? ' craftable' : '');

      const miniGrid = document.createElement('div');
      miniGrid.className = 'recipe-mini-grid';
      r.pattern.forEach(slot => {
        const cell = document.createElement('div');
        cell.className = 'recipe-mini-slot';
        if (slot) {
          const b = blocks.find(x => x.id === slot);
          if (b) cell.textContent = b.emoji;
        }
        miniGrid.appendChild(cell);
      });
      card.appendChild(miniGrid);

      const arrow = document.createElement('div');
      arrow.className = 'recipe-arrow';
      arrow.textContent = 'â¡ï¸';
      card.appendChild(arrow);

      const result = document.createElement('div');
      result.className = 'recipe-result';
      result.textContent = r.emoji;
      card.appendChild(result);

      const info = document.createElement('div');
      info.className = 'recipe-info';
      const nameEl = document.createElement('div');
      nameEl.className = 'recipe-name';
      const ownedLabel = owned > 0 ? ' (æ“æœ‰ x' + owned + ')' : '';
      nameEl.textContent = r.name + ownedLabel + (r.shapeless ? ' (ä»»æ„ä½ç½®)' : '');
      info.appendChild(nameEl);

      const needsEl = document.createElement('div');
      needsEl.className = 'recipe-needs';
      Object.entries(r.needs).forEach(([id, count], idx) => {
        const b = blocks.find(x => x.id === id);
        const have = getBlockCount(id);
        const span = document.createElement('span');
        span.className = have >= count ? 'has' : 'need';
        span.textContent = (b ? b.emoji : id) + ' ' + have + '/' + count;
        if (idx > 0) needsEl.appendChild(document.createTextNode('  '));
        needsEl.appendChild(span);
      });
      info.appendChild(needsEl);
      card.appendChild(info);

      list.appendChild(card);
    });

    section.appendChild(list);
    book.appendChild(section);
  });

  c.appendChild(book);
}

function craftSlotClick(idx) {
  if (craftGrid[idx]) {
    // Remove block from grid, return to inventory
    playPlaceSfx();
    addBlock(craftGrid[idx]);
    craftGrid[idx] = null;
    updateCraftUI();
  } else if (craftSelected && getBlockCount(craftSelected) > 0) {
    // Place selected block
    playPlaceSfx();
    craftGrid[idx] = craftSelected;
    // Deduct from inventory (temporarily)
    inventory[craftSelected] = (inventory[craftSelected] || 0) - 1;
    if (inventory[craftSelected] <= 0) delete inventory[craftSelected];
    saveGame();
    updateCraftUI();
  }
}

function checkCraftMatch() {
  // Check pickaxe recipes (all repeatable)
  for (const pick of pickaxes) {
    if (!pick.pattern) continue;
    const match = pick.pattern.every((need, i) => {
      if (need === null) return craftGrid[i] === null;
      return craftGrid[i] === need;
    });
    if (match) return { type: 'pickaxe', item: pick, emoji: pick.emoji, name: pick.name };
  }
  // Check axe recipes
  for (const axe of axes) {
    const match = axe.pattern.every((need, i) => {
      if (need === null) return craftGrid[i] === null;
      return craftGrid[i] === need;
    });
    if (match) return { type: 'axe', item: axe, emoji: axe.emoji, name: axe.name };
  }
  // Check sword recipes
  for (const sword of swords) {
    if (!sword.pattern) continue;
    const match = sword.pattern.every((need, i) => {
      if (need === null) return craftGrid[i] === null;
      return craftGrid[i] === need;
    });
    if (match) return { type: 'sword', item: sword, emoji: sword.emoji, name: sword.name };
  }
  // Check armor recipes
  for (const armor of armorRecipes) {
    const match = armor.pattern.every((need, i) => {
      if (need === null) return craftGrid[i] === null;
      return craftGrid[i] === need;
    });
    if (match) {
      const b = blocks.find(x => x.id === armor.outputId);
      return { type: 'armor', item: armor, emoji: b.emoji, name: b.name };
    }
  }
  // Check general recipes
  for (const recipe of craftRecipes) {
    if (recipe.shapeless) {
      // Shapeless: count placed blocks, must match needs exactly
      const placed = {};
      craftGrid.forEach(id => { if (id) placed[id] = (placed[id] || 0) + 1; });
      const placedKeys = Object.keys(placed);
      const needKeys = Object.keys(recipe.needs);
      if (placedKeys.length === needKeys.length &&
          needKeys.every(k => placed[k] === recipe.needs[k])) {
        return { type: 'item', item: recipe, emoji: recipe.emoji, name: `${recipe.name} x${recipe.outputCount}` };
      }
    } else if (recipe.pattern) {
      const match = recipe.pattern.every((need, i) => {
        if (need === null) return craftGrid[i] === null;
        return craftGrid[i] === need;
      });
      if (match) return { type: 'item', item: recipe, emoji: recipe.emoji, name: `${recipe.name} x${recipe.outputCount}` };
    }
  }
  return null;
}

function updateCraftUI() {
  // Update grid slots
  const gridEl = document.getElementById('craftGrid');
  if (!gridEl) return;
  const slots = gridEl.children;
  for (let i = 0; i < 9; i++) {
    const slot = slots[i];
    slot.textContent = '';
    slot.classList.toggle('filled', craftGrid[i] !== null);
    if (craftGrid[i]) {
      const b = blocks.find(x => x.id === craftGrid[i]);
      if (b) slot.textContent = b.emoji;
    }
  }

  // Check for recipe match
  const match = checkCraftMatch();
  const resultSlot = document.getElementById('craftResultSlot');
  const craftBtn = document.getElementById('craftBtn');
  if (resultSlot) {
    resultSlot.textContent = match ? match.emoji : '';
    resultSlot.classList.toggle('matched', !!match);
  }
  if (craftBtn) craftBtn.disabled = !match;

  // Update inventory panel
  const invGrid = document.getElementById('craftInvGrid');
  if (!invGrid) return;
  invGrid.textContent = '';
  blocks.forEach(b => {
    const count = getBlockCount(b.id);
    if (count <= 0) return;
    const item = document.createElement('div');
    item.className = 'craft-inv-item' + (craftSelected === b.id ? ' selected' : '');
    item.textContent = b.emoji;
    const countEl = document.createElement('span');
    countEl.className = 'inv-count';
    countEl.textContent = count;
    item.appendChild(countEl);
    // Show durability bar for tools
    if (toolDurability[b.id] && b.tier === 0) {
      const toolDef = pickaxes.find(p => p.id === b.id) || axes.find(a => a.id === b.id) || swords.find(s => s.id === b.id);
      if (toolDef && toolDef.durability !== Infinity) {
        const pct = (toolDurability[b.id] / toolDef.durability) * 100;
        const barColor = pct > 50 ? '#00B894' : pct > 20 ? '#FDCB6E' : '#FF6B6B';
        const bar = document.createElement('div');
        bar.style.cssText = `position:absolute;bottom:0;left:2px;right:2px;height:3px;border-radius:2px;background:rgba(0,0,0,0.2);`;
        const fill = document.createElement('div');
        fill.style.cssText = `height:100%;width:${pct}%;border-radius:2px;background:${barColor};transition:width 0.3s;`;
        bar.appendChild(fill);
        item.appendChild(bar);
      }
    }
    item.addEventListener('click', (e) => {
      e.stopPropagation();
      craftSelected = (craftSelected === b.id) ? null : b.id;
      updateCraftUI();
    });
    invGrid.appendChild(item);
  });
}

function doCraft() {
  const match = checkCraftMatch();
  if (!match) return;
  playCraftSfx();
  // Clear the grid (blocks already deducted when placed)
  craftGrid = [null,null,null, null,null,null, null,null,null];

  if (match.type === 'pickaxe' || match.type === 'axe' || match.type === 'sword') {
    addBlock(match.item.id);
    if (!toolDurability[match.item.id] && match.item.durability !== Infinity) {
      toolDurability[match.item.id] = match.item.durability;
    }
  } else if (match.type === 'armor') {
    addBlock(match.item.outputId);
  } else if (match.type === 'item') {
    addBlock(match.item.outputId, match.item.outputCount);
  }

  saveGame();
  doConfetti();
  initCollection();
}

function getHouseArt() {
  const arts = [
    'ğŸŒ³  ğŸŒ¿  ğŸŒ³\n\n   ç©ºåœ°\n\nğŸŒ¿  ğŸŒ³  ğŸŒ¿',
    'ğŸŒ³       ğŸŒ³\n\nğŸ§±ğŸ§±ğŸ§±ğŸ§±\nğŸ§±           ğŸ§±\nğŸ§±ğŸ§±ğŸ§±ğŸ§±',
    'ğŸŒ³       ğŸŒ³\n\nğŸ§±ğŸªµğŸªµğŸ§±\nğŸªµ           ğŸªµ\nğŸ§±ğŸªµğŸªµğŸ§±',
    '     ğŸ”º\n   / ğŸªµ \\\n  / ğŸªµğŸªµ \\\nğŸ§±ğŸªµğŸªµğŸ§±\nğŸªµ  ğŸšª  ğŸªµ\nğŸ§±ğŸªµğŸªµğŸ§±',
    '    â­\n     ğŸ”º\n   / ğŸªµ \\\n  / ğŸªµğŸªµ \\\nğŸ§±ğŸªµğŸªµğŸ§±\nğŸªµ  ğŸšª  ğŸªµ\nğŸ§±ğŸ’šğŸŸ¡ğŸ§±',
  ];
  return arts[houseProgress] || arts[arts.length - 1];
}

function renderHouse(c) {
  const houseArea = document.createElement('div');
  houseArea.className = 'house-area';

  const visual = document.createElement('div');
  visual.className = 'house-visual';
  visual.textContent = getHouseArt();
  houseArea.appendChild(visual);

  const stagesEl = document.createElement('div');
  houseStages.forEach((stage, i) => {
    const done = i < houseProgress;
    const isCurrent = i === houseProgress;
    const canBuild = isCurrent && hasBlocks(stage.needs);

    const el = document.createElement('div');
    el.className = 'house-stage ' + (done ? 'done' : isCurrent ? 'current' : 'locked');

    const info = document.createElement('div');
    info.className = 'house-stage-info';
    const nameEl = document.createElement('div');
    nameEl.className = 'house-stage-name';
    nameEl.textContent = `${stage.emoji} ${stage.name} ${done ? 'âœ…' : ''}`;
    info.appendChild(nameEl);

    const needsEl = document.createElement('div');
    needsEl.className = 'house-stage-needs';
    if (done) {
      needsEl.textContent = 'å®Œæˆ';
    } else {
      Object.entries(stage.needs).forEach(([id, count], idx) => {
        const b = blocks.find(x => x.id === id);
        const have = getBlockCount(id);
        const span = document.createElement('span');
        span.className = have >= count ? 'has' : 'need';
        span.textContent = `${b.emoji} ${have}/${count}`;
        if (idx > 0) needsEl.appendChild(document.createTextNode('  '));
        needsEl.appendChild(span);
      });
    }
    info.appendChild(needsEl);
    el.appendChild(info);

    if (isCurrent) {
      const btn = document.createElement('button');
      btn.className = 'house-build-btn';
      btn.textContent = 'å»ºé€ ';
      btn.disabled = !canBuild;
      btn.addEventListener('click', () => {
        removeBlocks(stage.needs);
        houseProgress++;
        saveGame();
        doConfetti();
        initCollection();
      });
      el.appendChild(btn);
    }

    stagesEl.appendChild(el);
  });
  houseArea.appendChild(stagesEl);
  c.appendChild(houseArea);
}

function renderEquipment(c) {
  const area = document.createElement('div');
  area.className = 'equip-area';

  const hint = document.createElement('div');
  hint.style.cssText = 'text-align:center;font-family:Fredoka,sans-serif;font-size:0.8rem;color:#B2BEC3;margin-bottom:4px;';
  hint.textContent = 'ğŸ‘† é»æ“Šéƒ¨ä½å¯æ›´æ›è£å‚™èˆ‡å·¥å…·';
  area.appendChild(hint);

  const charContainer = document.createElement('div');
  renderCharacter(charContainer, 'large');
  area.appendChild(charContainer);

  c.appendChild(area);
}

// ===== INIT =====
loadGame();
initLearn();

// Settings modal
const settingsModal = document.getElementById('settingsModal');
const settingsBtn = document.getElementById('settingsBtn');
const settingsClose = document.getElementById('settingsClose');
settingsBtn.addEventListener('click', () => { settingsModal.classList.add('active'); });
settingsClose.addEventListener('click', () => { settingsModal.classList.remove('active'); });
settingsModal.addEventListener('click', (e) => {
  if (e.target === settingsModal) settingsModal.classList.remove('active');
});

// Mute toggle
isMuted = localStorage.getItem('isMuted') === 'true';
const muteOffBtn = document.getElementById('muteOff');
const muteOnBtn = document.getElementById('muteOn');
function updateMuteUI() {
  muteOffBtn.classList.toggle('active', !isMuted);
  muteOnBtn.classList.toggle('active', isMuted);
}
updateMuteUI();
muteOffBtn.addEventListener('click', () => { isMuted = false; localStorage.setItem('isMuted', 'false'); updateMuteUI(); });
muteOnBtn.addEventListener('click', () => { isMuted = true; localStorage.setItem('isMuted', 'true'); updateMuteUI(); });

// Pre-warm: load voices so pickBestVoice works on first click
if (window.speechSynthesis) {
  speechSynthesis.getVoices();
  speechSynthesis.onvoiceschanged = () => {
    cachedVoice = null; // re-pick on voice list change
    speechSynthesis.getVoices();
  };
}
</script>
</body>
</html>
